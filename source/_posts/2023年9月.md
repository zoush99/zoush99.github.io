---
title: 2023年9月
date: 2023-09-05 21:00:26
tags: 
- log
- project
categories: 
- log
- learn
typora-root-url: ./../
---

# 问题日志

<!--more-->

## Flang运行命令`flang function.f90 -o function.exe`遇到问题：

```
/usr/bin/ld: cannot find -lflangmain
/usr/bin/ld: cannot find -lflang
/usr/bin/ld: cannot find -lflangrti
/usr/bin/ld: cannot find -lpgmath
clang-14: error: linker command failed with exit code 1 (use -v to see invocation)
```

解决办法：[解决/usr/bin/ld: cannot find -lxxx_crocodile的记录空间的技术博客_51CTO博客](https://blog.51cto.com/crocodile/964277?articleABtest=1)

分析原因：编译Flang生成的动态库没有放到/usr/lib中，因此在使用时找不到该库。现在需要将这些文件放到系统指定查找的位置。

也就是将编译好的文件复制到默认查找的库的地址下去：`sudo cp -a lib* /usr/lib/`，这样就能解决问题了。

## linux下的so、a和o文件的区别

如一个C程序，经过gcc编译后得到的依次是：.i,.s,.o。分别是预处理文件、汇编文件和二进制文件（单元编译的结果），将许多单元编译的.o文件链接成一个文件后，便是编译产物。

.o是中间文件，相当于windows系统下的.obj文件 。

.a为静态库，是好多个.o合在一起,用于静态链接， 相当于windows系统下的lib。

.so 为共享库，是shared object,用于动态链接的，相当于windows系统下的dll。

## gcc的编译过程

编译过程的分步执行：
为了更好地理解gcc的工作过程，我们可以让在gcc工作的**4个阶段**中的任何一个阶段中停止下来。相关的参数有：
**-E**
预编译后停下来，生成后缀为 **.i 的预编译文件**。
**-c**
编译后停下来，生成后缀为 **.o 的目标文件**。
**-S**
汇编后停下来，生成后缀为 **.s 的汇编源文件**。

第一步：进行预编译，使用 -E 参数
`gcc -E test.c -o test.i`
查看 test.i 文件中的内容，会发现 stdio.h 的内容确实都插到文件里去了，而其他应当被预处理的宏定义也都做了相应的处理。
第二步：将 test.i 编译为目标代码，使用 -c 参数
`gcc -c test.c -o test.o`
第三步：生成汇编源文件
`gcc -S test.c -o test.s`
第四步：将生成的目标文件链接成可执行文件
`gcc test.o - o test`

对于稍微复杂的情况，比如有多个源代码文件、需要链接库或有其他比较特别的要求，就要给定适当的调用选项参数。

## 解决Flang和IKOS适配问题的思路

![image-20230906101050110](/paper_source/2023年9月/Flang与IKOS适配思路.jpg)

## pragma once的使用规则

`#pragma once`是一个比较常用的C/C++[预处理](https://so.csdn.net/so/search?q=预处理&spm=1001.2101.3001.7020)指令，只要在头文件的最开始加入这条预处理指令，就能够保证头文件只被编译一次，防止头文件被重复引用。

**“被重复引用”**指[头文件](https://so.csdn.net/so/search?q=头文件&spm=1001.2101.3001.7020)在cpp文件中多次被include，include嵌套造可能现象造成头文件多次引用。

作用都是为了避免同一个被 #include 多次，或者避免头文件嵌套包含（参照前置声明的笔记）。需要特别注意的是：

+ #pragma once 并不是C++的原生语法，而是编译器的一种支持，所以并不是所有的编译器都能够支持。#ifndef 则为C++的标准。

+ #ifndef 依赖于不重复的宏名称，保证了包含在 #endif 的内容不会被重复包含，这个内容可以是一个文件的所有内容，或者仅仅是一段代码。而 #pragma once 则是针对物理文件的一个标记，标记该文件不会被 #include 多次，不能只针对文件中某段代码进行标记。而且，#pragma once 不能保证多个文件的拷贝不会被重复包含，但这种错误更容易发现，且 #pragma once 大大提高了编译效率。

+ 一般建议用 #pragma once，因为一个类声明和定义各占用一个物理文件，即使类声明之外的内容，也应该是和该类有关，比如非模板类中声明了模板接口，则需要在同一个文件定义该模板接口。

```c++
#ifndef 自定义的宏名称
#define 自定义的宏名称
...整个文件的内容，或某段代码...
#endif

// 标记当前物理文件只会被包含一次，但如果文件有多个拷贝，也会被重复包含
#pragma once 
```

## namespace：命名空间的定义

在C语言中只有一个全局作用域：

1. C语言中所有的全局标识符共享一个作用域
2. 标识符之间可能发生冲突

C++中提出了命名空间的概念：

1. 命名空间将全局作用域分成不同的部分
2. 不同命名空间中的标识符可以同名而不会发生冲突
3. 命名空间可以发生嵌套
4. 全局作用域也叫默认命名空间

```c++
namespace Name
{
	namespace Internal
	{
		/*...*/
	}
	/*...*/
}
```

C++命名空间的使用：

1. 使用整个命名空间：`using namespace name;`
2. 使用命名空间中的变量：`using name::variable;`
3. 使用默认命名空间中的变量:  `::variable;`

```c++
#include <stdio.h>
#include <iostream>
namespace First 
{
	int i = 0;
}
 
namespace Second
{
	int i = 1;
 
	namespace Internal //嵌套命名空间
	{
		struct P  //嵌套命名空间
		{
			int x;
			int y;
		};
	}
}
 
int main()
{
	using namespace First; //使用整个命名空间
	using Second::Internal::P;  //使用嵌套的命名空间
 
	printf("First::i = %d\n", i);
	printf("Second::i = %d\n", Second::i);  //使用命名空间中的变量
 
	P p = { 2, 3 };
 
	printf("p.x = %d\n", p.x);
	printf("p.y = %d\n", p.y);
 
	system("pause");
	return 0;
}
```

## unordered_map容器用法

```c++
#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;
int main()
{
    //创建空 umap 容器
    unordered_map<string, string> umap;
    //向 umap 容器添加新键值对
    umap.emplace("Python教程", "http://c.biancheng.net/python/");
    umap.emplace("Java教程", "http://c.biancheng.net/java/");
    umap.emplace("Linux教程", "http://c.biancheng.net/linux/");

    //输出 umap 存储键值对的数量
    cout << "umap size = " << umap.size() << endl;
    //使用迭代器输出 umap 容器存储的所有键值对
    for (auto iter = umap.begin(); iter != umap.end(); ++iter) {
        cout << iter->first << " " << iter->second << endl;
    }
    return 0;
}
```

具体使用讲解见网址：[C++ STL unordered_map容器用法详解 (biancheng.net)](http://c.biancheng.net/view/7231.html)

## C++语法中explicit关键字的使用及示例

`explicit` 是 C++ 语言中的一个关键字，它可以用来修饰单个参数的构造函数，表示该构造函数只能显式调用，禁止隐式转换。在 C++11 中，`explicit` 还可以用来修饰类型转换函数，表示只能显式进行类型转换。

下面是一个简单的示例，演示了 `explicit` 的使用：

```c++
#include <iostream>
using namespace std;

class A {
public:
    A(int x) : m_x(x) {}
    int get_x() const { return m_x; }
private:
    int m_x;
};

class B {
public:
    explicit B(int x) : m_x(x) {}
    int get_x() const { return m_x; }
private:
    int m_x;
};

void funcA(A a) {
    cout << "a.get_x() = " << a.get_x() << endl;
}

void funcB(B b) {
    cout << "b.get_x() = " << b.get_x() << endl;
}

int main() {
    A a1 = 1;
    funcA(a1); // 可以隐式转换
    // A a2 = 'a'; // 错误：不允许隐式转换

    B b1 = 2;
    // funcB(b1); // 错误：只能显式转换
    funcB(static_cast<B>(3)); // 正确：显式转换
    return 0;
}
```

详情见[C++语法糖(explicit关键字)详解以及示例代码 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/624294266)

## C++中的noexcept关键字的用法

在C++11标准中引入了`noexcept`关键字，它用于指示函数是否可能抛出异常。`noexcept`可以用于函数声明和函数定义中，如果将函数标记为`noexcept`，那么编译器就可以进行一些优化，从而提高程序性能。

`noexcept`关键字可以放在函数声明和函数定义的括号后面，表示该函数不会抛出任何异常。例如：

```c++
void myFunction() noexcept {
    // function body
}
```

更多细节请看[C++语法糖(noexcept关键字)详解以及示例代码 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/624737461#:~:text=在C%2B%2B11标准中引入了noexcept关键字，它用于指示函数是否可能抛出异常。,noexcept可以用于函数声明和函数定义中，如果将函数标记为noexcept，那么编译器就可以进行一些优化，从而提高程序性能。 noexcept关键字可以放在函数声明和函数定义的括号后面，表示该函数不会抛出任何异常。)

## C++中的const关键字使用

**const修饰成员函数：常函数**

- 成员函数后加`const`后我们称为这个函数为**常函数**
- 常函数内不可以修改成员属性
- 成员属性声明时加关键字`mutable`后，在常函数中依然可以修改

```c++
class Person {
public: 
        void ShowPerson() const {
		this->m_B = 100;
	}
};
```

```c++
class Person {
public:
	Person() {
		m_A = 0;
		m_B = 0;
	}
	//this指针的本质是一个指针常量，指针的指向不可修改
	//如果想让指针指向的值也不可以修改，需要声明常函数
	void ShowPerson() const {
		//const Type* const pointer;
		//this = NULL; //不能修改指针的指向 Person* const this;
		//this->mA = 100; //但是this指针指向的对象的数据是可以修改的
		//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量
		this->m_B = 100;
	}
	void MyFunc() const {
		//mA = 10000;
	}
public:
	int m_A;
	mutable int m_B; //可修改 可变的
};
//const修饰对象  常对象
void test01() {

	const Person person; //常量对象  
	cout << person.m_A << endl;
	//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问
	person.m_B = 100; //但是常对象可以修改mutable修饰成员变量

	//常对象访问成员函数
	person.MyFunc(); //常对象不能调用const的函数

}

int main() {
	test01();
	system("pause");
	return 0;
}
```

细节请看[C++中const的5种用法总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/403182089)

## C++中的delete关键字使用

`delete`有2个作用：

1. 释放`new`分配的动态内存；
2. 阻止编译器自动合成函数；

**释放new分配的动态内存**

`delete`需要与`new`配对使用，其参数可以是指向一块内存首地址或空指针（`nullptr`）。不能对同一块内存多次delete，但是可以对空指针多次`delete`。

注意`delete`和`delete[] `的区别：

- `delete p `释放`p`指向的（单个）内存，可用于释放单个内存对象；
- `delete []p `释放`p`指向的内存区块，可用于释放一组内存（数组）；

```c++
// 释放基本类型内存
int *pi = new int(20);
delete pi;

// 释放类对象内存
int *ps = new string("hello");
delete ps; // 会调用string类析构函数

// 释放数组类型内存
int *pa = new int[10];
delete []pa;
```

**阻止编译器合成函数**

适用于C++11以上版本。

如果没有为类编写**构造函数、析构函数、拷贝构造函数、拷贝赋值运算符，以及移动拷贝函数、移动赋值运算符**，编译器可能会为类合成默认的函数版本。显式使用`delete`，可以阻止编译器合成对应函数。

```c++
class MyObj {
public:
  MyObj() = delete; // 阻止编译器合成构造函数，会导致类无法实例化
  MyObj& MyObj(const MyObj &) = delete; // 阻止编译器合成拷贝构造函数，会导致类无法拷贝构造，如std::cin, std::cout
  MyObj& operator=(const MyObj &) = delete; // 阻止合成赋值运算符，会导致类无法拷贝，如cin, cout, cerr
  ...
}
```



与`delete`对应的是`default`，`default`显式告诉编译器使用编译器自动合成的函数。
合成的默认构造函数，只有基类子对象和类类型对象会被初始化，而其他所有的非静态成员（如整数，指针，数组等），都不会初始化，对他们进行初始化的应该是程序员，而非编译器。

如果类包含了需要动态创建对象的指针，就不能依靠合成的构造函数、拷贝构造函数、拷贝赋值运算符。

详情见[C++> delete关键字初探 - 明明1109 - 博客园 (cnblogs.com)](https://www.cnblogs.com/fortunely/p/14554114.html)

## C++中的友元函数和友元类

在 C++ 中，一个类中可以有 `public`、`protected`、`private `三种属性的成员，通过对象可以访问 `public `成员，只有本类中的函数可以访问本类的 private 成员。现在，我们来介绍一种例外情况——友元（friend）。借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。

friend 的意思是朋友，或者说是好友，与好友的关系显然要比一般人亲密一些。我们会对好朋友敞开心扉，倾诉自己的秘密，而对一般人会谨言慎行，潜意识里就自我保护。在 C++ 中，这种友好关系可以用` friend `关键字指明，中文多译为“友元”，借助友元可以访问与其有好友关系的类中的私有成员。如果你对“友元”这个名词不习惯，可以按原文 friend 理解为朋友。

友元函数
在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。

**友元函数可以访问当前类中的所有成员，包括 `public`、`protected`、`private` 属性的。**

细节请看[C++友元函数和友元类（C++ friend关键字）_51CTO博客_c++ 友元](https://blog.51cto.com/u_15080016/4567286)

## C++中智能指针unique_ptr使用

C++ 标准提供了 3 种智能指针，分别是 `shared_ptr`、`unique_ptr` 和 `weak_ptr`，本节我们给大家讲解 `unique_ptr` 智能指针的特性和用法。

> 关于 shared_ptr 智能指针，可以阅读《[C++11 shared_ptr智能指针](http://c.biancheng.net/view/7898.html)》一节；关于 weak_ptr 智能指针，可以阅读《[C++11 weak_ptr智能指针](http://c.biancheng.net/view/vip_8673.html)》一节。

作为智能指针的一种，`unique_ptr` 指针自然也具备“在适当时机自动释放堆内存空间”的能力。和 `shared_ptr `指针最大的不同之处在于，unique_ptr 指针指向的堆内存无法同其它 unique_ptr 共享，也就是说，每个 `unique_ptr `指针都独自拥有对其所指堆内存空间的所有权。

> 这也就意味着，每个 unique_ptr 指针指向的堆内存空间的引用计数，都只能为 1，一旦该 unique_ptr 指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。

`unique_ptr `智能指针是以模板类的形式提供的，`unique_ptr<T>`（T 为指针所指数据的类型）定义在`<memory>`头文件，并位于 `std `命名空间中。因此，要想使用 `unique_ptr `类型指针，程序中应首先包含如下1条语句：

```c++
#include <memory>
```

**unique_ptr智能指针的创建**

考虑到不同实际场景的需要，`unique_ptr<T>` 模板类提供了多个实用的构造函数，这里给读者列举了几种常用的构造` unique_ptr `智能指针的方式。

1. 通过以下 2 种方式，可以创建出空的 unique_ptr 指针：
```c++
std::unique_ptr<int> p1();
std::unique_ptr<int> p2(nullptr);
```

2. 创建` unique_ptr` 指针的同时，也可以明确其指向。例如：

```c++
std::unique_ptr<int> p3(new int);
```

3. 基于` unique_ptr` 类型指针不共享各自拥有的堆内存，因此 C++11 标准中的 `unique_ptr` 模板类没有提供拷贝构造函数，只提供了移动构造函数。例如：

```c++
std::unique_ptr<int> p4(new int);
std::unique_ptr<int> p5(p4);//错误，堆内存不共享
std::unique_ptr<int> p5(std::move(p4));//正确，调用移动构造函数
```

值得一提的是，对于调用移动构造函数的 p4 和 p5 来说，p5 将获取 p4 所指堆空间的所有权，而 p4 将变成空指针（`nullptr`）。默认情况下，`unique_ptr` 指针采用 `std::default_delete<T> `方法释放堆内存。当然，我们也可以自定义

4. 符合实际场景的释放规则。值得一提的是，和 `shared_ptr` 指针不同，为 `unique_ptr` 自定义释放规则，只能采用函数对象的方式。例如：

```c++
//自定义的释放规则
struct myDel
{
    void operator()(int *p) {
        delete p;
    }
};
std::unique_ptr<int, myDel> p6(new int);
//std::unique_ptr<int, myDel> p6(new int, myDel());
```

详细内容请见[C++11 unique_ptr智能指针详解 (biancheng.net)](http://c.biancheng.net/view/7909.html)、[C++内存管理——unique_ptr - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/404771979)

## C++中的static关键字的使用

1. 全局静态变量，在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。**内存中的位置：** 静态存储区，在整个程序运行期间一直存在。**初始化**：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；**作用域**：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

2. 局部静态变量，在局部变量之前加上关键字`static`，局部变量就成为一个局部静态变量。内存中的位置：静态存储区。初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

3. 静态函数，在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是`extern`的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。函数的实现使用`static`修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；warning：不要再头文件中声明`static`的全局函数，不要在cpp内声明非`static`的全局函数，
   如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；

4. 类的静态成员，在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。
5. 类的静态函数，静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。

详情请查阅[C++ Static关键字作用介绍_WhiteTian的博客-CSDN博客](https://blog.csdn.net/u011718663/article/details/118218407)

## C++中的override的使用

### `virtual`：

- 放在函数的返回值前面，用于表示该成员函数为虚函数
- 父类虚函数前必须写；子类虚函数前可以省略（不管省不省略，该函数在子类中也是虚函数类型）
- virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义

### `override`：

- 父类的虚函数不可使用
- 放在子类虚函数的参数列表后（如果函数有尾指返回类型，那么要放在尾指返回类型后），用来说明此函数为覆盖(重写)父类的虚函数。如果类方法在类外进行定义，那么override不能加
- 不一定强制要求子类声明这个关键字，但是建议使用
- 这是C++11标准填入的

### `final`：

- 如果我们定义的一个虚函数不想被派生类覆盖（重写），那么可以在虚函数之后添加一个final关键字，声明这个虚函数不可以被派生类所覆盖（重写）
- 如果函数有尾指返回类型，那么要放在尾指返回类型后

细节见[C++:44---关键字virtual、override、final-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1784495)

## C++中的`static_cast`怎么用

仅根据表达式中存在的类型，将` expression` 转换为` type-id `类型。

```c++
static_cast <type-id> ( expression )
```

在标准 C++ 中，不进行运行时类型检查来帮助确保转换的安全。 在 C++/CX 中，将执行编译时和运行时检查。 有关更多信息，请参见 [强制转换](https://learn.microsoft.com/zh-cn/cpp/cpp/casting?view=msvc-170)中定义的接口的私有 C++ 特定实现。

`static_cast` 运算符可用于将指向基类的指针转换为指向派生类的指针等操作。 此类转换并非始终安全。

通常使用 `static_cast` 转换数值数据类型，例如将枚举型转换为整型或将整型转换为浮点型，而且你能确定参与转换的数据类型。 `static_cast` 转换安全性不如 `dynamic_cast` 转换，因为 `static_cast` 不执行运行时类型检查，而 `dynamic_cast` 执行该检查。 对不明确的指针的 `dynamic_cast` 将失败，而 `static_cast`的返回结果看似没有问题；这是危险的。 尽管 `dynamic_cast`转换更加安全，但是 `dynamic_cast`*只适用于指针或引用，而且运行时类型检查也是一项开销。 有关详细信息，请参阅 [dynamic_cast 运算符](https://learn.microsoft.com/zh-cn/cpp/cpp/dynamic-cast-operator?view=msvc-170)。

详情请见[static_cast 运算符 | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/cpp/static-cast-operator?view=msvc-170)

## C++中的`# ifdef`怎么用

可以在任何可以使用 `#if` 的地方使用 `#ifdef`*和 `#ifndef`指令。 如果定义了 `identifier`，`#ifdef``identifier` 语句等效于 `#if 1`。 如果 `identifier` 尚未定义或未被 `#undef`指令定义，它等效于 `#if 0`。 这些指令只检查使用 `#define` 定义的标识符是否存在，而不检查在 C 或 C++ 源代码中声明的标识符。

提供这些指令只是为了实现与该语言的早期版本的兼容性。 首选与 `#if` 指令一起使用的 `defined(``identifier`)` 常量表达式。

`#ifndef` 指令检查与 `#ifdef`检查的条件相反的情况。 如果尚未定义标识符，或者如果它的定义已用 `#undef` 删除，则条件为 `true`（非零值）。 否则，条件为 `false `(0)。

```c++
// ifdef_ifndef.CPP
// compile with: /Dtest /c
#ifndef test
#define final
#endif
```

## C++中的`# if, # elif, # endif`怎么用

源文件中的每个 `#if `指令必须与表示结束的` #endif` 指令匹配。 任意数量的 `#elif` 指令可以出现在 #if 和` #endif `指令之间，但最多允许一个` #else `指令。 `#else `指令（如果有）必须是` #endif `之前的最后一个指令。

`#if、#elif、#else `和 `#endif `指令可以嵌套在其他` #if `指令的 text 部分中。 每个嵌套的 `#else、#elif 或 #endif `指令属于最靠近的前面的 #if 指令。

所有条件编译指令（如 #if 和 #ifdef）都必须在文件末尾之前匹配一个 #endif 关闭指令。 否则会生成错误消息。 当条件编译指令包含在包含文件中时，这些指令必须满足相同的条件：包含文件的末尾不能有未匹配的条件编译指令。

在 #elif 命令后面的行部分中执行宏替换，以便能够在 constant-expression 中使用宏调用。

预处理器选择 text 的给定匹配项之一以进行进一步处理。 text 中指定的块可以是文本的任意序列。 它可占用多个行。 通常，text 是对编译器或预处理器有意义的程序文本。

预处理器处理选定的 text，并将其传递给编译器。 如果 text 包含预处理器指令，则预处理器将执行这些指令。 仅编译预处理器所选的文本块。

预处理器通过计算每个 #if 或 #elif 指令后面的常量表达式来选择单个 text 项，直到找到实际（非零）常量表达式。 它选择所有文本（包括以 **#** 开头的其他预处理器指令），直到其关联的 #elif、#else 或 #endif。

如果 constant-expression 的所有匹配项都为 false，或者 #elif 指令未出现，则预处理器将选择 #else 子句后面的文本块。 如果没有 #else 子句，并且 #if 块中的 constant-expression 的所有实例都为 false，则不选择文本块。

constant-expression 是具有下列其他限制的整数常量表达式：

- 表达式必须具有整型，并且只能包含整数常量、字符常量和 defined 运算符。
- 表达式不能使用 **`sizeof`** 或 type-cast 运算符。
- 目标环境无法表示整数的所有范围。
- 转换以与类型 **`long`** 相同的方式表示类型 **`int`**，并以与类型 **`unsigned long`** 相同的方式表示类型 **`unsigned int`**。
- 转换器可以将字符常量转换为与目标环境的集不同的代码值集。 若要确定目标环境的属性，请使用为该环境生成的应用程序来检查 LIMITS.H 宏的值。
- 该表达式不得查询环境，并且必须不受与目标计算机上的实现详细信息的影响。

```c++
#if defined(CREDIT)
    credit();
#elif defined(DEBIT)
    debit();
#else
    printerror();
#endif
```

```c++
#if DLEVEL > 5
    #define SIGNAL  1
    #if STACKUSE == 1
        #define STACK   200
    #else
        #define STACK   100
    #endif
#else
    #define SIGNAL  0
    #if STACKUSE == 1
        #define STACK   100
    #else
        #define STACK   50
    #endif
#endif
#if DLEVEL == 0
    #define STACK 0
#elif DLEVEL == 1
    #define STACK 100
#elif DLEVEL > 5
    display( debugptr );
#else
    #define STACK 200
#endif
```

具体请看[#if、#elif、#else 和 #endif 指令 (C/C++) | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=msvc-170)

## C++中的`typename`和`class`的区别



在 C++ Template 中很多地方都用到了 typename 与 class 这两个关键字，而且好像可以替换，是不是这两个关键字完全一样呢?

相信学习 C++ 的人对 class 这个关键字都非常明白，class 用于定义类，在模板引入 c++ 后，最初定义模板的方法为：

```c++
template<class T>......
```

这里 class 关键字表明T是一个类型，后来为了避免 class 在这两个地方的使用可能给人带来混淆，所以引入了 typename 这个关键字，它的作用同 class 一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了：

```c++
template<typename T>......
```

在模板定义语法中关键字 class 与 typename 的作用完全一样。

typename 难道仅仅在模板定义中起作用吗？其实不是这样，typename 另外一个作用为：**使用嵌套依赖类型(nested depended name)**，如下所示：

```c++
class MyArray 
{ 
    public：
    typedef int LengthType;
.....
}

template<class T>
void MyMethod( T myarr ) 
{ 
    typedef typename T::LengthType LengthType; 
    LengthType length = myarr.GetLength; 
}
```

这个时候 typename 的作用就是告诉 c++ 编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有 typename，编译器没有任何办法知道 T::LengthType 是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。

## C++中的`void*`怎么用

首先`void*`中的void代表一个任意的数据类型，"星号"代表一个指针，所以其就是一个任意数据类型的指针。

> 对于指定数据类型的指针如`int* ，double*`等，他们的sizeof都是4个字节，因为都是一个指针，只是指针指向的数据类型不一致。

**当函数传参时不确定数据类型时或者支持多种数据类型传递时。**

```c++
void say(int type,void* pArgs) {
    switch (type) 
    {
        case 0:
        {
            double* d = (double*)pArgs;
            break;
        }   
        case 1:
        {
            int* i = (int*)pArgs;
            break;
        }       
    }
}
```

**函数返回值不需要考虑类型，只关心返回的大小。**

```c++
void* malloc(size_t size)
```

代码使用

```c++
int* a = nullptr;
double* b = nullptr;
b = (double*)malloc(sizeof(double));
a = (int*)malloc(sizeof(double));
```

可以看到`malloc`返回值类型为`void*`，其只返回分配内存的大小，不关心分配后的内存你是使用int还是double类型进行划分.

> 注意：函数外部在接收到void*格式的返回值时，需要强转为自己的数据类型才能使用。

**当void*作为函数的参数类型或者返回值类型时，说明该函数可以接收或者返回任意类型的指针。**

代码如下：

```c++
void* _say(void* pArgs) {
    return pArgs;
}
int  main()
{
    int _a = 5;
    float f = 10.8;
    int* _pi = &_a;
    float* pf = &f;

    cout << *(int*)_say(_pi) << endl;
    cout << *(float*)_say(pf) << endl;

}
运行结果：
5
10.8
```

代码中可以看出参数`void* pArgs`可以使用任意类型的实参，返回值也可以返回任意类型的指针，但是最终需要转换为具体类型才能使用。

`void*`在C++中的作用其实就是为了实现**泛型编程**，和Java中使用Object来表示是一样的，所以又称为通用指针和泛指针，不过**C++中大部分情况下会使用模板编程来实现泛型**。

## 在项目中用doxygen写项目注释

**Doxygen语法简介**

所谓`Doxygen`语法就是在写程序注视时候按照`Doxygen`语法规则来写注释。只有按照标准的注释规则来写注释，生成的文档才会非常漂亮，否则乱七八糟的。

| 命令        | 字段名                                                       | 语法                                                      |
| ----------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| @file       | 文件名                                                       | file [< name >]                                           |
| @brief      | 简介                                                         | brief { brief description }                               |
| @author     | 作者                                                         | author { list of authors }                                |
| @mainpage   | 主页信息                                                     | mainpage [(title)]                                        |
| @date       | 年-月-日                                                     | date { date description }                                 |
| @author     | 版本号                                                       | version { version number }                                |
| @copyright  | 版权                                                         | copyright { copyright description }                       |
| @param      | 参数                                                         | param [(dir)] < parameter-name> { parameter description } |
| @return     | 返回                                                         | return { description of the return value }                |
| @retval     | 返回值                                                       | retval { description }                                    |
| @bug        | 漏洞                                                         | bug { bug description }                                   |
| @details    | 细节                                                         | details { detailed description }                          |
| @pre        | 前提条件                                                     | pre { description of the precondition }                   |
| @see        | 参考                                                         | see { references }                                        |
| @link       | 连接(与@see类库，{@link [http://www.google.com](https://link.zhihu.com/?target=http%3A//www.google.com)}) | link < link-object>                                       |
| @throw      | 异常描述                                                     | throw < exception-object> { exception description }       |
| @todo       | 待处理                                                       | todo { paragraph describing what is to be done }          |
| @warning    | 警告信息                                                     | warning { warning message }                               |
| @deprecated | 弃用说明。可用于描述替代方案，预期寿命等                     | deprecated { description }                                |
| @example    | 弃用说明。可用于描述替代方案，预期寿命等                     | deprecated { description }                                |

**文件注释**

一般放在文件开头

```text
/**
 * @file 文件名
 * @brief 简介
 * @details 细节
 * @author 作者
 * @version 版本号
 * @date 年-月-日
 * @copyright 版权
 */
```

**函数注释**

```text
/**
  * @brief 函数描述
  * @param 参数描述
  * @return 返回描述
  * @retval 返回值描述
  */
```

细节请看[干货|教你使用Doxygen制作漂亮的程序文档 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/510925324)

## C++中的`this`和`*this`的作用和区别

`return *this`返回的是当前对象的克隆或者本身（若返回类型为A， 则是克隆， 若返回类型为A&， 则是本身 ）。`return this`返回当前对象的地址（指向当前对象的指针）。

具体请见[C++中this与*this的区别_北海的星辰大海的博客-CSDN博客](https://blog.csdn.net/u011663005/article/details/106151786)

## C++中的`initializer_list`类型的简单使用

**initializer_list**是C++11提供的新数据类型，和`vector`一样，`initializer_list`也是一种模板类型。可以使用`.begin(), .end()` 等方法。

因为C++11扩大了初始化列表的适用范围，使其可用于所有内置类型和用户定义的类型。使用初始化列表时，可添加=等于号，也可不添加。

```c++
int  a={0} ; 
int  b{0} ;
vector<int> v = { 1, 2, 3, 4 } ;
vector<int> v{ 1, 2, 3, 4} ;
```

由此可见，`initializer_list` 还有一种用法是在构造函数或者其他函数中作为参数输入。能够简化一些操作。两个小例子：

第一个例子是在类中的构造函数中接收初始化列表。

```c++
class MyNumber{
public:
    MyNumber(const std::initializer_list<int> &v) {
        for (auto itm : v) {
            mVec.push_back(itm);
        }
    }

    void print() {
        for (auto itm : mVec) {
        std::cout << itm << " ";
        }
    }
private:
    std::vector<int> mVec;
};

int main(){
    MyNumber m = { 1, 2, 3, 4 };
    m.print();  // 1 2 3 4
    return 0;
}
```

第二个例子是在普通函数中接受初始化列表。

```c++
#include<iostream>
#include<initializer_list>

using namespace std;

double sum(initializer_list<double> il);
double average(const initializer_list<double> &ril);

double sum(initializer_list<double> il){
	double sum = 0;
	for (auto tmp : il) sum += tmp;
	return sum;
}

double average(const initializer_list<double> &ril){
	if (ril.size() > 0){
		double sum = 0;
		for (auto tmp : ril) sum += tmp;
		return sum / ril.size();
	}
	return 0.0;
}


int main(){
	cout << "sum:" << sum({ 2, 3, 4 }) << ", ave:" << average({ 2.0, 3, 4 }) << endl;
	initializer_list<double> dl = { 1.5, 2.5, 3.5, 4.5, 5.5 };
	cout << "sum:" << sum(dl) << ", ave:" << average(dl) << endl;
	dl = { 1, 2, 3, 4, 5, 6 };
	cout << "sum:" << sum(dl) << ", ave:" << average(dl) << endl;
	system("pause");
}
```

## C++运算符优先级

C++运算符优先级，是描述在计算机运算计算表达式时执行运算的先后顺序。 先执行具有较高优先级的运算，然后执行较低优先级的运算。 例如，我们常说的先执行相乘和除，再执行加减运算。



| 优先级 | 结合性 | 运算符                             | 备注                                                         |
| ------ | ------ | ---------------------------------- | ------------------------------------------------------------ |
| 1      | 左结合 | () [] -> .                         | 圆括号 下标运算符 指向结构体成员运算符 结构体成员运算符      |
| 2      | 右结合 | ! ~ ++ -- + - (类型) * & sizeof    | 逻辑非运算符 按位取反运算符 前缀增量运算符 前缀减量运算符 正号运算符 负号运算符 类型转换运算符 指针运算符 地址运算符 长度运算符 |
| 3      | 左结合 | * / %                              | 乘法运算符 除法运算符 取余运算符                             |
| 4      | 左结合 | + -                                | 加法运算符 减法运算符                                        |
| 5      | 左结合 | << >>                              | 左移运算符 右移运算符                                        |
| 6      | 左结合 | < <= > >=                          | 关系运算符                                                   |
| 7      | 左结合 | == !=                              | 等于运算符 不等于运算符                                      |
| 8      | 左结合 | &                                  | 按位与运算符                                                 |
| 9      | 左结合 | ^                                  | 按位异或运算符                                               |
| 10     | 结合性 | \|                                 | 按位或运算符                                                 |
| 11     | 左结合 | &&                                 | 逻辑与运算符                                                 |
| 12     | 左结合 | \|\|                               | 逻辑或运算符                                                 |
| 13     | 右结合 | ? :                                | 条件运算符                                                   |
| 14     | 右结合 | = += -= *= /= %= &= ^= \|= <<= >>= | 赋值运算符                                                   |
| 15     | 左结合 | ,                                  | 逗号运算符                                                   |

 细节请看[C++ 运算符优先级列表 - IAmAProgrammer - 博客园 (cnblogs.com)](https://www.cnblogs.com/shangdawei/p/3883702.html)

## C++中`for`循环的几种用法

```c++
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;

int main(int, char **)
{
    vector<int> list({0, 1, 2, 3, 4, 5, 6, 7, 8, 9});

    /* 下标法 */
    for (size_t i = 0; i < list.size(); i++) {
        cout<<list[i]; //or list.at(i)
    }

    /* 迭代器 */
    for (auto iter = list.begin(); iter != list.end(); ++iter) {
        cout<<*iter;
    }

    /* STL函数 */
    for_each(list.begin(), list.end(), [](int item){ cout<<item; });

    /* C++11新增加 */
    for(auto each : list) {
        cout<<each;
    }
}
```

详情请见[C++ for循环的几种用法-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1463130)

## 提问IKOS关于AR的问题

> Hi, everyone! do you have some syntactic details, or documentation, about your own design of the abstract representation language (AR)? When I read the source code, I find that there is a lot designed in it and it is not intuitive enough. Thank you guys! Thank you for doing the work for the program analysis and open-sourcing the results so that I have the opportunity to learn from it!



> Unfortunately, AR is pretty loosely documented.
> In a way, it is pretty similar to the LLVM language: https://llvm.org/docs/LangRef.html
> Each instruction is pretty much translated 1:1 into AR.
> You can find the implementation of the translation in https://github.com/NASA-SW-VnV/ikos/blob/master/frontend/llvm/src/import/function.cpp#L305
> The major differences are:
>
> - AR integer types are either signed or unsigned. LLVM integers do not have a signedness.
> - AR has a concept of local variables. LLVM has a[ `alloca` instruction](https://llvm.org/docs/LangRef.html#alloca-instruction) that allocates memory on the stack (effectively a local variable).
> - AR has names for variables, LLVM doesn't (names are in the debugging information, which uses a different format)
> - LLVM phi nodes and branching are translated into `ar::Comparison` statement within the control flow graph. Basically, `ar::Comparison` is an assert. To translate a `if(cond) { x =1 } else { x = 2 }` you would have 2 basic blocks, one with `Comparison(cond, NE, 0)` and one with `Comparison(cond, EQ, 0)`.

## LLVM IR中的bitcast指令用法

在 LLVM IR 中，`bitcast` 是一条指令，用于将一个值按照指定的类型进行位级别的转换，而不改变其内部表示。

`bitcast` 指令的语法如下：

```LLVM IR
%result = bitcast <source_type> <value> to <destination_type>
```

例如，下面的 LLVM IR 代码演示了将一个整数转换为浮点数的示例：

```LLVM IR
%value = load i32, i32* %ptr	;从指针%ptr加载一个整数值
%float_value = bitcast i32 %int_value to float	;将整数值转换为浮点数
```

在这个例子中，首先使用` load `指令从指针 `%ptr `加载一个整数值，并将其保存在 `%int_value` 变量中。然后，使用 `bitcast `指令将 `%int_value `的内部表示按照浮点数类型进行转换，并将结果保存在 `%float_value` 变量中。

需要注意的是，bitcast 指令只是对内部表示进行位级别的转换，并不改变值的语义。因此，在使用 `bitcast` 指令时，需要确保源类型和目标类型具有相同的大小和对齐方式，以避免不确定的行为。

此外，`bitcast `指令还可以用于指针类型的转换，例如将指向一个类型的指针转换为指向另一个类型的指针。这在某些情况下可以用于类型的转换和指针的重新解释。

详情请看[LLVM IR bitcast指令用法 - CSDN文库](https://wenku.csdn.net/answer/4jwo82yi7n)

## vim的用法

```sh
zou@zou-VirtualBox:~/Downloads/FortranProgram/chap03$ vim -help
VIM - Vi IMproved 8.1 (2018 May 18, compiled Aug 18 2023 03:41:54)

Usage: vim [arguments] [file ..]       edit specified file(s)
   or: vim [arguments] -               read text from stdin
   or: vim [arguments] -t tag          edit file where tag is defined
   or: vim [arguments] -q [errorfile]  edit file with first error

Arguments:
   --			Only file names after this
   -v			Vi mode (like "vi")
   -e			Ex mode (like "ex")
   -E			Improved Ex mode
   -s			Silent (batch) mode (only for "ex")
   -d			Diff mode (like "vimdiff")
   -y			Easy mode (like "evim", modeless)
   -R			Readonly mode (like "view")
   -Z			Restricted mode (like "rvim")
   -m			Modifications (writing files) not allowed
   -M			Modifications in text not allowed
   -b			Binary mode
   -l			Lisp mode
   -C			Compatible with Vi: 'compatible'
   -N			Not fully Vi compatible: 'nocompatible'
   -V[N][fname]		Be verbose [level N] [log messages to fname]
   -D			Debugging mode
   -n			No swap file, use memory only
   -r			List swap files and exit
   -r (with file name)	Recover crashed session
   -L			Same as -r
   -A			Start in Arabic mode
   -H			Start in Hebrew mode
   -T <terminal>	Set terminal type to <terminal>
   --not-a-term		Skip warning for input/output not being a terminal
   --ttyfail		Exit if input or output is not a terminal
   -u <vimrc>		Use <vimrc> instead of any .vimrc
   --noplugin		Don't load plugin scripts
   -p[N]		Open N tab pages (default: one for each file)
   -o[N]		Open N windows (default: one for each file)
   -O[N]		Like -o but split vertically
   +			Start at end of file
   +<lnum>		Start at line <lnum>
   --cmd <command>	Execute <command> before loading any vimrc file
   -c <command>		Execute <command> after loading the first file
   -S <session>		Source file <session> after loading the first file
   -s <scriptin>	Read Normal mode commands from file <scriptin>
   -w <scriptout>	Append all typed commands to file <scriptout>
   -W <scriptout>	Write all typed commands to file <scriptout>
   -x			Edit encrypted files
   --startuptime <file>	Write startup timing messages to <file>
   -i <viminfo>		Use <viminfo> instead of .viminfo
   --clean		'nocompatible', Vim defaults, no plugins, no viminfo
   -h  or  --help	Print Help (this message) and exit
   --version		Print version information and exit

```

## ubuntu上的一些常见指令

- **pwd（present working directory）**

显示当前的工作目录/路径。



- **cd (change directory)**

改变目录，用于输入需要前往的路径/目录。

有一些特殊命令也很常用 :

```text
前往同一级的另一个目录
cd ../directory name
cd .. 表示进入上层目录
cd ../.. 进入上上层目录，后面还可以加更多。
前往同一级的另一个目录
cd ../directory name
cd -  //表示返回上一次的目录
cd ~  //进入home主目录，即/home/用户名的简写
```

- **ls (list)**

ls 显示当前目录下的文件（不包括隐藏文件和缓存文件等）；

列出目录下所有文件

```text
ls -a 
```

ll , 以列表形式显示当前路径下的所有文件的详细信息（包括隐藏文件和缓存文件等）。



- **mkdir (make directory)**

创建目录，后面接上directory的名字。

```text
mkdir I_dont_care //创建一个“我不在乎”目录
```

- **rm (remove)**

删除文件，后面接上要删除的文件名。如果要删除目录，需要这样写：

```text
rm -I <目录名>  //这样做会删除指定目录中的所有子目录和包含的文件
```

- **touch**

创建任意格式的文件，包括源代码、文本等等，通过后缀来决定。例如，.cpp/.cc是c++源代码，而.py是python源代码。

```text
touch hello_world.cpp  //创建hello_world源代码
```



- **cp (copy)**

复制命令。通用格式为

```text
cp -? <源文件/源目录> <目的目录>  //第一个"-?"表示参数，出发地在左，目的地在右
```

特别的，如果想把某目录下所有文件都复制，可以使用参数-r

```text
cp -r cangjingkong/ xuexi    //将canjingkong目录下的所有资源都复制到xuexi目录中
```

- **mv (move)**

移动+重命名命令。格式类似于cp命令

```text
mv -? <源文件/源目录> <目的目录> //第一个"-?"表示参数，出发地在左，目的地在右
```

以移动txt文件为例 可以分为以下三种情况：

```text
mv a.txt b.txt                 //出发地和目的地是同一路径，名称从a.txt变为b.txt，那仅仅是重命名
mv ~/目录1/a.txt ~/目录2       //出发地和目的地是不同路径，没有指定新的名称，那仅仅是移动
mv ~/目录1/a.txt ~/目录2/b.txt //出发地和目的地是不同路径，指定了新的名称，那就是移动+重命名
```

常用的例子有，

移动目录到另一目录中

```text
mv 目录1/ 目录2
```

将某目录下所有的文件和目录都移动到当前目录下

```text
mv ~/videos/p_hub .
```



- **gedit**

在桌面临时新建一个text editor（文本编辑器）显示文件内的文本，并且支持修改。按ctrl+c退出文件显示。

```text
gedit <文件名>
```

例如，

```abap
gedit single_ladies_contacts.csv
```

- **cat**

在终端打印出文本内容。

```text
cat <文件名>  //在terminal内部打印，和gedit相区分
```

具体请看链接[Ubuntu常用命令 总结整理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/392986700)

## 回归测试是什么

回归测试（Regression Testing）是软件测试的一种类型，用于验证在进行软件修改或更新后，旧的功能仍然能够按照预期的方式正常工作，同时新功能或修复的问题也没有引入新的错误。回归测试旨在确保软件在经过修改后，仍然保持了与之前版本相同的稳定性和兼容性。

以下是回归测试的一些关键特点和解释：

1. **目的**：回归测试的主要目标是检测新的代码更改是否对现有功能产生了负面影响。它有助于确保已有的软件功能没有退化或损害，并且新功能、改进或修复的问题是有效的。

2. **自动化**：由于回归测试需要频繁地运行，通常采用自动化测试工具来执行。这些工具能够自动运行一系列测试用例，并比较测试结果与预期结果，以检测潜在的问题。

3. **选择测试用例**：回归测试通常不需要覆盖所有可能的测试场景，而是集中在关键的测试用例上，以验证最重要的功能是否正常工作。选择测试用例的方法可以基于风险分析、业务需求或之前的缺陷历史。

4. **持续集成**：在持续集成（Continuous Integration）工作流程中，回归测试是一个关键的环节。每当代码库中有新的提交时，自动化回归测试将运行，以确保新的更改没有破坏现有的代码。

5. **快速反馈**：回归测试的目标之一是提供快速的反馈，以便开发团队能够尽早修复潜在的问题。如果回归测试发现了错误，开发人员可以尽快进行修复，而不是等到问题进入生产环境。

6. **版本控制**：回归测试通常与版本控制系统集成，以确保每个版本的软件都经过了适当的回归测试。这有助于跟踪软件的演化和改进。

总之，回归测试是一种关键的软件测试方法，旨在确保软件在不断进行修改和更新的过程中仍然保持了稳定性和质量。它有助于减少新功能引入的风险，同时维护现有功能的可靠性。

## 阅读LLVM IR

当你提到LLVM IR语句时，你是在谈论低级虚拟指令集（Low-Level Virtual Instruction Set），它是由LLVM编译器框架使用的中间表示形式。LLVM IR用于表示源代码的中间表示，通常是在编译源代码到目标代码的过程中使用。

以下是一些常见的LLVM IR语句以及它们的解释：

1. **声明变量**：
   ```
   %x = alloca i32
   ```
   这个语句创建一个名为`%x`的整数类型（`i32`）的变量。

2. **赋值**：
   ```
   store i32 42, i32* %x
   ```
   这个语句将整数值42存储到变量`%x`中。

3. **加载变量**：
   ```
   %val = load i32, i32* %x
   ```
   这个语句从变量`%x`中加载整数值，并将其存储到`%val`中。

4. **条件分支**：
   ```
   br i1 %condition, label %trueLabel, label %falseLabel
   ```
   这个语句根据条件`%condition`的值，选择跳转到`%trueLabel`或`%falseLabel`。

5. **循环**：
   ```
   br label %loopHeader
   ; ...
   %loopHeader:
   ; 循环体
   br i1 %loopCondition, label %loopHeader, label %afterLoop
   %afterLoop:
   ```
   这个语句表示一个简单的循环结构，根据`%loopCondition`的值反复执行循环体，直到条件不满足，然后跳转到`%afterLoop`。

6. **函数调用**：
   ```
   %result = call i32 @myFunction(i32 %arg1, i32 %arg2)
   ```
   这个语句调用名为`myFunction`的函数，传递两个整数参数`%arg1`和`%arg2`，并将返回值存储在`%result`中。

这些示例涵盖了LLVM IR中的一些基本语句。LLVM IR是一种灵活且强大的中间表示，用于优化和生成目标代码。不同的编译器和工具可以使用LLVM IR来执行各种优化和分析，以改进程序的性能和可靠性。

## 由Flang转换的Fortran程序

原来的Fortran程序：

```fortran
program main
	integer a
	integer b
	a = 1
stop
end program main
```

转换后的LLVM IR是这样的：

```LLVM
; this block is definition that is related to sourcefile
; ModuleID = '/tmp/defineVariabl-775d8e.ll'
source_filename = "/tmp/defineVariabl-775d8e.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@.C310_MAIN_ = internal constant i64 0
@.C311_MAIN_ = internal constant i32 1
@.C309_MAIN_ = internal constant i32 0

define void @MAIN_() !dbg !5 {
L.entry:
  %a_329 = alloca i32, align 4
  %0 = bitcast i32* @.C309_MAIN_ to i8*
  %1 = bitcast void (...)* @fort_init to void (i8*, ...)*
  call void (i8*, ...) %1(i8* %0)
  br label %L.LB1_335

L.LB1_335:                                        ; preds = %L.entry
  store i32 1, i32* %a_329, align 4, !dbg !8
  %2 = bitcast i32* @.C309_MAIN_ to i8*, !dbg !9
  %3 = bitcast void (...)* @f90_stop08a to void (i8*, i8*, i64, ...)*, !dbg !9
  call void (i8*, i8*, i64, ...) %3(i8* %2, i8* null, i64 0), !dbg !9
  ret void, !dbg !10
}

declare void @f90_stop08a(...)

declare void @fort_init(...)

!llvm.module.flags = !{!0, !1}
!llvm.dbg.cu = !{!2}

!0 = !{i32 2, !"Dwarf Version", i32 4}
!1 = !{i32 2, !"Debug Info Version", i32 3}
!2 = distinct !DICompileUnit(language: DW_LANG_Fortran90, file: !3, producer: " F90 Flang - 1.5 2017-05-01", isOptimized: false, flags: "'+flang -emit-llvm -S defineVariabl.f90 -o defineVariable.ll'", runtimeVersion: 0, emissionKind: FullDebug, enums: !4, retainedTypes: !4, globals: !4, imports: !4, nameTableKind: None)
!3 = !DIFile(filename: "defineVariabl.f90", directory: "/home/zou/Downloads/FortranProgram/easyBenchmark")
!4 = !{}
!5 = distinct !DISubprogram(name: "main", scope: !2, file: !3, line: 1, type: !6, scopeLine: 1, spFlags: DISPFlagDefinition | DISPFlagMainSubprogram, unit: !2, retainedNodes: !4)
!6 = !DISubroutineType(cc: DW_CC_program, types: !7)
!7 = !{null}
!8 = !DILocation(line: 4, column: 1, scope: !5)
!9 = !DILocation(line: 5, column: 1, scope: !5)
!10 = !DILocation(line: 6, column: 1, scope: !5)
```

```LLVM
@.C310_MAIN_ = internal constant i64 0
```

这行LLVM IR代码表示一个内部常量的定义，名为@.C310_MAIN_，其类型为i64（64位整数），并且其初始值为0。让我们逐一解释这个代码：

- `@.C310_MAIN_`: 这是一个LLVM IR中的符号名，用作常量的名称。符号名以`@`开头，通常用于全局变量和常量。

- `internal`: 这个关键字表示@.C310_MAIN_是一个内部常量，它的可见性被限制在当前编译单元内。这意味着它不能在其他编译单元中被引用，只能在当前编译单元内使用。

- `constant`: 这表明@.C310_MAIN_是一个常量，它的值在编译时就确定了，不能在运行时更改。

- `i64`: 这是@.C310_MAIN_的数据类型，表示64位整数。

- `0`: 这是@.C310_MAIN_的初始值，表示这个常量的值是0。

这行代码的作用是在LLVM IR中定义一个64位整数常量@.C310_MAIN_，其值为0。在后续的LLVM IR代码中，可以使用@.C310_MAIN_来引用这个常量，就像引用任何其他全局变量或常量一样。这有助于提高代码的可读性和维护性，因为可以使用有意义的名称来代替数字0。

```LLVM
%a_329 = alloca i32, align 4
```

这行LLVM IR代码表示在当前函数的栈帧上分配存储空间来存储一个32位整数（i32类型），并要求按4字节对齐。让我们逐一解释这个代码：

- `%a_329`: 这是一个局部变量的名称，以`%`开头，用于在当前函数中引用这个变量。这个变量的名字是`a_329`。

- `alloca`: 这是LLVM IR中的一条指令，用于在当前函数的栈帧上分配内存。它用于创建局部变量的存储空间。

- `i32`: 这是要分配的内存块的数据类型，表示32位整数。

- `align 4`: 这是对齐要求，表示内存块的起始地址应该是4的倍数。这是一种常见的对齐方式，有助于提高内存访问的效率。

因此，这行代码的作用是在当前函数的栈帧上分配了一块用于存储32位整数的内存空间，并将其命名为`%a_329`。后续的代码可以使用`%a_329`来引用这个局部变量，并在其中存储和访问32位整数的值。这是在函数内部定义局部变量的一种方式，用于存储临时数据或计算结果。

```LLVM
%0 = bitcast i32* @.C309_MAIN_ to i8*
```

这行LLVM IR代码表示了一个位转换（bitcast）操作，将一个指向32位整数（i32*）的指针`@.C309_MAIN_`转换为指向8位整数（i8*，也就是字节）的指针。让我们逐一解释这个代码：

- `%0`: 这是一个临时值的名称，以`%`开头，用于在LLVM IR中引用这个位转换操作的结果。`%0`通常用于表示临时变量或操作结果。

- `bitcast`: 这是LLVM IR中的一条指令，用于执行位转换操作。位转换操作允许将一个数据类型的值解释为另一个数据类型，但不会改变其实际存储内容，只是改变了视图。

- `i32* @.C309_MAIN_`: 这表示一个指向32位整数（i32*）的指针，这个指针的名称是`@.C309_MAIN_`。这个指针通常用于引用某个变量或内存位置。

- `to i8*`: 这表示将原始的32位整数指针转换为指向8位整数（i8*，也就是字节）的指针。这种位转换操作通常用于将不同数据类型的数据以字节为单位进行操作。

所以，这行代码的作用是将名为`@.C309_MAIN_`的32位整数指针转换为指向8位整数（字节）的指针，并将结果存储在`%0`中，以便后续的LLVM IR代码可以使用`%0`来引用这个新的字节指针。这种转换通常在处理底层内存操作或数据类型转换时使用。

```LLVM
%1 = bitcast void (...)* @fort_init to void (i8*, ...)*
```

这行LLVM IR代码表示一个位转换（bitcast）操作，将一个函数指针`@fort_init`，指向接受任意数量参数的函数（void (...)），转换为一个函数指针，指向接受第一个参数为指向8位整数（i8*）的指针，其余参数可以是任意数量的参数的函数（void (i8*, ...)）。让我们逐一解释这个代码：

- `%1`: 这是一个临时值的名称，以`%`开头，用于在LLVM IR中引用这个位转换操作的结果。`%1`通常用于表示临时变量或操作结果。

- `bitcast`: 这是LLVM IR中的一条指令，用于执行位转换操作。位转换操作允许将一个函数指针的类型转换为另一个函数指针的类型。

- `void (...)* @fort_init`: 这表示一个函数指针，`@fort_init`指向一个接受任意数量参数的函数，返回类型为`void`。这种函数指针通常用于表示可变参数函数，其中`...`表示可接受不定数量的参数。

- `to void (i8*, ...)*`: 这表示将原始的函数指针`@fort_init`转换为一个新的函数指针，指向一个接受第一个参数为指向8位整数（i8*）的指针，其余参数可以是任意数量的参数的函数。这种转换通常用于调整函数的参数类型，以便在调用该函数时传递正确类型的参数。

所以，这行代码的作用是将函数指针`@fort_init`从接受任意数量参数的函数类型转换为接受第一个参数为指向8位整数（i8*）的指针，其余参数可以是任意数量的参数的函数类型，并将结果存储在`%1`中，以便后续的LLVM IR代码可以使用`%1`来引用这个新的函数指针。这种转换通常在需要与不同参数类型的函数交互时使用。

```LLVM
call void (i8*, ...) %1(i8* %0)
```

这行LLVM IR代码表示一个函数调用操作。让我们逐一解释这个代码：

- `call`: 这是LLVM IR中用于执行函数调用的指令。

- `void (i8*, ...)* %1`: 这部分表示要调用的函数。`%1`是一个函数指针，它指向一个接受第一个参数为指向8位整数（i8*）的指针，其余参数可以是任意数量的参数的函数。这意味着我们将调用由`%1`指向的函数。

- `(i8* %0)`: 这是传递给函数的参数列表。在这里，我们传递了一个参数，即`i8*`类型的值，它是之前进行位转换（bitcast）操作时得到的结果，即`%0`。

所以，这行代码的作用是调用由函数指针`%1`所指向的函数，传递了一个参数，即`%0`。这种调用通常用于动态地调用不同类型或不定参数的函数，具体函数的实现由`%1`所指向的函数决定。这种机制通常在与函数指针或可变参数函数交互时使用。

```LLVM
store i32 1, i32* %a_329, align 4, !dbg !8
```

这是一个LLVM IR语句的示例，让我解释一下：

- `store i32 1, i32* %a_329`：这个语句表示将整数值1存储到指针变量`%a_329`指向的位置。具体来说，它将整数值1存储到`%a_329`指向的32位整数（`i32`）的内存位置。

- `align 4`：这是一个对齐（alignment）选项，它指定了存储操作的对齐方式。在这里，数据被4字节对齐，这意味着它将被存储在内存中的地址应该是4的倍数。对齐通常用于优化内存访问。

- `!dbg !8`：这是调试信息的一部分，它指向调试元数据。`!dbg`后面的`!8`可能是一个引用，它将链接到源代码中的调试信息，以帮助调试器在源代码级别调试程序。

综合起来，这个语句的作用是将整数值1存储到指针变量`%a_329`指向的内存位置，并要求对齐方式为4字节。调试信息`!dbg !8`则用于调试和源代码关联。这是编译器生成的一条低级指令，通常在LLVM IR的中间表示中出现，用于在编译过程中管理和操作数据。

```LLVM
!llvm.module.flags = !{!0, !1}
!llvm.dbg.cu = !{!2}

!0 = !{i32 2, !"Dwarf Version", i32 4}
!1 = !{i32 2, !"Debug Info Version", i32 3}
!2 = distinct !DICompileUnit(language: DW_LANG_Fortran90, file: !3, producer: " F90 Flang - 1.5 2017-05-01", isOptimized: false, flags: "'+flang -emit-llvm -S defineVariabl.f90 -o defineVariable.ll'", runtimeVersion: 0, emissionKind: FullDebug, enums: !4, retainedTypes: !4, globals: !4, imports: !4, nameTableKind: None)
!3 = !DIFile(filename: "defineVariabl.f90", directory: "/home/zou/Downloads/FortranProgram/easyBenchmark")
!4 = !{}
!5 = distinct !DISubprogram(name: "main", scope: !2, file: !3, line: 1, type: !6, scopeLine: 1, spFlags: DISPFlagDefinition | DISPFlagMainSubprogram, unit: !2, retainedNodes: !4)
!6 = !DISubroutineType(cc: DW_CC_program, types: !7)
!7 = !{null}
!8 = !DILocation(line: 4, column: 1, scope: !5)
!9 = !DILocation(line: 5, column: 1, scope: !5)
!10 = !DILocation(line: 6, column: 1, scope: !5)
```

这些代码片段看起来是LLVM调试信息的一部分，用于在编译器生成的中间表示代码（LLVM IR）中存储关于源代码的元数据和调试信息。让我解释一下这些代码：

1. `!llvm.module.flags = !{!0, !1}`：这行代码包含了模块级别的标志，可能包括有关Dwarf调试信息和调试版本的信息。`!0`和`!1`是后面两个标志的引用。

2. `!0 = !{i32 2, !"Dwarf Version", i32 4}`：这个标志表示Dwarf调试信息的版本。在这里，Dwarf版本被设置为4。

3. `!1 = !{i32 2, !"Debug Info Version", i32 3}`：这个标志表示调试信息的版本。在这里，调试信息版本被设置为3。

4. `!2 = distinct !DICompileUnit(...)`：这是一个表示编译单元的调试信息，其中包含了有关源代码文件、编译器版本、是否进行了优化等信息。这对于调试非常重要。

5. `!3 = !DIFile(...)`：这是一个表示源文件的调试信息，其中包含了源文件的名称和目录信息。

6. `!4 = !{}`：这个标志表示一个空的列表，通常用于一些调试信息的元素，比如枚举、全局变量、导入等等。

7. `!5 = distinct !DISubprogram(...)`：这个标志表示一个子程序（或函数）的调试信息，包括名称、源文件、行号等信息。在这里，它代表名为"main"的程序入口点。

8. `!6 = !DISubroutineType(...)`：这个标志表示子程序的类型信息，包括调用约定等信息。在这里，它指示DW_CC_program调用约定，表示这是一个程序的入口点。

9. `!7 = !{null}`：这个标志表示一个空的类型列表，通常用于描述子程序的参数和返回类型。

10. `!8`, `!9`, `!10` 是不同的DILocation标志，用于表示源代码中不同位置的行和列号。这些信息对于在调试器中定位和调试代码非常重要。

总之，这些调试信息是为了帮助开发人员在LLVM IR级别调试程序时能够将代码映射回源代码，以便更容易地理解和解决问题。这些信息通常由编译器生成，并与生成的目标代码一起提供给调试器。

```LLVM
declare void @f90_stop08a(...)
```

这是一个LLVM IR中的声明语句，它声明了一个名为 `f90_stop08a` 的函数，该函数返回 `void`，即没有返回值，并且接受一个或多个参数，但在声明中没有提供参数的具体类型或数量。这种声明通常用于与其他编译单元或库函数进行链接，而具体的函数定义则在另一个地方提供。在这里，`@f90_stop08a` 函数的具体实现将在其他地方定义或链接到程序中。这种方式可以在不暴露函数内部实现细节的情况下使用外部函数。

## LLVM IR中有很多`bitcast`语句

这个有什么作用？

