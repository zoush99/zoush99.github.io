---
title: 2023年9月
date: 2023-09-05 21:00:26
tags: 
- log
- project
categories: 
- log
- learn
typora-root-url: ./../
---

# 问题日志

<!--more-->

## Flang运行命令`flang function.f90 -o function.exe`遇到问题：

```
/usr/bin/ld: cannot find -lflangmain
/usr/bin/ld: cannot find -lflang
/usr/bin/ld: cannot find -lflangrti
/usr/bin/ld: cannot find -lpgmath
clang-14: error: linker command failed with exit code 1 (use -v to see invocation)
```

解决办法：[解决/usr/bin/ld: cannot find -lxxx_crocodile的记录空间的技术博客_51CTO博客](https://blog.51cto.com/crocodile/964277?articleABtest=1)

分析原因：编译Flang生成的动态库没有放到/usr/lib中，因此在使用时找不到该库。现在需要将这些文件放到系统指定查找的位置。

也就是将编译好的文件复制到默认查找的库的地址下去：`sudo cp -a lib* /usr/lib/`，这样就能解决问题了。

## linux下的so、a和o文件的区别

如一个C程序，经过gcc编译后得到的依次是：.i,.s,.o。分别是预处理文件、汇编文件和二进制文件（单元编译的结果），将许多单元编译的.o文件链接成一个文件后，便是编译产物。

.o是中间文件，相当于windows系统下的.obj文件 。

.a为静态库，是好多个.o合在一起,用于静态链接， 相当于windows系统下的lib。

.so 为共享库，是shared object,用于动态链接的，相当于windows系统下的dll。

## gcc的编译过程

编译过程的分步执行：
为了更好地理解gcc的工作过程，我们可以让在gcc工作的**4个阶段**中的任何一个阶段中停止下来。相关的参数有：
**-E**
预编译后停下来，生成后缀为 **.i 的预编译文件**。
**-c**
编译后停下来，生成后缀为 **.o 的目标文件**。
**-S**
汇编后停下来，生成后缀为 **.s 的汇编源文件**。

第一步：进行预编译，使用 -E 参数
`gcc -E test.c -o test.i`
查看 test.i 文件中的内容，会发现 stdio.h 的内容确实都插到文件里去了，而其他应当被预处理的宏定义也都做了相应的处理。
第二步：将 test.i 编译为目标代码，使用 -c 参数
`gcc -c test.c -o test.o`
第三步：生成汇编源文件
`gcc -S test.c -o test.s`
第四步：将生成的目标文件链接成可执行文件
`gcc test.o - o test`

对于稍微复杂的情况，比如有多个源代码文件、需要链接库或有其他比较特别的要求，就要给定适当的调用选项参数。

## 解决Flang和IKOS适配问题的思路

![image-20230906101050110](/paper_source/2023年9月/Flang与IKOS适配思路.jpg)

## pragma once的使用规则

`#pragma once`是一个比较常用的C/C++[预处理](https://so.csdn.net/so/search?q=预处理&spm=1001.2101.3001.7020)指令，只要在头文件的最开始加入这条预处理指令，就能够保证头文件只被编译一次，防止头文件被重复引用。

**“被重复引用”**指[头文件](https://so.csdn.net/so/search?q=头文件&spm=1001.2101.3001.7020)在cpp文件中多次被include，include嵌套造可能现象造成头文件多次引用。

作用都是为了避免同一个被 #include 多次，或者避免头文件嵌套包含（参照前置声明的笔记）。需要特别注意的是：

+ #pragma once 并不是C++的原生语法，而是编译器的一种支持，所以并不是所有的编译器都能够支持。#ifndef 则为C++的标准。

+ #ifndef 依赖于不重复的宏名称，保证了包含在 #endif 的内容不会被重复包含，这个内容可以是一个文件的所有内容，或者仅仅是一段代码。而 #pragma once 则是针对物理文件的一个标记，标记该文件不会被 #include 多次，不能只针对文件中某段代码进行标记。而且，#pragma once 不能保证多个文件的拷贝不会被重复包含，但这种错误更容易发现，且 #pragma once 大大提高了编译效率。

+ 一般建议用 #pragma once，因为一个类声明和定义各占用一个物理文件，即使类声明之外的内容，也应该是和该类有关，比如非模板类中声明了模板接口，则需要在同一个文件定义该模板接口。

```c++
#ifndef 自定义的宏名称
#define 自定义的宏名称
...整个文件的内容，或某段代码...
#endif

// 标记当前物理文件只会被包含一次，但如果文件有多个拷贝，也会被重复包含
#pragma once 
```

## namespace：命名空间的定义

在C语言中只有一个全局作用域：

1. C语言中所有的全局标识符共享一个作用域
2. 标识符之间可能发生冲突

C++中提出了命名空间的概念：

1. 命名空间将全局作用域分成不同的部分
2. 不同命名空间中的标识符可以同名而不会发生冲突
3. 命名空间可以发生嵌套
4. 全局作用域也叫默认命名空间

```c++
namespace Name
{
	namespace Internal
	{
		/*...*/
	}
	/*...*/
}
```

C++命名空间的使用：

1. 使用整个命名空间：`using namespace name;`
2. 使用命名空间中的变量：`using name::variable;`
3. 使用默认命名空间中的变量:  `::variable;`

```c++
#include <stdio.h>
#include <iostream>
namespace First 
{
	int i = 0;
}
 
namespace Second
{
	int i = 1;
 
	namespace Internal //嵌套命名空间
	{
		struct P  //嵌套命名空间
		{
			int x;
			int y;
		};
	}
}
 
int main()
{
	using namespace First; //使用整个命名空间
	using Second::Internal::P;  //使用嵌套的命名空间
 
	printf("First::i = %d\n", i);
	printf("Second::i = %d\n", Second::i);  //使用命名空间中的变量
 
	P p = { 2, 3 };
 
	printf("p.x = %d\n", p.x);
	printf("p.y = %d\n", p.y);
 
	system("pause");
	return 0;
}
```

## unordered_map容器用法

```c++
#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;
int main()
{
    //创建空 umap 容器
    unordered_map<string, string> umap;
    //向 umap 容器添加新键值对
    umap.emplace("Python教程", "http://c.biancheng.net/python/");
    umap.emplace("Java教程", "http://c.biancheng.net/java/");
    umap.emplace("Linux教程", "http://c.biancheng.net/linux/");

    //输出 umap 存储键值对的数量
    cout << "umap size = " << umap.size() << endl;
    //使用迭代器输出 umap 容器存储的所有键值对
    for (auto iter = umap.begin(); iter != umap.end(); ++iter) {
        cout << iter->first << " " << iter->second << endl;
    }
    return 0;
}
```

具体使用讲解见网址：[C++ STL unordered_map容器用法详解 (biancheng.net)](http://c.biancheng.net/view/7231.html)

## C++语法中explicit关键字的使用及示例

`explicit` 是 C++ 语言中的一个关键字，它可以用来修饰单个参数的构造函数，表示该构造函数只能显式调用，禁止隐式转换。在 C++11 中，`explicit` 还可以用来修饰类型转换函数，表示只能显式进行类型转换。

下面是一个简单的示例，演示了 `explicit` 的使用：

```c++
#include <iostream>
using namespace std;

class A {
public:
    A(int x) : m_x(x) {}
    int get_x() const { return m_x; }
private:
    int m_x;
};

class B {
public:
    explicit B(int x) : m_x(x) {}
    int get_x() const { return m_x; }
private:
    int m_x;
};

void funcA(A a) {
    cout << "a.get_x() = " << a.get_x() << endl;
}

void funcB(B b) {
    cout << "b.get_x() = " << b.get_x() << endl;
}

int main() {
    A a1 = 1;
    funcA(a1); // 可以隐式转换
    // A a2 = 'a'; // 错误：不允许隐式转换

    B b1 = 2;
    // funcB(b1); // 错误：只能显式转换
    funcB(static_cast<B>(3)); // 正确：显式转换
    return 0;
}
```

详情见[C++语法糖(explicit关键字)详解以及示例代码 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/624294266)

## C++中的noexcept关键字的用法

在C++11标准中引入了`noexcept`关键字，它用于指示函数是否可能抛出异常。`noexcept`可以用于函数声明和函数定义中，如果将函数标记为`noexcept`，那么编译器就可以进行一些优化，从而提高程序性能。

`noexcept`关键字可以放在函数声明和函数定义的括号后面，表示该函数不会抛出任何异常。例如：

```c++
void myFunction() noexcept {
    // function body
}
```

更多细节请看[C++语法糖(noexcept关键字)详解以及示例代码 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/624737461#:~:text=在C%2B%2B11标准中引入了noexcept关键字，它用于指示函数是否可能抛出异常。,noexcept可以用于函数声明和函数定义中，如果将函数标记为noexcept，那么编译器就可以进行一些优化，从而提高程序性能。 noexcept关键字可以放在函数声明和函数定义的括号后面，表示该函数不会抛出任何异常。)

## C++中的const关键字使用

**const修饰成员函数：常函数**

- 成员函数后加`const`后我们称为这个函数为**常函数**
- 常函数内不可以修改成员属性
- 成员属性声明时加关键字`mutable`后，在常函数中依然可以修改

```c++
class Person {
public: 
        void ShowPerson() const {
		this->m_B = 100;
	}
};
```

```c++
class Person {
public:
	Person() {
		m_A = 0;
		m_B = 0;
	}
	//this指针的本质是一个指针常量，指针的指向不可修改
	//如果想让指针指向的值也不可以修改，需要声明常函数
	void ShowPerson() const {
		//const Type* const pointer;
		//this = NULL; //不能修改指针的指向 Person* const this;
		//this->mA = 100; //但是this指针指向的对象的数据是可以修改的
		//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量
		this->m_B = 100;
	}
	void MyFunc() const {
		//mA = 10000;
	}
public:
	int m_A;
	mutable int m_B; //可修改 可变的
};
//const修饰对象  常对象
void test01() {

	const Person person; //常量对象  
	cout << person.m_A << endl;
	//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问
	person.m_B = 100; //但是常对象可以修改mutable修饰成员变量

	//常对象访问成员函数
	person.MyFunc(); //常对象不能调用const的函数

}

int main() {
	test01();
	system("pause");
	return 0;
}
```

细节请看[C++中const的5种用法总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/403182089)

## C++中的delete关键字使用

`delete`有2个作用：

1. 释放`new`分配的动态内存；
2. 阻止编译器自动合成函数；

**释放new分配的动态内存**

`delete`需要与`new`配对使用，其参数可以是指向一块内存首地址或空指针（`nullptr`）。不能对同一块内存多次delete，但是可以对空指针多次`delete`。

注意`delete`和`delete[] `的区别：

- `delete p `释放`p`指向的（单个）内存，可用于释放单个内存对象；
- `delete []p `释放`p`指向的内存区块，可用于释放一组内存（数组）；

```c++
// 释放基本类型内存
int *pi = new int(20);
delete pi;

// 释放类对象内存
int *ps = new string("hello");
delete ps; // 会调用string类析构函数

// 释放数组类型内存
int *pa = new int[10];
delete []pa;
```

**阻止编译器合成函数**

适用于C++11以上版本。

如果没有为类编写**构造函数、析构函数、拷贝构造函数、拷贝赋值运算符，以及移动拷贝函数、移动赋值运算符**，编译器可能会为类合成默认的函数版本。显式使用`delete`，可以阻止编译器合成对应函数。

```c++
class MyObj {
public:
  MyObj() = delete; // 阻止编译器合成构造函数，会导致类无法实例化
  MyObj& MyObj(const MyObj &) = delete; // 阻止编译器合成拷贝构造函数，会导致类无法拷贝构造，如std::cin, std::cout
  MyObj& operator=(const MyObj &) = delete; // 阻止合成赋值运算符，会导致类无法拷贝，如cin, cout, cerr
  ...
}
```



与`delete`对应的是`default`，`default`显式告诉编译器使用编译器自动合成的函数。
合成的默认构造函数，只有基类子对象和类类型对象会被初始化，而其他所有的非静态成员（如整数，指针，数组等），都不会初始化，对他们进行初始化的应该是程序员，而非编译器。

如果类包含了需要动态创建对象的指针，就不能依靠合成的构造函数、拷贝构造函数、拷贝赋值运算符。

详情见[C++> delete关键字初探 - 明明1109 - 博客园 (cnblogs.com)](https://www.cnblogs.com/fortunely/p/14554114.html)

## C++中的友元函数和友元类

在 C++ 中，一个类中可以有 `public`、`protected`、`private `三种属性的成员，通过对象可以访问 `public `成员，只有本类中的函数可以访问本类的 private 成员。现在，我们来介绍一种例外情况——友元（friend）。借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。

friend 的意思是朋友，或者说是好友，与好友的关系显然要比一般人亲密一些。我们会对好朋友敞开心扉，倾诉自己的秘密，而对一般人会谨言慎行，潜意识里就自我保护。在 C++ 中，这种友好关系可以用` friend `关键字指明，中文多译为“友元”，借助友元可以访问与其有好友关系的类中的私有成员。如果你对“友元”这个名词不习惯，可以按原文 friend 理解为朋友。

友元函数
在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。

**友元函数可以访问当前类中的所有成员，包括 `public`、`protected`、`private` 属性的。**

细节请看[C++友元函数和友元类（C++ friend关键字）_51CTO博客_c++ 友元](https://blog.51cto.com/u_15080016/4567286)

## C++中智能指针unique_ptr使用

C++ 标准提供了 3 种智能指针，分别是 `shared_ptr`、`unique_ptr` 和 `weak_ptr`，本节我们给大家讲解 `unique_ptr` 智能指针的特性和用法。

> 关于 shared_ptr 智能指针，可以阅读《[C++11 shared_ptr智能指针](http://c.biancheng.net/view/7898.html)》一节；关于 weak_ptr 智能指针，可以阅读《[C++11 weak_ptr智能指针](http://c.biancheng.net/view/vip_8673.html)》一节。

作为智能指针的一种，`unique_ptr` 指针自然也具备“在适当时机自动释放堆内存空间”的能力。和 `shared_ptr `指针最大的不同之处在于，unique_ptr 指针指向的堆内存无法同其它 unique_ptr 共享，也就是说，每个 `unique_ptr `指针都独自拥有对其所指堆内存空间的所有权。

> 这也就意味着，每个 unique_ptr 指针指向的堆内存空间的引用计数，都只能为 1，一旦该 unique_ptr 指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。

`unique_ptr `智能指针是以模板类的形式提供的，`unique_ptr<T>`（T 为指针所指数据的类型）定义在`<memory>`头文件，并位于 `std `命名空间中。因此，要想使用 `unique_ptr `类型指针，程序中应首先包含如下1条语句：

```c++
#include <memory>
```

**unique_ptr智能指针的创建**

考虑到不同实际场景的需要，`unique_ptr<T>` 模板类提供了多个实用的构造函数，这里给读者列举了几种常用的构造` unique_ptr `智能指针的方式。

1. 通过以下 2 种方式，可以创建出空的 unique_ptr 指针：
```c++
std::unique_ptr<int> p1();
std::unique_ptr<int> p2(nullptr);
```

2. 创建` unique_ptr` 指针的同时，也可以明确其指向。例如：

```c++
std::unique_ptr<int> p3(new int);
```

3. 基于` unique_ptr` 类型指针不共享各自拥有的堆内存，因此 C++11 标准中的 `unique_ptr` 模板类没有提供拷贝构造函数，只提供了移动构造函数。例如：

```c++
std::unique_ptr<int> p4(new int);
std::unique_ptr<int> p5(p4);//错误，堆内存不共享
std::unique_ptr<int> p5(std::move(p4));//正确，调用移动构造函数
```

值得一提的是，对于调用移动构造函数的 p4 和 p5 来说，p5 将获取 p4 所指堆空间的所有权，而 p4 将变成空指针（`nullptr`）。默认情况下，`unique_ptr` 指针采用 `std::default_delete<T> `方法释放堆内存。当然，我们也可以自定义

4. 符合实际场景的释放规则。值得一提的是，和 `shared_ptr` 指针不同，为 `unique_ptr` 自定义释放规则，只能采用函数对象的方式。例如：

```c++
//自定义的释放规则
struct myDel
{
    void operator()(int *p) {
        delete p;
    }
};
std::unique_ptr<int, myDel> p6(new int);
//std::unique_ptr<int, myDel> p6(new int, myDel());
```

详细内容请见[C++11 unique_ptr智能指针详解 (biancheng.net)](http://c.biancheng.net/view/7909.html)、[C++内存管理——unique_ptr - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/404771979)

## C++中的static关键字的使用

1. 全局静态变量，在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。**内存中的位置：** 静态存储区，在整个程序运行期间一直存在。**初始化**：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；**作用域**：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

2. 局部静态变量，在局部变量之前加上关键字`static`，局部变量就成为一个局部静态变量。内存中的位置：静态存储区。初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

3. 静态函数，在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是`extern`的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。函数的实现使用`static`修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；warning：不要再头文件中声明`static`的全局函数，不要在cpp内声明非`static`的全局函数，
   如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；

4. 类的静态成员，在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。
5. 类的静态函数，静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。

详情请查阅[C++ Static关键字作用介绍_WhiteTian的博客-CSDN博客](https://blog.csdn.net/u011718663/article/details/118218407)

## C++中的override的使用

### `virtual`：

- 放在函数的返回值前面，用于表示该成员函数为虚函数
- 父类虚函数前必须写；子类虚函数前可以省略（不管省不省略，该函数在子类中也是虚函数类型）
- virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义

### `override`：

- 父类的虚函数不可使用
- 放在子类虚函数的参数列表后（如果函数有尾指返回类型，那么要放在尾指返回类型后），用来说明此函数为覆盖(重写)父类的虚函数。如果类方法在类外进行定义，那么override不能加
- 不一定强制要求子类声明这个关键字，但是建议使用
- 这是C++11标准填入的

### `final`：

- 如果我们定义的一个虚函数不想被派生类覆盖（重写），那么可以在虚函数之后添加一个final关键字，声明这个虚函数不可以被派生类所覆盖（重写）
- 如果函数有尾指返回类型，那么要放在尾指返回类型后

细节见[C++:44---关键字virtual、override、final-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1784495)

## C++中的`static_cast`怎么用

仅根据表达式中存在的类型，将` expression` 转换为` type-id `类型。

```c++
static_cast <type-id> ( expression )
```

在标准 C++ 中，不进行运行时类型检查来帮助确保转换的安全。 在 C++/CX 中，将执行编译时和运行时检查。 有关更多信息，请参见 [强制转换](https://learn.microsoft.com/zh-cn/cpp/cpp/casting?view=msvc-170)中定义的接口的私有 C++ 特定实现。

`static_cast` 运算符可用于将指向基类的指针转换为指向派生类的指针等操作。 此类转换并非始终安全。

通常使用 `static_cast` 转换数值数据类型，例如将枚举型转换为整型或将整型转换为浮点型，而且你能确定参与转换的数据类型。 `static_cast` 转换安全性不如 `dynamic_cast` 转换，因为 `static_cast` 不执行运行时类型检查，而 `dynamic_cast` 执行该检查。 对不明确的指针的 `dynamic_cast` 将失败，而 `static_cast`的返回结果看似没有问题；这是危险的。 尽管 `dynamic_cast`转换更加安全，但是 `dynamic_cast`*只适用于指针或引用，而且运行时类型检查也是一项开销。 有关详细信息，请参阅 [dynamic_cast 运算符](https://learn.microsoft.com/zh-cn/cpp/cpp/dynamic-cast-operator?view=msvc-170)。

详情请见[static_cast 运算符 | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/cpp/static-cast-operator?view=msvc-170)

## C++中的`# ifdef`怎么用

可以在任何可以使用 `#if` 的地方使用 `#ifdef`*和 `#ifndef`指令。 如果定义了 `identifier`，`#ifdef``identifier` 语句等效于 `#if 1`。 如果 `identifier` 尚未定义或未被 `#undef`指令定义，它等效于 `#if 0`。 这些指令只检查使用 `#define` 定义的标识符是否存在，而不检查在 C 或 C++ 源代码中声明的标识符。

提供这些指令只是为了实现与该语言的早期版本的兼容性。 首选与 `#if` 指令一起使用的 `defined(``identifier`)` 常量表达式。

`#ifndef` 指令检查与 `#ifdef`检查的条件相反的情况。 如果尚未定义标识符，或者如果它的定义已用 `#undef` 删除，则条件为 `true`（非零值）。 否则，条件为 `false `(0)。

```c++
// ifdef_ifndef.CPP
// compile with: /Dtest /c
#ifndef test
#define final
#endif
```

## C++中的`# if, # elif, # endif`怎么用

源文件中的每个 `#if `指令必须与表示结束的` #endif` 指令匹配。 任意数量的 `#elif` 指令可以出现在 #if 和` #endif `指令之间，但最多允许一个` #else `指令。 `#else `指令（如果有）必须是` #endif `之前的最后一个指令。

`#if、#elif、#else `和 `#endif `指令可以嵌套在其他` #if `指令的 text 部分中。 每个嵌套的 `#else、#elif 或 #endif `指令属于最靠近的前面的 #if 指令。

所有条件编译指令（如 #if 和 #ifdef）都必须在文件末尾之前匹配一个 #endif 关闭指令。 否则会生成错误消息。 当条件编译指令包含在包含文件中时，这些指令必须满足相同的条件：包含文件的末尾不能有未匹配的条件编译指令。

在 #elif 命令后面的行部分中执行宏替换，以便能够在 constant-expression 中使用宏调用。

预处理器选择 text 的给定匹配项之一以进行进一步处理。 text 中指定的块可以是文本的任意序列。 它可占用多个行。 通常，text 是对编译器或预处理器有意义的程序文本。

预处理器处理选定的 text，并将其传递给编译器。 如果 text 包含预处理器指令，则预处理器将执行这些指令。 仅编译预处理器所选的文本块。

预处理器通过计算每个 #if 或 #elif 指令后面的常量表达式来选择单个 text 项，直到找到实际（非零）常量表达式。 它选择所有文本（包括以 **#** 开头的其他预处理器指令），直到其关联的 #elif、#else 或 #endif。

如果 constant-expression 的所有匹配项都为 false，或者 #elif 指令未出现，则预处理器将选择 #else 子句后面的文本块。 如果没有 #else 子句，并且 #if 块中的 constant-expression 的所有实例都为 false，则不选择文本块。

constant-expression 是具有下列其他限制的整数常量表达式：

- 表达式必须具有整型，并且只能包含整数常量、字符常量和 defined 运算符。
- 表达式不能使用 **`sizeof`** 或 type-cast 运算符。
- 目标环境无法表示整数的所有范围。
- 转换以与类型 **`long`** 相同的方式表示类型 **`int`**，并以与类型 **`unsigned long`** 相同的方式表示类型 **`unsigned int`**。
- 转换器可以将字符常量转换为与目标环境的集不同的代码值集。 若要确定目标环境的属性，请使用为该环境生成的应用程序来检查 LIMITS.H 宏的值。
- 该表达式不得查询环境，并且必须不受与目标计算机上的实现详细信息的影响。

```c++
#if defined(CREDIT)
    credit();
#elif defined(DEBIT)
    debit();
#else
    printerror();
#endif
```

```c++
#if DLEVEL > 5
    #define SIGNAL  1
    #if STACKUSE == 1
        #define STACK   200
    #else
        #define STACK   100
    #endif
#else
    #define SIGNAL  0
    #if STACKUSE == 1
        #define STACK   100
    #else
        #define STACK   50
    #endif
#endif
#if DLEVEL == 0
    #define STACK 0
#elif DLEVEL == 1
    #define STACK 100
#elif DLEVEL > 5
    display( debugptr );
#else
    #define STACK 200
#endif
```

具体请看[#if、#elif、#else 和 #endif 指令 (C/C++) | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=msvc-170)

## C++中的`typename`和`class`的区别



在 C++ Template 中很多地方都用到了 typename 与 class 这两个关键字，而且好像可以替换，是不是这两个关键字完全一样呢?

相信学习 C++ 的人对 class 这个关键字都非常明白，class 用于定义类，在模板引入 c++ 后，最初定义模板的方法为：

```c++
template<class T>......
```

这里 class 关键字表明T是一个类型，后来为了避免 class 在这两个地方的使用可能给人带来混淆，所以引入了 typename 这个关键字，它的作用同 class 一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了：

```c++
template<typename T>......
```

在模板定义语法中关键字 class 与 typename 的作用完全一样。

typename 难道仅仅在模板定义中起作用吗？其实不是这样，typename 另外一个作用为：**使用嵌套依赖类型(nested depended name)**，如下所示：

```c++
class MyArray 
{ 
    public：
    typedef int LengthType;
.....
}

template<class T>
void MyMethod( T myarr ) 
{ 
    typedef typename T::LengthType LengthType; 
    LengthType length = myarr.GetLength; 
}
```

这个时候 typename 的作用就是告诉 c++ 编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有 typename，编译器没有任何办法知道 T::LengthType 是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。

## C++中的`void*`怎么用

首先`void*`中的void代表一个任意的数据类型，"星号"代表一个指针，所以其就是一个任意数据类型的指针。

> 对于指定数据类型的指针如`int* ，double*`等，他们的sizeof都是4个字节，因为都是一个指针，只是指针指向的数据类型不一致。

**当函数传参时不确定数据类型时或者支持多种数据类型传递时。**

```c++
void say(int type,void* pArgs) {
    switch (type) 
    {
        case 0:
        {
            double* d = (double*)pArgs;
            break;
        }   
        case 1:
        {
            int* i = (int*)pArgs;
            break;
        }       
    }
}
```

**函数返回值不需要考虑类型，只关心返回的大小。**

```c++
void* malloc(size_t size)
```

代码使用

```c++
int* a = nullptr;
double* b = nullptr;
b = (double*)malloc(sizeof(double));
a = (int*)malloc(sizeof(double));
```

可以看到`malloc`返回值类型为`void*`，其只返回分配内存的大小，不关心分配后的内存你是使用int还是double类型进行划分.

> 注意：函数外部在接收到void*格式的返回值时，需要强转为自己的数据类型才能使用。

**当void*作为函数的参数类型或者返回值类型时，说明该函数可以接收或者返回任意类型的指针。**

代码如下：

```c++
void* _say(void* pArgs) {
    return pArgs;
}
int  main()
{
    int _a = 5;
    float f = 10.8;
    int* _pi = &_a;
    float* pf = &f;

    cout << *(int*)_say(_pi) << endl;
    cout << *(float*)_say(pf) << endl;

}
运行结果：
5
10.8
```

代码中可以看出参数`void* pArgs`可以使用任意类型的实参，返回值也可以返回任意类型的指针，但是最终需要转换为具体类型才能使用。

`void*`在C++中的作用其实就是为了实现**泛型编程**，和Java中使用Object来表示是一样的，所以又称为通用指针和泛指针，不过**C++中大部分情况下会使用模板编程来实现泛型**。

## 在项目中用doxygen写项目注释

**Doxygen语法简介**

所谓`Doxygen`语法就是在写程序注视时候按照`Doxygen`语法规则来写注释。只有按照标准的注释规则来写注释，生成的文档才会非常漂亮，否则乱七八糟的。

| 命令        | 字段名                                                       | 语法                                                      |
| ----------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| @file       | 文件名                                                       | file [< name >]                                           |
| @brief      | 简介                                                         | brief { brief description }                               |
| @author     | 作者                                                         | author { list of authors }                                |
| @mainpage   | 主页信息                                                     | mainpage [(title)]                                        |
| @date       | 年-月-日                                                     | date { date description }                                 |
| @author     | 版本号                                                       | version { version number }                                |
| @copyright  | 版权                                                         | copyright { copyright description }                       |
| @param      | 参数                                                         | param [(dir)] < parameter-name> { parameter description } |
| @return     | 返回                                                         | return { description of the return value }                |
| @retval     | 返回值                                                       | retval { description }                                    |
| @bug        | 漏洞                                                         | bug { bug description }                                   |
| @details    | 细节                                                         | details { detailed description }                          |
| @pre        | 前提条件                                                     | pre { description of the precondition }                   |
| @see        | 参考                                                         | see { references }                                        |
| @link       | 连接(与@see类库，{@link [http://www.google.com](https://link.zhihu.com/?target=http%3A//www.google.com)}) | link < link-object>                                       |
| @throw      | 异常描述                                                     | throw < exception-object> { exception description }       |
| @todo       | 待处理                                                       | todo { paragraph describing what is to be done }          |
| @warning    | 警告信息                                                     | warning { warning message }                               |
| @deprecated | 弃用说明。可用于描述替代方案，预期寿命等                     | deprecated { description }                                |
| @example    | 弃用说明。可用于描述替代方案，预期寿命等                     | deprecated { description }                                |

**文件注释**

一般放在文件开头

```text
/**
 * @file 文件名
 * @brief 简介
 * @details 细节
 * @author 作者
 * @version 版本号
 * @date 年-月-日
 * @copyright 版权
 */
```

**函数注释**

```text
/**
  * @brief 函数描述
  * @param 参数描述
  * @return 返回描述
  * @retval 返回值描述
  */
```

细节请看[干货|教你使用Doxygen制作漂亮的程序文档 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/510925324)

## C++中的`this`和`*this`的作用和区别

`return *this`返回的是当前对象的克隆或者本身（若返回类型为A， 则是克隆， 若返回类型为A&， 则是本身 ）。`return this`返回当前对象的地址（指向当前对象的指针）。

具体请见[C++中this与*this的区别_北海的星辰大海的博客-CSDN博客](https://blog.csdn.net/u011663005/article/details/106151786)

## C++中的`initializer_list`类型的简单使用

**initializer_list**是C++11提供的新数据类型，和`vector`一样，`initializer_list`也是一种模板类型。可以使用`.begin(), .end()` 等方法。

因为C++11扩大了初始化列表的适用范围，使其可用于所有内置类型和用户定义的类型。使用初始化列表时，可添加=等于号，也可不添加。

```c++
int  a={0} ; 
int  b{0} ;
vector<int> v = { 1, 2, 3, 4 } ;
vector<int> v{ 1, 2, 3, 4} ;
```

由此可见，`initializer_list` 还有一种用法是在构造函数或者其他函数中作为参数输入。能够简化一些操作。两个小例子：

第一个例子是在类中的构造函数中接收初始化列表。

```c++
class MyNumber{
public:
    MyNumber(const std::initializer_list<int> &v) {
        for (auto itm : v) {
            mVec.push_back(itm);
        }
    }

    void print() {
        for (auto itm : mVec) {
        std::cout << itm << " ";
        }
    }
private:
    std::vector<int> mVec;
};

int main(){
    MyNumber m = { 1, 2, 3, 4 };
    m.print();  // 1 2 3 4
    return 0;
}
```

第二个例子是在普通函数中接受初始化列表。

```c++
#include<iostream>
#include<initializer_list>

using namespace std;

double sum(initializer_list<double> il);
double average(const initializer_list<double> &ril);

double sum(initializer_list<double> il){
	double sum = 0;
	for (auto tmp : il) sum += tmp;
	return sum;
}

double average(const initializer_list<double> &ril){
	if (ril.size() > 0){
		double sum = 0;
		for (auto tmp : ril) sum += tmp;
		return sum / ril.size();
	}
	return 0.0;
}


int main(){
	cout << "sum:" << sum({ 2, 3, 4 }) << ", ave:" << average({ 2.0, 3, 4 }) << endl;
	initializer_list<double> dl = { 1.5, 2.5, 3.5, 4.5, 5.5 };
	cout << "sum:" << sum(dl) << ", ave:" << average(dl) << endl;
	dl = { 1, 2, 3, 4, 5, 6 };
	cout << "sum:" << sum(dl) << ", ave:" << average(dl) << endl;
	system("pause");
}
```
