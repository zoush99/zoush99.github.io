---
title: 2023年9月
date: 2023-09-05 21:00:26
tags: 
- log
- project
categories: 
- log
- learn
typora-root-url: ./../
---

## 问题日志

<!--more-->

### Flang运行命令`flang function.f90 -o function.exe`遇到问题：

```
/usr/bin/ld: cannot find -lflangmain
/usr/bin/ld: cannot find -lflang
/usr/bin/ld: cannot find -lflangrti
/usr/bin/ld: cannot find -lpgmath
clang-14: error: linker command failed with exit code 1 (use -v to see invocation)
```

解决办法：[解决/usr/bin/ld: cannot find -lxxx_crocodile的记录空间的技术博客_51CTO博客](https://blog.51cto.com/crocodile/964277?articleABtest=1)

分析原因：编译Flang生成的动态库没有放到/usr/lib中，因此在使用时找不到该库。现在需要将这些文件放到系统指定查找的位置。

也就是将编译好的文件复制到默认查找的库的地址下去：`sudo cp -a lib* /usr/lib/`，这样就能解决问题了。

### linux下的so、a和o文件的区别

如一个C程序，经过gcc编译后得到的依次是：.i,.s,.o。分别是预处理文件、汇编文件和二进制文件（单元编译的结果），将许多单元编译的.o文件链接成一个文件后，便是编译产物。

.o是中间文件，相当于windows系统下的.obj文件 。

.a为静态库，是好多个.o合在一起,用于静态链接， 相当于windows系统下的lib。

.so 为共享库，是shared object,用于动态链接的，相当于windows系统下的dll。

### gcc的编译过程

编译过程的分步执行：
为了更好地理解gcc的工作过程，我们可以让在gcc工作的**4个阶段**中的任何一个阶段中停止下来。相关的参数有：
**-E**
预编译后停下来，生成后缀为 **.i 的预编译文件**。
**-c**
编译后停下来，生成后缀为 **.o 的目标文件**。
**-S**
汇编后停下来，生成后缀为 **.s 的汇编源文件**。

第一步：进行预编译，使用 -E 参数
`gcc -E test.c -o test.i`
查看 test.i 文件中的内容，会发现 stdio.h 的内容确实都插到文件里去了，而其他应当被预处理的宏定义也都做了相应的处理。
第二步：将 test.i 编译为目标代码，使用 -c 参数
`gcc -c test.c -o test.o`
第三步：生成汇编源文件
`gcc -S test.c -o test.s`
第四步：将生成的目标文件链接成可执行文件
`gcc test.o - o test`

对于稍微复杂的情况，比如有多个源代码文件、需要链接库或有其他比较特别的要求，就要给定适当的调用选项参数。

### 解决Flang和IKOS适配问题的思路

![image-20230906101050110](/paper_source/2023年9月/Flang与IKOS适配思路.jpg)
