---
title: 2023年9月
date: 2023-09-05 21:00:26
tags: 
- log
- project
categories: 
- log
- learn
typora-root-url: ./../
---

# 问题日志

<!--more-->

## Flang运行命令`flang function.f90 -o function.exe`遇到问题：

```
/usr/bin/ld: cannot find -lflangmain
/usr/bin/ld: cannot find -lflang
/usr/bin/ld: cannot find -lflangrti
/usr/bin/ld: cannot find -lpgmath
clang-14: error: linker command failed with exit code 1 (use -v to see invocation)
```

解决办法：[解决/usr/bin/ld: cannot find -lxxx_crocodile的记录空间的技术博客_51CTO博客](https://blog.51cto.com/crocodile/964277?articleABtest=1)

分析原因：编译Flang生成的动态库没有放到/usr/lib中，因此在使用时找不到该库。现在需要将这些文件放到系统指定查找的位置。

也就是将编译好的文件复制到默认查找的库的地址下去：`sudo cp -a lib* /usr/lib/`，这样就能解决问题了。

## linux下的so、a和o文件的区别

如一个C程序，经过gcc编译后得到的依次是：.i,.s,.o。分别是预处理文件、汇编文件和二进制文件（单元编译的结果），将许多单元编译的.o文件链接成一个文件后，便是编译产物。

.o是中间文件，相当于windows系统下的.obj文件 。

.a为静态库，是好多个.o合在一起,用于静态链接， 相当于windows系统下的lib。

.so 为共享库，是shared object,用于动态链接的，相当于windows系统下的dll。

## gcc的编译过程

编译过程的分步执行：
为了更好地理解gcc的工作过程，我们可以让在gcc工作的**4个阶段**中的任何一个阶段中停止下来。相关的参数有：
**-E**
预编译后停下来，生成后缀为 **.i 的预编译文件**。
**-c**
编译后停下来，生成后缀为 **.o 的目标文件**。
**-S**
汇编后停下来，生成后缀为 **.s 的汇编源文件**。

第一步：进行预编译，使用 -E 参数
`gcc -E test.c -o test.i`
查看 test.i 文件中的内容，会发现 stdio.h 的内容确实都插到文件里去了，而其他应当被预处理的宏定义也都做了相应的处理。
第二步：将 test.i 编译为目标代码，使用 -c 参数
`gcc -c test.c -o test.o`
第三步：生成汇编源文件
`gcc -S test.c -o test.s`
第四步：将生成的目标文件链接成可执行文件
`gcc test.o - o test`

对于稍微复杂的情况，比如有多个源代码文件、需要链接库或有其他比较特别的要求，就要给定适当的调用选项参数。

## 解决Flang和IKOS适配问题的思路

![image-20230906101050110](/paper_source/2023年9月/Flang与IKOS适配思路.jpg)

## pragma once的使用规则

`#pragma once`是一个比较常用的C/C++[预处理](https://so.csdn.net/so/search?q=预处理&spm=1001.2101.3001.7020)指令，只要在头文件的最开始加入这条预处理指令，就能够保证头文件只被编译一次，防止头文件被重复引用。

**“被重复引用”**指[头文件](https://so.csdn.net/so/search?q=头文件&spm=1001.2101.3001.7020)在cpp文件中多次被include，include嵌套造可能现象造成头文件多次引用。

作用都是为了避免同一个被 #include 多次，或者避免头文件嵌套包含（参照前置声明的笔记）。需要特别注意的是：

+ #pragma once 并不是C++的原生语法，而是编译器的一种支持，所以并不是所有的编译器都能够支持。#ifndef 则为C++的标准。

+ #ifndef 依赖于不重复的宏名称，保证了包含在 #endif 的内容不会被重复包含，这个内容可以是一个文件的所有内容，或者仅仅是一段代码。而 #pragma once 则是针对物理文件的一个标记，标记该文件不会被 #include 多次，不能只针对文件中某段代码进行标记。而且，#pragma once 不能保证多个文件的拷贝不会被重复包含，但这种错误更容易发现，且 #pragma once 大大提高了编译效率。

+ 一般建议用 #pragma once，因为一个类声明和定义各占用一个物理文件，即使类声明之外的内容，也应该是和该类有关，比如非模板类中声明了模板接口，则需要在同一个文件定义该模板接口。

```c++
#ifndef 自定义的宏名称
#define 自定义的宏名称
...整个文件的内容，或某段代码...
#endif

// 标记当前物理文件只会被包含一次，但如果文件有多个拷贝，也会被重复包含
#pragma once 
```

## namespace：命名空间的定义

在C语言中只有一个全局作用域：

1. C语言中所有的全局标识符共享一个作用域
2. 标识符之间可能发生冲突

C++中提出了命名空间的概念：

1. 命名空间将全局作用域分成不同的部分
2. 不同命名空间中的标识符可以同名而不会发生冲突
3. 命名空间可以发生嵌套
4. 全局作用域也叫默认命名空间

```c++
namespace Name
{
	namespace Internal
	{
		/*...*/
	}
	/*...*/
}
```

C++命名空间的使用：

1. 使用整个命名空间：`using namespace name;`
2. 使用命名空间中的变量：`using name::variable;`
3. 使用默认命名空间中的变量:  `::variable;`

```c++
#include <stdio.h>
#include <iostream>
namespace First 
{
	int i = 0;
}
 
namespace Second
{
	int i = 1;
 
	namespace Internal //嵌套命名空间
	{
		struct P  //嵌套命名空间
		{
			int x;
			int y;
		};
	}
}
 
int main()
{
	using namespace First; //使用整个命名空间
	using Second::Internal::P;  //使用嵌套的命名空间
 
	printf("First::i = %d\n", i);
	printf("Second::i = %d\n", Second::i);  //使用命名空间中的变量
 
	P p = { 2, 3 };
 
	printf("p.x = %d\n", p.x);
	printf("p.y = %d\n", p.y);
 
	system("pause");
	return 0;
}
```

## unordered_map容器用法

```c++
#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;
int main()
{
    //创建空 umap 容器
    unordered_map<string, string> umap;
    //向 umap 容器添加新键值对
    umap.emplace("Python教程", "http://c.biancheng.net/python/");
    umap.emplace("Java教程", "http://c.biancheng.net/java/");
    umap.emplace("Linux教程", "http://c.biancheng.net/linux/");

    //输出 umap 存储键值对的数量
    cout << "umap size = " << umap.size() << endl;
    //使用迭代器输出 umap 容器存储的所有键值对
    for (auto iter = umap.begin(); iter != umap.end(); ++iter) {
        cout << iter->first << " " << iter->second << endl;
    }
    return 0;
}
```

具体使用讲解见网址：[C++ STL unordered_map容器用法详解 (biancheng.net)](http://c.biancheng.net/view/7231.html)

## C++语法中explicit关键字的使用及示例

`explicit` 是 C++ 语言中的一个关键字，它可以用来修饰单个参数的构造函数，表示该构造函数只能显式调用，禁止隐式转换。在 C++11 中，`explicit` 还可以用来修饰类型转换函数，表示只能显式进行类型转换。

下面是一个简单的示例，演示了 `explicit` 的使用：

```c++
#include <iostream>
using namespace std;

class A {
public:
    A(int x) : m_x(x) {}
    int get_x() const { return m_x; }
private:
    int m_x;
};

class B {
public:
    explicit B(int x) : m_x(x) {}
    int get_x() const { return m_x; }
private:
    int m_x;
};

void funcA(A a) {
    cout << "a.get_x() = " << a.get_x() << endl;
}

void funcB(B b) {
    cout << "b.get_x() = " << b.get_x() << endl;
}

int main() {
    A a1 = 1;
    funcA(a1); // 可以隐式转换
    // A a2 = 'a'; // 错误：不允许隐式转换

    B b1 = 2;
    // funcB(b1); // 错误：只能显式转换
    funcB(static_cast<B>(3)); // 正确：显式转换
    return 0;
}
```

详情见[C++语法糖(explicit关键字)详解以及示例代码 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/624294266)

## C++中的noexcept关键字的用法

在C++11标准中引入了noexcept关键字，它用于指示函数是否可能抛出异常。noexcept可以用于函数声明和函数定义中，如果将函数标记为noexcept，那么编译器就可以进行一些优化，从而提高程序性能。

noexcept关键字可以放在函数声明和函数定义的括号后面，表示该函数不会抛出任何异常。例如：

```c++
void myFunction() noexcept {
    // function body
}
```

更多细节请看[C++语法糖(noexcept关键字)详解以及示例代码 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/624737461#:~:text=在C%2B%2B11标准中引入了noexcept关键字，它用于指示函数是否可能抛出异常。,noexcept可以用于函数声明和函数定义中，如果将函数标记为noexcept，那么编译器就可以进行一些优化，从而提高程序性能。 noexcept关键字可以放在函数声明和函数定义的括号后面，表示该函数不会抛出任何异常。)

## C++中的const关键字使用

**const修饰成员函数：常函数**

- 成员函数后加const后我们称为这个函数为**常函数**
- 常函数内不可以修改成员属性
- 成员属性声明时加关键字mutable后，在常函数中依然可以修改

```c++
class Person {
public: 
        void ShowPerson() const {
		this->m_B = 100;
	}
};
```

```c++
class Person {
public:
	Person() {
		m_A = 0;
		m_B = 0;
	}
	//this指针的本质是一个指针常量，指针的指向不可修改
	//如果想让指针指向的值也不可以修改，需要声明常函数
	void ShowPerson() const {
		//const Type* const pointer;
		//this = NULL; //不能修改指针的指向 Person* const this;
		//this->mA = 100; //但是this指针指向的对象的数据是可以修改的
		//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量
		this->m_B = 100;
	}
	void MyFunc() const {
		//mA = 10000;
	}
public:
	int m_A;
	mutable int m_B; //可修改 可变的
};
//const修饰对象  常对象
void test01() {

	const Person person; //常量对象  
	cout << person.m_A << endl;
	//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问
	person.m_B = 100; //但是常对象可以修改mutable修饰成员变量

	//常对象访问成员函数
	person.MyFunc(); //常对象不能调用const的函数

}

int main() {
	test01();
	system("pause");
	return 0;
}
```

细节请看[C++中const的5种用法总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/403182089)
