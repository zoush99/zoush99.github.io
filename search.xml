<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git的使用</title>
    <url>/2023/06/13/git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="主要介绍git的使用规则"><a href="#主要介绍git的使用规则" class="headerlink" title="主要介绍git的使用规则"></a>主要介绍git的使用规则</h2><span id="more"></span>

<p><img src="/paper_source/git%E6%8C%87%E4%BB%A4/graph.jpg"></p>
<p>一些信息查找命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git branch -al</span><br><span class="line">git branch -r</span><br></pre></td></tr></table></figure>

<p>在要推送的项目下，打开git，首先需要初始化。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>然后连接远程仓库，这个远程仓库需要自己预先建立（github或其他代码管理平台都可以），如我想连接自己的zoush99。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:zoush99/zoush99.github.io.git</span><br></pre></td></tr></table></figure>

<p>将远程仓库的某个分支拉取到本地。（第一个参数是远程分支，第二个参数是本地分支）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull --set-upstream-to=origin/source <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>将本地仓库加入到提交目录中。（加入了所有文件，也可以加入特定文件）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>提交到仓库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;提交备注&quot;</span></span><br></pre></td></tr></table></figure>

<p>上传到远程仓库。（第一个参数是远程分支，第二个参数是本地分支）如果加上参数<code>-u</code>则会将本地分支作为追踪分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>以上是完整的过程，但是还需要一些常见的指令。</p>
<p>将远程仓库的文件复制到本地。（将默认的分支拉取到本地，后面一个参数是将本地文件夹重命名为source）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:zoush99/zoush99.github.io.git <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>拉取指定分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b <span class="built_in">source</span> git@github.com:zoush99/zoush99.github.io.git <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>拉取到本地后，可以查看是哪个分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>新建并且切换为本地分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>新建本地分支，并且从远程仓库拉取代码。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b <span class="built_in">source</span> origin/source</span><br></pre></td></tr></table></figure>
<p>删除本地分支，注意要切换到其他分支后，才能删除本地分支，在当前分支时不能删除当前分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -d <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>删除远程分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin -d <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>其他需要注意的：用命令<code>git pull --set-upstream-to=origin/source source</code>将修改的远程代码拉取到本地后，直接用<code>git push origin source</code>提交，不需要<code>add</code>和<code>commit</code>，因为<code>pull=fetch+merge</code>。</p>
<p>注意<code>fetch</code>和<code>merge</code>指令和<code>pull</code>指令。</p>
<p>更新远程仓库的某个分支到本地。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>将远程仓库的某个分支下载到本地新建的分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin <span class="built_in">source</span>:<span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>将远程分支合并到本地当前分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git merge origin/source</span><br></pre></td></tr></table></figure>

<p>上面两个命令连续执行，相当于如下的<code>pull</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>版本回滚操作，回到之前的版本，防止数据丢失。</p>
<p>查看版本号。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>使用指令回到目标版本号指定的版本。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --hard 目标版本号</span><br></pre></td></tr></table></figure>

<p>再提交。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure>

<p>也可以用<code>revert</code>操作。但这里不打算介绍这种方法，看起来有些麻烦。</p>
<p>建立本地分支和远程分支的关联（创建远程分支）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin 202309（分支名）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git pages发布页面和源代码同步脚本</title>
    <url>/2023/06/26/git-pages%E5%8F%91%E5%B8%83%E9%A1%B5%E9%9D%A2%E5%92%8C%E6%BA%90%E4%BB%A3%E7%A0%81%E5%90%8C%E6%AD%A5%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="github-pages界面和源代码同步"><a href="#github-pages界面和源代码同步" class="headerlink" title="github pages界面和源代码同步"></a>github pages界面和源代码同步</h2><span id="more"></span>

<blockquote>
<p> 为了便于自己记录并且保存自己的做项目或者生活中记录的重点事项，也为了多设备单账号协同发布。所以打算写一个脚本用来便于运行脚本分别发布并且同步源代码。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">!</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This simple script is designed to make it easier to publish my github pages and to be able to synchronize the <span class="built_in">source</span> code updates to the sourcecode branch.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &quot;the name of this scipt is publish&quot;</span><br><span class="line">echo &quot;First post on pages&quot;</span><br><span class="line">hexo g -d</span><br><span class="line"></span><br><span class="line">result=`git branch | grep &quot;*&quot;`</span><br><span class="line">curBranch=$&#123;result:2&#125;</span><br><span class="line">echo &quot;Then upload to sourcecode branch&quot;</span><br><span class="line">read -p &quot;Enter submission notes:&quot; notes</span><br><span class="line">echo &quot;Determine if the local branch is a sourcecode branch, if so, upload directly, otherwise switch to sourcecode branch and upload again&quot;</span><br><span class="line">echo &quot;Current git branch is $curBranch&quot;</span><br><span class="line">if [ $&#123;curBranch&#125; == &quot;sourcecode&quot; ]</span><br><span class="line">    then </span><br><span class="line">        echo &quot;the branch is sourcecode, upload directly&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;Switch to the sourcecode branch, then upload&quot;</span><br><span class="line">        git checkout sourcecode </span><br><span class="line">fi </span><br><span class="line"></span><br><span class="line">git pull origin sourcecode &amp;&amp;</span><br><span class="line">git add . &amp;&amp;</span><br><span class="line">git commit -m $notes &amp;&amp; </span><br><span class="line">git push origin sourcecode</span><br></pre></td></tr></table></figure>

<p>实现了简单的快捷上传操作。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Classic-Flang说明</title>
    <url>/2023/07/14/Classic-Flang%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="Flang的使用情况"><a href="#Flang的使用情况" class="headerlink" title="Flang的使用情况"></a>Flang的使用情况</h2><span id="more"></span>

<p>之前搞了那么久，现在终于得开始了解这个工具了。先慢慢使用，看看它的能力以及学习一下转换而来的LLVM IR的语法。</p>
<h2 id="安装Flang"><a href="#安装Flang" class="headerlink" title="安装Flang"></a>安装Flang</h2><p><img src="/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/%E5%AE%89%E8%A3%85Flang.jpg"></p>
<p>我安装的是github网站上的flang-compiler项目的legacy版本<a href="https://github.com/flang-compiler/flang/tree/legacy">flang-compiler&#x2F;flang at legacy (github.com)</a>。使用的安装脚本是根据网站上提供的安装脚本，并稍作修改：改进了下载版本等信息，总体而言没有做太大改进。为了保证开源包的安全性（可用性），fork到个人目录下：<a href="https://github.com/zoush99/flang/tree/legacy">zoush99&#x2F;flang at legacy (github.com)</a>。</p>
<p>为了让自己养成良好习惯，在这里记录一下安装的步骤。</p>
<p>安装LLVM需要一系列现代编译链：build-essensial和CMake的版本不低于3.3，并且应该到LLVM的网站满足所需要的依赖，才能进行安装步骤。推荐链接：<a href="http://llvm.org/docs/GettingStarted.html#host-c-toolchain-both-compiler-and-standard-library">Getting started with LLVM</a>和<a href="http://llvm.org/docs/CMake.html">CMake llvm</a>。</p>
<p>安装需要依赖后，直接安装其提供的LLVM14版本。其中的一些细节不做讨论。一些解释详见<a href="https://github.com/flang-compiler/flang/wiki/Building-Flang">Building Flang · flang-compiler&#x2F;flang Wiki (github.com)</a></p>
<p>我们这里需要直接将安装脚本罗列下来，并且依次执行即可。</p>
<p>首先是安装的初始化脚本：将CMake的命令进行初始设置，一定要提前执行。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">INSTALL_PREFIX=`<span class="built_in">pwd</span>`/install</span><br><span class="line"></span><br><span class="line"><span class="comment"># Targets to build should be one of: X86 PowerPC AArch64</span></span><br><span class="line">CMAKE_OPTIONS=<span class="string">&quot;-DCMAKE_INSTALL_PREFIX=<span class="variable">$INSTALL_PREFIX</span> \</span></span><br><span class="line"><span class="string">    -DLLVM_CONFIG=<span class="variable">$INSTALL_PREFIX</span>/bin/llvm-config \</span></span><br><span class="line"><span class="string">    -DCMAKE_CXX_COMPILER=<span class="variable">$INSTALL_PREFIX</span>/bin/clang++ \</span></span><br><span class="line"><span class="string">    -DCMAKE_C_COMPILER=<span class="variable">$INSTALL_PREFIX</span>/bin/clang \</span></span><br><span class="line"><span class="string">    -DCMAKE_Fortran_COMPILER=<span class="variable">$INSTALL_PREFIX</span>/bin/flang </span></span><br><span class="line"><span class="string">    -DCMAKE_Fortran_COMPILER_ID=Flang \</span></span><br><span class="line"><span class="string">    -DLLVM_TARGETS_TO_BUILD=X86&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后是安装llvm14的脚本，直接执行即可。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">. setup.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -d classic-flang-llvm-project ]]; <span class="keyword">then</span></span><br><span class="line">    git <span class="built_in">clone</span> -b release_14x https://github.com/zoush99/classic-flang-llvm-project.git</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> classic-flang-llvm-project</span><br><span class="line"><span class="built_in">mkdir</span> -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake <span class="variable">$CMAKE_OPTIONS</span> -DCMAKE_C_COMPILER=/usr/bin/gcc -DCMAKE_CXX_COMPILER=/usr/bin/g++ -DLLVM_ENABLE_CLASSIC_FLANG=ON -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang;openmp&quot;</span> -DCMAKE_BUILD_TYPE=Release ../llvm</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>将classic-flang-llvm-project&#x2F;build&#x2F;bin目录加入到环境变量，或install&#x2F;bin加入到环境变量。测试Clang命令是否正确执行，这时发现也会存在Flang的命令，但只是将Flang链接到Clang命令，之后安装Flang才会对Fortran程序起作用。</p>
<p>然后安装Flang的legacy版本，这个版本最近更新是在8个月前，因为要适配IKOS&#x2F;Clam，所以需要llvm14版本。目前Flang已经更新到15或更高版本。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">. setup.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -d flang ]]; <span class="keyword">then</span></span><br><span class="line">    git <span class="built_in">clone</span> -b legacy https://github.com/zoush99/flang.git</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">cd</span> flang/runtime/libpgmath</span><br><span class="line"> <span class="built_in">mkdir</span> -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"> cmake <span class="variable">$CMAKE_OPTIONS</span> ..</span><br><span class="line"> make -j4</span><br><span class="line"> sudo make install)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> flang</span><br><span class="line"><span class="built_in">mkdir</span> -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake <span class="variable">$CMAKE_OPTIONS</span> -DFLANG_LLVM_EXTENSIONS=ON ..</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>这样就把Flang安装成功，之后若使用IKOS还需要安装一个14版本的llvm，但二者相互不影响，因为他们针对不同的处理模块。等安装IKOS时需要将原有的（安装Flang所需）Clang从环境变量中移除（加注释），而安装新的llvm从而加入到环境变量中。之后需要编译IKOS时应该使用官方llvm。</p>
<p>之后所作更改时（Flang和IKOS各自）应该记住这点，因为所使用的llvm版本相同但内容不同，且不冲突。</p>
<p>安装完成后，我还需要将编译得到的一些动态或静态库复制到系统默认查询位置中<code>/usr/lib</code>或<code>/usr/local</code>。这样才算完全没问题。</p>
<h2 id="使用Flang"><a href="#使用Flang" class="headerlink" title="使用Flang"></a>使用Flang</h2><p>使用命令：</p>
<p><code> flang -help</code></p>
<p>来查找它所接受的命令，Flang本身支持所有的Clang的命令，而且支持针对Fortran特定的命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">OVERVIEW: clang LLVM compiler</span><br><span class="line"></span><br><span class="line">USAGE: clang-14 [options] file...</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -<span class="comment">###                    Print (but do not run) the commands to run for this compilation</span></span><br><span class="line">  -cpp                    Enable predefined and <span class="built_in">command</span> line preprocessor macros</span><br><span class="line">  -c                      Only run preprocess, compile, and assemble steps</span><br><span class="line">  -D &lt;macro&gt;=&lt;value&gt;      Define &lt;macro&gt; to &lt;value&gt; (or 1 <span class="keyword">if</span> &lt;value&gt; omitted)</span><br><span class="line">  -E                      Only run the preprocessor</span><br><span class="line">  -falternative-parameter-statement</span><br><span class="line">                          Enable the old style PARAMETER statement</span><br><span class="line">  -fbackslash             Specify that backslash <span class="keyword">in</span> string introduces an escape character</span><br><span class="line">  -fcolor-diagnostics     Enable colors <span class="keyword">in</span> diagnostics</span><br><span class="line">  -fdefault-double-8      Set the default double precision kind to an 8 byte wide <span class="built_in">type</span></span><br><span class="line">  -fdefault-integer-8     Set the default <span class="built_in">integer</span> kind to an 8 byte wide <span class="built_in">type</span></span><br><span class="line">  -fdefault-real-8        Set the default real kind to an 8 byte wide <span class="built_in">type</span></span><br><span class="line">  -ffixed-form            Process <span class="built_in">source</span> files <span class="keyword">in</span> fixed form</span><br><span class="line">  -ffixed-line-length-&lt;value&gt;</span><br><span class="line">                          Set line length <span class="keyword">in</span> fixed-form format Fortran, current supporting only 72 and 132 characters</span><br><span class="line">  -ffree-form             Process <span class="built_in">source</span> files <span class="keyword">in</span> free form</span><br><span class="line">  -finput-charset=&lt;value&gt; Specify the default character <span class="built_in">set</span> <span class="keyword">for</span> <span class="built_in">source</span> files</span><br><span class="line">  -fintrinsic-modules-path &lt;<span class="built_in">dir</span>&gt;</span><br><span class="line">                          Specify <span class="built_in">where</span> to find the compiled intrinsic modules</span><br><span class="line">  -flarge-sizes           Use INTEGER(KIND=8) <span class="keyword">for</span> the result <span class="built_in">type</span> <span class="keyword">in</span> size-related intrinsics</span><br><span class="line">  -fno-color-diagnostics  Disable colors <span class="keyword">in</span> diagnostics</span><br><span class="line">  -fno-fixed-form         Disable fixed-form format <span class="keyword">for</span> Fortran</span><br><span class="line">  -fno-free-form          Disable free-form format <span class="keyword">for</span> Fortran</span><br><span class="line">  -fopenacc               Enable OpenACC</span><br><span class="line">  -fopenmp                Parse OpenMP pragmas and generate parallel code.</span><br><span class="line">  -<span class="built_in">help</span>                   Display available options</span><br><span class="line">  -I &lt;<span class="built_in">dir</span>&gt;                Add directory to the end of the list of include search paths</span><br><span class="line">  -module-dir &lt;<span class="built_in">dir</span>&gt;       Put MODULE files <span class="keyword">in</span> &lt;<span class="built_in">dir</span>&gt;</span><br><span class="line">  -nocpp                  Disable predefined and <span class="built_in">command</span> line preprocessor macros</span><br><span class="line">  -o &lt;file&gt;               Write output to &lt;file&gt;</span><br><span class="line">  -pedantic               Warn on language extensions</span><br><span class="line">  -P                      Disable linemarker output <span class="keyword">in</span> -E mode</span><br><span class="line">  -std=&lt;value&gt;            Language standard to compile <span class="keyword">for</span></span><br><span class="line">  -U &lt;macro&gt;              Undefine macro &lt;macro&gt;</span><br><span class="line">  --version               Print version information</span><br><span class="line">  -W&lt;warning&gt;             Enable the specified warning</span><br><span class="line">  -Xflang &lt;arg&gt;           Pass &lt;arg&gt; to the flang compiler</span><br></pre></td></tr></table></figure>

<p>因为我们要用的只是将Fortran转成IR，而且不涉及并行程序（OpenMP），所以只用传统的一些命令行转化即可。</p>
<p>下面列举出一些可以使用的组合命令，以及它们的功能。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">flang -emit-llvm test.f90 -S -c -o test.ll</span><br><span class="line"><span class="comment"># 传统的clang命令生成llvm IR，且是可读版本.ll：汇编文件</span></span><br><span class="line">flang -emit-llvm test.f90 -c -o test.bc</span><br><span class="line"><span class="comment"># 从源码转换成机器码.bc：位码文件</span></span><br><span class="line">llvm-as test.ll -o test.bc</span><br><span class="line"><span class="comment"># 将.ll转换成.bc</span></span><br><span class="line">llvm-dis test.bc -o test.ll</span><br><span class="line"><span class="comment"># 将.bc转换成.ll</span></span><br><span class="line">lli test.bc</span><br><span class="line"><span class="comment"># 直接执行.bc文件</span></span><br><span class="line">llvm-extract --func=foo test.bc -o test-func.bc	<span class="comment"># 用test.ll也可以</span></span><br><span class="line"><span class="comment"># 从位码文件中抽取函数名为foo的函数，除了抽取函数，还可以抽取别名和全局变量</span></span><br></pre></td></tr></table></figure>

<p>一般来说，只用生成汇编文件或位码文件即可，汇编文件用来人为阅读，位码文件直接输入到IKOS中进行分析。</p>
<p>列出Clang的一些命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. .c -&gt; .i</span></span><br><span class="line">clang -E -c test.c -o test.i</span><br><span class="line"><span class="comment"># 2. .c -&gt; .bc</span></span><br><span class="line">clang -emit-llvm test.c -c -o test.bc</span><br><span class="line"><span class="comment"># 3. .c -&gt; .ll</span></span><br><span class="line">clang -emit-llvm test.c -S -o test.ll</span><br><span class="line"><span class="comment"># 4. .i -&gt; .bc</span></span><br><span class="line">clang -emit-llvm test.i -c -o test.bc</span><br><span class="line"><span class="comment"># 5. .i -&gt; .ll</span></span><br><span class="line">clang -emit-llvm test.i -S -o test.ll</span><br><span class="line"><span class="comment"># 6. .bc -&gt; .ll</span></span><br><span class="line">llvm-dis test.bc -o test.ll</span><br><span class="line"><span class="comment"># 7. .ll -&gt; .bc</span></span><br><span class="line">llvm-as test.ll -o test.bc</span><br><span class="line"><span class="comment"># 8. 多 bc 合并为一个 bc</span></span><br><span class="line">llvm-link test1.bc test2.bc -o test.bc</span><br></pre></td></tr></table></figure>

<p><img src="/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/Center.jpg" alt="img"></p>
<h2 id="Flang转换成-ll的结果"><a href="#Flang转换成-ll的结果" class="headerlink" title="Flang转换成.ll的结果"></a>Flang转换成.ll的结果</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">source_filename = <span class="string">&quot;/path/to/source.c&quot;</span></span><br><span class="line"><span class="comment"># 这里描述了源文件的名称和所在路径</span></span><br><span class="line">target datalayout = <span class="string">&quot;layout specification&quot;</span></span><br><span class="line"><span class="comment"># 这里描述了目标机器中数据的内存布局方式，包括字节序、类型以及对齐方式</span></span><br><span class="line"><span class="comment"># 这个参数对理解LLVM关系不大</span></span><br><span class="line">target triple = <span class="string">&quot;ARCHITECTURE-VENDOR-OPERATIONG_SYSTEM&quot;</span></span><br><span class="line">target triple = <span class="string">&quot;ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT&quot;</span></span><br><span class="line"><span class="comment"># 描述了目标机器是什么，从而指示后端生成相应的目标代码</span></span><br><span class="line">Identifiers</span><br><span class="line"><span class="comment"># 标识符分为：全局标识符和局部标识符。全局标识符以@开头，如全局函数、全局变量。局部标识符以%开头，类似于汇编语言中的寄存器</span></span><br><span class="line"><span class="comment"># 标识符有3种形式：</span></span><br><span class="line"><span class="comment">## 有名称的值，表示带有前缀（@或%）的字符串。如：%Val, @name</span></span><br><span class="line"><span class="comment">## 无名称的值，表示带前缀（@或%）的无符号数值。如%0, %1, @2</span></span><br><span class="line"><span class="comment">## 常量</span></span><br><span class="line">Functions</span><br><span class="line"><span class="comment"># define用于定义一个函数</span></span><br><span class="line">define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]</span><br><span class="line">       [cconv] [ret attrs]</span><br><span class="line">       &lt;ResultType&gt; @&lt;FunctionName&gt; ([argument list])</span><br><span class="line">       [(unnamed_addr|local_unnamed_addr)] [AddrSpace] [fn Attrs]</span><br><span class="line">       [section <span class="string">&quot;name&quot;</span>] [comdat [(<span class="variable">$name</span>)]] [align N] [gc] [prefix Constant]</span><br><span class="line">       [prologue Constant] [personality Constant] (!name !N)* &#123; ... &#125;</span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">define dso_local void @foo(i32 %x) <span class="comment">#0 &#123;</span></span><br><span class="line">  ; 省略 ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># define void @foo(i32 %x) &#123; ... &#125;，表示定义一个函数。其函数名称为foo，返回值的数据类型为void，参数（用%x表示）的数据类型为 i32（占用4字节的整型）</span></span><br><span class="line"><span class="comment"># #0，用于修饰函数时表示一组函数属性。这些属性定义在文件末尾</span></span><br><span class="line">  7 define weak dso_local void @foo(i32 %x) <span class="comment">#0 &#123;</span></span><br><span class="line">  8 entry:</span><br><span class="line">  9   %x.addr = alloca i32, align 4</span><br><span class="line"> 10   %y = alloca i32, align 4</span><br><span class="line"> 11   %z = alloca i32, align 4</span><br><span class="line"> 12   store i32 %x, i32* %x.addr, align 4</span><br><span class="line"> 13   %0 = load i32, i32* %x.addr, align 4</span><br><span class="line"> 14   %cmp = icmp eq i32 %0, 0</span><br><span class="line"> 15   br i1 %cmp, label %if.then, label %if.end</span><br><span class="line"> 16 </span><br><span class="line"> 17 if.then:                                          ; preds = %entry</span><br><span class="line"> 18   store i32 5, i32* %y, align 4</span><br><span class="line"> 19   br label %if.end</span><br><span class="line"> 20 </span><br><span class="line"> 21 if.end:                                           ; preds = %if.then, %entry</span><br><span class="line"> 22   %1 = load i32, i32* %x.addr, align 4</span><br><span class="line"> 23   %tobool = icmp ne i32 %1, 0</span><br><span class="line"> 24   br i1 %tobool, label %if.end2, label %if.then1</span><br><span class="line"> 25 </span><br><span class="line"> 26 if.then1:                                         ; preds = %if.end</span><br><span class="line"> 27   store i32 6, i32* %z, align 4</span><br><span class="line"> 28   br label %if.end2</span><br><span class="line"> 29 </span><br><span class="line"> 30 if.end2:                                          ; preds = %if.then1, %if.end</span><br><span class="line"> 31   ret void</span><br><span class="line"> 32 &#125;</span><br><span class="line"><span class="comment"># LLVM IR中，函数体是由基本块构成的。基本块是由一系列顺序执行的语句构成的，并（可选地）以标签作为起始。不同的标签代表不同的基本块</span></span><br><span class="line"><span class="comment"># 基本块的特点如下：</span></span><br><span class="line"><span class="comment">## 仅有一个入口，即基本块中的第一条指令</span></span><br><span class="line"><span class="comment">## 仅有一个出口，即基本块中的最后一条指令（被称为terminator instruction）。该指令要么跳转到其他基本块（不包括入口基本块），要买从函数返回</span></span><br><span class="line"><span class="comment">## 函数体中第一个出现的基本块，称为入口基本块（Entry Basic Block）。它是一个特殊的基本块，在进入函数时立即执行该基本块，并且不允许作为其他基本块的跳转目标（即不允许该基本块有前继结点）</span></span><br></pre></td></tr></table></figure>

<h2 id="LLVM-IR生成文件过程"><a href="#LLVM-IR生成文件过程" class="headerlink" title="LLVM IR生成文件过程"></a>LLVM IR生成文件过程</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.c --frontend--&gt; AST --frontend--&gt; LLVM IR --LLVM opt--&gt; LLVM IR --LLVM llc--&gt; .s Assembly --OS Assembler--&gt; .o --OS Linker--&gt; executable</span><br></pre></td></tr></table></figure>

<h2 id="LLVM-IR语法的基本概念"><a href="#LLVM-IR语法的基本概念" class="headerlink" title="LLVM IR语法的基本概念"></a>LLVM IR语法的基本概念</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>以<code>;</code>开头并一直延申到行尾，作为注释行。</p>
<h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><p>主程序是可执行程序执行的入口点，所以任何可执行程序都需要<code>main</code>函数才能运行。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是主程序，在<code>@main()</code>之后的就是函数的函数体，<code>ret i32 0</code>就代表C语言中的<code>return 0;</code>。因此，如果要增加代码，就只需要在大括号内，<code>ret i32 0</code>前增加代码即可。</p>
<h3 id="目标数据布局"><a href="#目标数据布局" class="headerlink" title="目标数据布局"></a>目标数据布局</h3><p>LLVM也支持我们手动定制这样的数据布局，例如，我们可以在LLVM IR的源代码中写：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target</span> <span class="keyword">datalayout</span> <span class="operator">=</span> <span class="string">&quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br></pre></td></tr></table></figure>

<p>这一长串文字就定义了目标的数据布局。具体而言：</p>
<ul>
<li><code>e</code>: 小端序</li>
<li><code>m:e</code>: 符号表中使用ELF格式的命名修饰</li>
<li><code>p270:32:32-p271:32:32-p272:64:64</code>: 与地址空间有关</li>
<li><code>i64:64</code>: 将<code>i64</code>类型的变量采用64位的ABI对齐</li>
<li><code>f80:128</code>: 将<code>long double</code>类型的变量采用128位的ABI对齐</li>
<li><code>n8:16:32:64</code>: 目标CPU的原生整型包含8位、16位、32位和64位</li>
<li><code>S128</code>: 栈以128位自然对齐</li>
</ul>
<h3 id="C的例子"><a href="#C的例子" class="headerlink" title="C的例子"></a>C的例子</h3><p>关于符号和符号表，这些还是挺抽象的，我们不如用一个具体的C语言的例子来看看效果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> c;</span><br><span class="line"><span class="type">void</span> <span class="title function_">d</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">e</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们先理解一下这个C语言代码各个符号的含义：</p>
<ul>
<li><p><code>a</code></p>
<p> 定义在<strong>当前文件中的全局变量</strong>，别的文件也可以使用这个符号</p>
</li>
<li><p><code>b</code></p>
<p> 定义在<strong>别的文件中的全局变量</strong>，当前文件需要使用这个符号</p>
</li>
<li><p><code>c</code></p>
<p> 定义在<strong>当前文件中的全局变量，别的文件不可以使用这个符号</strong></p>
</li>
<li><p><code>d</code></p>
<p> 定义在<strong>别的文件中的函数，当前文件需要使用这个符号</strong></p>
</li>
<li><p><code>e</code></p>
<p> 定义在<strong>当前文件中的函数，别的文件也可以使用这个符号</strong></p>
</li>
<li><p><code>f</code></p>
<p> 定义在<strong>当前文件中的函数，别的文件不可以使用这个符号</strong></p>
</li>
</ul>
<p>以上六种，是我们在C语言编程中最常见的符号形式。</p>
<p>我们使用Clang将其编译为LLVM IR，是什么样子的呢？</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@a</span> <span class="operator">=</span> dso_local <span class="keyword">global</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line"><span class="title">@b</span> <span class="operator">=</span> <span class="keyword">external</span> <span class="keyword">global</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line"><span class="title">@c</span> <span class="operator">=</span> <span class="keyword">internal</span> <span class="keyword">global</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@d</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@e</span>() &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="keyword">internal</span> void <span class="title">@f</span>() &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现几件事（在默认的编译选项下）：</p>
<ul>
<li>C语言中的<code>static</code>，也就是当前文件中定义，别的文件不可以用的，都会加上<code>internal</code>修饰符</li>
<li>C语言中的<code>extern</code>，也就是别的文件中定义的，全局变量会加上<code>external</code>修饰符，函数会使用<code>declare</code></li>
<li>C语言中定义的，可以给别的文件使用的全局变量或函数，不会加上链接类型修饰符，并且会加上<code>dso_local</code>保证不会被抢占</li>
</ul>
<h2 id="寄存器和栈"><a href="#寄存器和栈" class="headerlink" title="寄存器和栈"></a>寄存器和栈</h2><p>这两种数据我选择放在一起讲。我们知道，大多数对数据的操作，如加减乘除、比大小等，都需要操作的是<strong>寄存器</strong>内的数据。那么，我们为什么需要把数据放在<strong>栈</strong>上呢？主要有两个原因：</p>
<ul>
<li>寄存器数量不够</li>
<li>需要操作内存地址</li>
</ul>
<p>如果我们一个函数内有三四十个局部变量，但是家用型CPU最多也就十几个通用寄存器，所以我们不可能把所有变量都放在寄存器中。因此我们需要把一部分数据放在内存中，栈就是一个很好的存储数据的地方；此外，有时候我们需要直接操作内存地址，但是寄存器并没有通用的地址表示，所以只能把数据放在栈上来完成对地址的操作。</p>
<p>因此，<strong>在不操作内存地址的前提下，栈只是寄存器的一个替代品。</strong>如果寄存器的数量足够，并且代码中没有需要操作内存地址的时候，寄存器是足够胜任的，并且更加高效的。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>正因为如此，LLVM IR引入了虚拟寄存器的概念。在LLVM IR中，一个函数的局部变量可以是寄存器或者栈上的变量。对于寄存器而言，我们只需要像普通的赋值语句一样操作，但需要注意名字必须以<code>%</code>开头：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%local_variable</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>此时，<code>%local_variable</code>这个变量就代表一个寄存器，它此时的值就是<code>1</code>和<code>2</code>相加的结果。我们可以写一个简单的程序验证这一点：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; register_test.ll</span></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="variable">%local_variable</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%local_variable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们查看其编译出的汇编代码，其主函数为：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">main:</span></span><br><span class="line">    movl    <span class="number">$2</span>, %eax</span><br><span class="line">    addl    <span class="number">$1</span>, %eax</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>

<p>确实这个局部变量<code>%local_variable</code>变成了寄存器<code>eax</code>。</p>
<p>关于寄存器，我们还需了解一点。在不同的ABI下，会有一些callee-saved register和caller-saved register。简单来说，就是在函数内部，某些寄存器的值不能改变。或者说，在函数返回时，某些寄存器的值要和进入函数前相同。比如，在System V的ABI下，<code>rbp</code>, <code>rbx</code>, <code>r12</code>, <code>r13</code>, <code>r14</code>, <code>r15</code>都需要满足这一条件。由于LLVM IR是面向多平台的，所以我们需要一份代码适用于多种ABI。因此，<strong>LLVM IR内部自动帮我们做了这些事。如果我们把所有没有被保留的寄存器都用光了，那么LLVM IR会帮我们把这些被保留的寄存器放在栈上，然后继续使用这些被保留寄存器。当函数退出时，会帮我们自动从栈上获取到相应的值放回寄存器内。</strong></p>
<p>那么，如果所有通用寄存器都用光了，该怎么办？LLVM IR会帮我们把剩余的值放在栈上，但是对我们用户而言，<em>实际上都是虚拟寄存器，用户是感觉不到差别的。</em></p>
<p>因此，我们可以粗略地理解LLVM IR对寄存器的使用：</p>
<ul>
<li>当所需寄存器数量较少时，直接使用callee-saved register，即不需要保留的寄存器</li>
<li>当callee-saved register不够时，将caller-saved register原本的值压栈，然后使用caller-saved register</li>
<li>当寄存器用光以后，就把多的虚拟寄存器的值压栈</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>我们之前说过，当不需要操作地址并且寄存器数量足够时，我们可以直接使用寄存器。而LLVM IR的策略保证了我们可以<strong>使用无数的虚拟寄存器</strong>。那么，<em>在需要操作地址以及需要可变变量时，我们就需要使用栈。</em></p>
<p>LLVM IR对栈的使用十分简单，直接使用<code>alloca</code>指令即可。如：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%local_variable</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br></pre></td></tr></table></figure>

<p>就可以声明一个在栈上的变量了。关于栈上变量的操作，我会在之后提到，目前我们对栈上变量的了解只需这么多。</p>
<p>###数据的使用</p>
<p>在之前的两篇文章中，我们解释了LLVM中是如何对应数据区、寄存器和栈上的数据的。那么，这些数据定义了以后，该如何使用呢？</p>
<h3 id="全局变量和栈上变量皆指针"><a href="#全局变量和栈上变量皆指针" class="headerlink" title="全局变量和栈上变量皆指针"></a>全局变量和栈上变量皆指针</h3><p>下面，我们就需要讲怎样使用<em>全局变量和栈上的变量</em>。这两种变量实际上是类似的，LLVM IR把它们都看作指针。也就是说，对于全局变量：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@global_variable</span> <span class="operator">=</span> <span class="keyword">global</span> <span class="type">i32</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>和栈上变量</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%local_variable</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br></pre></td></tr></table></figure>

<p>这两个变量实际上都是<code>ptr</code>指针，指向它们所处的一个<code>i32</code>大小的内存区域。所以，我们不能这样：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="title">@global_variable</span> <span class="comment">; Wrong!</span></span><br></pre></td></tr></table></figure>

<p>因为<code>@global_variable</code>只是一个指针。</p>
<p>如果要操作这些值，必须使用<code>load</code>和<code>store</code>这两个命令。如果我们要获取<code>@global_variable</code>的值，就需要</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="title">@global_variable</span></span><br></pre></td></tr></table></figure>

<p>这个指令的意思是，把一个<code>ptr</code>指针<code>@global_variable</code>的<code>i32</code>类型的值赋给虚拟寄存器<code>%1</code>，然后我们就能愉快地</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="variable">%1</span></span><br></pre></td></tr></table></figure>

<p>这样了。</p>
<p>类似地，如果我们要将值存储到全局变量或栈上变量里，会需要<code>store</code>命令：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> ptr <span class="title">@global_variable</span></span><br></pre></td></tr></table></figure>

<p>这个代表将<code>i32</code>类型的值<code>1</code>赋给<code>ptr</code>类型的全局变量<code>@global_variable</code>所指的内存区域中。</p>
<h3 id="SSA"><a href="#SSA" class="headerlink" title="SSA"></a>SSA</h3><p>LLVM IR是一个严格遵守SSA(Static Single Assignment)策略的语言。SSA的要求很简单：每个变量只被赋值一次。也就是说，你不能</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>对<code>%1</code>同时赋值两次是不被允许的。</p>
<p>SSA作为一个历史悠久的概念，已经有了相当成熟的相关技术。通过使用SSA，编译器可以进行更好的优化，应用更成熟的算法，得到更好的结果。这里因为个人能力有限，就不再多对SSA进行介绍。我们只需要知道，通过约束每个变量只被赋值一次，可以让LLVM更好地优化。</p>
<p>上面这个例子好做，直接把3加4的结果赋值给一个新的虚拟寄存器就好了。但是，并非所有的情况都这么简单。在一些复杂情况下，将值存储在栈上再取出来，或者使用<code>phi</code>指令，也是一个更好的选择。</p>
<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>我们知道，汇编语言是弱类型的，我们操作汇编语言的时候，实际上考虑的是一些二进制序列。但是，LLVM IR却是强类型的，在LLVM IR中所有变量都必须有类型。这是因为，我们在使用高级语言编程的时候，往往都会使用强类型的语言，弱类型的语言无必要性，也不利于维护。因此，使用强类型语言，LLVM IR可以更好地进行优化。</p>
<h3 id="基本的数据类型"><a href="#基本的数据类型" class="headerlink" title="基本的数据类型"></a>基本的数据类型</h3><p>LLVM IR中比较基本的数据类型包括：</p>
<ul>
<li>空类型（<code>void</code>）</li>
<li>整型（<code>iN</code>）</li>
<li>浮点型（<code>float</code>、<code>double</code>等）</li>
</ul>
<p>空类型一般是作为不返回值的函数的返回类型，没有特别的含义，就代表「什么都没有」。</p>
<p>整型是指<code>i1</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>这类的数据类型。这里<code>iN</code>的<code>N</code>可以是任意正整数，可以是<code>i3</code>，<code>i1942652</code>。但最常用，最符合常理的就是<code>i1</code>以及8的整数倍。<code>i1</code>有两个值：<code>true</code>和<code>false</code>。也就是说，下面的代码可以正确编译：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%boolean_variable</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i1</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i1</span> <span class="keyword">true</span><span class="punctuation">,</span> ptr <span class="variable">%boolean_variable</span></span><br></pre></td></tr></table></figure>

<p>对于大于1位的整型，也就是如<code>i8</code>, <code>i16</code>等类型，我们可以直接用数字字面量赋值：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%integer_variable</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">128</span><span class="punctuation">,</span> ptr <span class="variable">%integer_variable</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">-128</span><span class="punctuation">,</span> ptr <span class="variable">%integer_variable</span></span><br></pre></td></tr></table></figure>

<h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>有一点需要注意的是，在LLVM IR中，整型默认是有符号整型，也就是说我们可以直接将<code>-128</code>以补码形式赋值给<code>i32</code>类型的变量。在LLVM IR中，整型的有无符号是<strong>体现在操作指令而非类型上</strong>的，比方说，对于两个整型变量的除法，LLVM IR分别提供了<code>udiv</code>和<code>sdiv</code>指令分别适用于无符号整型除法和有符号整型除法：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">udiv</span> <span class="type">i8</span> <span class="number">-6</span><span class="punctuation">,</span> <span class="number">2</span>    <span class="comment">; Get (256 - 6) / 2 = 125</span></span><br><span class="line"><span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">sdiv</span> <span class="type">i8</span> <span class="number">-6</span><span class="punctuation">,</span> <span class="number">2</span>    <span class="comment">; Get (-6) / 2 = -3</span></span><br></pre></td></tr></table></figure>

<p>我们可以用这样一个简单的程序验证：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; div_test.ll</span></span><br><span class="line"><span class="keyword">define</span> <span class="type">i8</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">udiv</span> <span class="type">i8</span> <span class="number">-6</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line">    <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">sdiv</span> <span class="type">i8</span> <span class="number">-6</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i8</span> <span class="variable">%1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别将<code>ret</code>语句的参数换成<code>%1</code>和<code>%2</code>以后，将代码编译成可执行文件，在终端下运行并查看返回值即可。</p>
<p>总结一下就是，LLVM IR中的<em>整型默认按有符号补码存储</em>，但一个变量究竟是否要被看作有无符号数需要看其参与的指令。</p>
<h3 id="转换指令"><a href="#转换指令" class="headerlink" title="转换指令"></a>转换指令</h3><p>与整型密切相关的就是转换指令，比如说，将<code>i8</code>类型的数<code>-127</code>转换成<code>i32</code>类型的数，将<code>i32</code>类型的数<code>257</code>转换成<code>i8</code>类型的数等。总的来说，LLVM IR中提供三种指令：<code>trunc</code> .. <code>to</code>指令，<code>zext</code> .. <code>to</code>指令和<code>sext</code> .. <code>to</code>指令。</p>
<p>将长的整型转换成短的整型很简单，直接把多余的高位去掉就行，LLVM IR提供的是<code>trunc</code> .. <code>to</code>指令：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%trunc_integer</span> <span class="operator">=</span> <span class="keyword">trunc</span> <span class="type">i32</span> <span class="number">257</span> <span class="keyword">to</span> <span class="type">i8</span> <span class="comment">; Trunc 32 bit 100000001 to 8 bit, get 1</span></span><br></pre></td></tr></table></figure>

<p>将短的整型变成长的整型则相对比较复杂。这是因为，在补码中最高位是符号位，并不表示实际的数值。因此，如果单纯地在更高位补<code>0</code>，那么<code>i8</code>类型的<code>-1</code>（补码为<code>11111111</code>）就会变成<code>i32</code>的<code>255</code>。这虽然符合道理，但有时候我们需要<code>i8</code>类型的<code>-1</code>扩展到<code>i32</code>时仍然是<code>-1</code>。LLVM IR为我们提供了两种指令：零扩展的<code>zext</code> .. <code>to</code>指令和符号扩展的<code>sext</code> .. <code>to</code>指令。</p>
<p>零扩展就是最简单的，直接在高位补<code>0</code>，而符号扩展则是用原数的符号位来填充。也就是说我们如下的代码：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%zext_integer</span> <span class="operator">=</span> <span class="keyword">zext</span> <span class="type">i8</span> <span class="number">-1</span> <span class="keyword">to</span> <span class="type">i32</span> <span class="comment">; Extend 8 bit 0xFF to 32 bit 0x000000FF, get 255</span></span><br><span class="line"><span class="variable">%sext_integer</span> <span class="operator">=</span> <span class="keyword">sext</span> <span class="type">i8</span> <span class="number">-1</span> <span class="keyword">to</span> <span class="type">i32</span> <span class="comment">; Extend 8 bit 0xFF to 32 bit 0xFFFFFFFF, get -1</span></span><br></pre></td></tr></table></figure>

<p>类似地，浮点型的数和整型的数也可以相互转换，使用<code>fptoui</code> .. <code>to</code>, <code>fptosi</code> .. <code>to</code>, <code>uitofp</code> .. <code>to</code>, <code>sitofp</code> .. <code>to</code>可以分别将浮点数转换为无符号、有符号整型，将无符号、有符号整型转换为浮点数。不过有一点要注意的是，如果将大数转换为小的数，那么并不保证截断，如将浮点型的<code>257.1</code>转换成<code>i8</code>（上限为<code>128</code>），那么就会产生未定义行为。所以，在浮点型和整型相互转换的时候，需要在高级语言层面做一些调整，如使用饱和转换等。</p>
<h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><p>LLVM IR中的指针类型就是<code>ptr</code>。与C语言不同，LLVM IR中的指针不含有其指向内容的类型，也就是说，类似于C语言中的<code>void *</code>。我们之前提到，LLVM IR中的全局变量和栈上分配的变量都是指针，所以其类型都是指针类型。</p>
<p>在高级语言中，直接操作裸指针的机会都比较少，除非在性能极其敏感的场景下，由最厉害的大佬才能操作裸指针。这是因为，裸指针极其危险，稍有不慎就会出现段错误等致命错误，所以我们使用指针时应该慎之又慎。</p>
<p>LLVM IR为大佬们提供了操作裸指针的一些指令。在C语言中，我们会遇到这种场景：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">size_t</span> address_of_x = (<span class="type">size_t</span>)&amp;x;</span><br><span class="line"><span class="type">size_t</span> address_of_y = address_of_x - <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> also_y = *(<span class="type">int</span> *)address_of_y;</span><br></pre></td></tr></table></figure>

<p>这种场景比较无脑，但确实是合理的，需要将指针看作一个具体的数值进行加减。到x86_64的汇编语言层次，取地址就变成了<code>lea</code>命令，解引用倒是比较正常，就是一个简单的<code>mov</code>。</p>
<p>在LLVM IR层次，为了使指针能像整型一样加减，提供了<code>ptrtoint</code> .. <code>to</code>指令和<code>inttoptr</code> .. <code>to</code>指令，分别解决将指针转换为整型，和将整型转换为指针的功能。也就是说，我们可以粗略地将上面的程序转写为</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%x</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span> <span class="comment">; %x is of type ptr, which is the address of variable x</span></span><br><span class="line"><span class="variable">%y</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span> <span class="comment">; %y is of type ptr, which is the address of variable y</span></span><br><span class="line"><span class="variable">%address_of_x</span> <span class="operator">=</span> <span class="keyword">ptrtoint</span> ptr <span class="variable">%x</span> <span class="keyword">to</span> <span class="type">i64</span></span><br><span class="line"><span class="variable">%address_of_y</span> <span class="operator">=</span> <span class="keyword">sub</span> <span class="type">i64</span> <span class="variable">%address_of_x</span><span class="punctuation">,</span> <span class="number">4</span></span><br><span class="line"><span class="variable">%also_y</span> <span class="operator">=</span> <span class="keyword">inttoptr</span> <span class="type">i64</span> <span class="variable">%address_of_y</span> <span class="keyword">to</span> ptr <span class="comment">; %also_y is of type ptr, which is the address of variable y</span></span><br></pre></td></tr></table></figure>

<h2 id="聚合类型"><a href="#聚合类型" class="headerlink" title="聚合类型"></a>聚合类型</h2><p>比起指针类型而言，更重要的是<strong>聚合类型</strong>。我们在C语言中常见的聚合类型有数组和结构体，LLVM IR也为我们提供了相应的支持。</p>
<p>数组类型很简单，我们要声明一个类似C语言中的<code>int a[4]</code>，只需要</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%a</span> <span class="operator">=</span> <span class="keyword">alloca</span> [<span class="number">4</span> <span class="keyword">x</span> <span class="type">i32</span>]</span><br></pre></td></tr></table></figure>

<p>也就是说，C语言中的<code>int[4]</code>类型在LLVM IR中可以写成<code>[4 x i32]</code>。注意，**这里面是个<code>x</code>不是<code>*</code>**。</p>
<p>我们也可以使用类似地语法进行初始化：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@global_array</span> <span class="operator">=</span> <span class="keyword">global</span> [<span class="number">4</span> <span class="keyword">x</span> <span class="type">i32</span>] [<span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>特别地，我们知道，字符串在底层可以看作字符组成的数组，所以LLVM IR为我们提供了语法糖：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@global_string</span> <span class="operator">=</span> <span class="keyword">global</span> [<span class="number">12</span> <span class="keyword">x</span> <span class="type">i8</span>] <span class="keyword">c</span><span class="string">&quot;Hello world<span class="char escape_">\00</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>在字符串中，转义字符必须以<code>\xy</code>的形式出现，其中<code>xy</code>是这个转义字符的ASCII码。比如说，字符串的结尾，C语言中的<code>\0</code>，在LLVM IR中就表现为<code>\00</code>。</p>
<p>结构体的类型也相对比较简单，在C语言中的结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">char</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在LLVM IR中就成了</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123;</span><br><span class="line">    <span class="type">i32</span><span class="punctuation">,</span></span><br><span class="line">    <span class="type">i8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们初始化一个结构体也很简单：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@global_structure</span> <span class="operator">=</span> <span class="keyword">global</span> <span class="variable">%MyStruct</span> &#123; <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i8</span> <span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">; or</span></span><br><span class="line"><span class="title">@global_structure</span> <span class="operator">=</span> <span class="keyword">global</span> &#123; <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i8</span> &#125; &#123; <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i8</span> <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，无论是数组还是结构体，其作为全局变量或栈上变量，依然是指针，也就是说，<code>@global_array</code>的类型是<code>ptr</code>, <code>@global_structure</code>的类型也是<code>ptr</code>。接下来的问题就是，我们如何对聚合类型进行操作呢？</p>
<p>在LLVM IR中，<em>如果我们想对一个聚合类型的某些字段进行操作，需要区分这个聚合类型是指针形式的</em>，也就是以全局变量或者栈形式存储，还是值形式的，也就是以寄存器形式存储。</p>
<h3 id="getelementptr"><a href="#getelementptr" class="headerlink" title="getelementptr"></a><code>getelementptr</code></h3><p>首先，我们将介绍以指针形式存储的聚合类型，该如何访问其字段。</p>
<h4 id="访问数组元素字段"><a href="#访问数组元素字段" class="headerlink" title="访问数组元素字段"></a>访问数组元素字段</h4><p>我们先来看一个最直观的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="keyword">struct</span> MyStruct *my_structs_ptr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> my_y = my_structs_ptr[<span class="number">2</span>].y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有一个<code>foo</code>函数，其接收了一个参数<code>my_structs_ptr</code>。从函数体的语义可知，这里这个参数，实际上指向了一个数组，我们要取这个数组的第三个元素的<code>y</code>字段。</p>
<p>我们先直接看结论，用LLVM IR来表示为</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123; <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(ptr <span class="variable">%my_structs_ptr</span>) &#123;</span><br><span class="line">    <span class="variable">%my_y_in_stack</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%my_y_ptr</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="variable">%MyStruct</span><span class="punctuation">,</span> ptr <span class="variable">%my_structs_ptr</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line">    <span class="variable">%my_y_val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%my_y_ptr</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%my_y_val</span><span class="punctuation">,</span> ptr <span class="variable">%my_y_in_stack</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以注意到，最核心的就是<code>getelementptr</code>指令了。它的四个参数的语义分别为<code>%MyStruct, ptr %my_structs_ptr, i64 2, i32 1</code></p>
<p>我们要取地址的指针，它指向区域的类型为<code>%MyStruct</code></p>
<ul>
<li><p><code>ptr %my_structs_ptr</code></p>
<p> 我们要操作的指针，是<code>ptr %my_structs_ptr</code></p>
</li>
<li><p><code>i64 2</code></p>
<p> 取偏移量为2的那个元素，也就是<code>my_structs_ptr[2]</code></p>
</li>
<li><p><code>i32 1</code></p>
<p> 对于获得到的那个元素，取索引为1的字段，也就是<code>my_structs_ptr[2].y</code></p>
</li>
</ul>
<p>通过这个指令，我们获得了<code>my_structs_ptr[2].y</code>的地址，随后的LLVM IR指令就是将这个地址的值放到了局部变量中。</p>
<h4 id="访问指针字段"><a href="#访问指针字段" class="headerlink" title="访问指针字段"></a>访问指针字段</h4><p>接下来，我们看这样一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="keyword">struct</span> MyStruct *my_structs_ptr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> my_y = my_structs_ptr-&gt;y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其对应的LLVM IR为</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123; <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(ptr <span class="variable">%my_structs_ptr</span>) &#123;</span><br><span class="line">    <span class="variable">%my_y_in_stack</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%my_y_ptr</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="variable">%MyStruct</span><span class="punctuation">,</span> ptr <span class="variable">%my_structs_ptr</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line">    <span class="variable">%my_y_val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%my_y_ptr</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%my_y_val</span><span class="punctuation">,</span> ptr <span class="variable">%my_y_in_stack</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唯一的改动，就是将之前的偏移量<code>i64 2</code>改为<code>i64 0</code>。</p>
<p>这看上去挺符合直觉的。等等，符合直觉吗？</p>
<p>我们发现，即使是将<code>my_structs_ptr</code>看作是指向结构体的指针，而非指向数组的指针，仍然要加一个偏移量<code>0</code>。这是因为，C语言中，对于一个数组<code>array</code>，<code>&amp;array[0]</code>和指向首元素的<code>array_ptr</code>是同一个东西。为了兼容C语言这个特性，LLVM IR在<code>getelementptr</code>中，将所有的指针都看作一个指向数组首地址的指针。因此，我们需要额外加一个<code>i64 0</code>的偏移量来解决这个问题。</p>
<h4 id="级联访问"><a href="#级联访问" class="headerlink" title="级联访问"></a>级联访问</h4><p>此外，<code>getelementptr</code>还可以接多个参数，类似于级联调用。我们有C程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> <span class="title">my_structs</span>[4];</span></span><br></pre></td></tr></table></figure>

<p>那么如果我们想获得<code>my_structs[2].y[3]</code>的地址，只需要</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123;</span><br><span class="line">    <span class="type">i32</span><span class="punctuation">,</span></span><br><span class="line">    [<span class="number">5</span> <span class="keyword">x</span> <span class="type">i32</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">%my_structs</span> <span class="operator">=</span> <span class="keyword">alloca</span> [<span class="number">4</span> <span class="keyword">x</span> <span class="variable">%MyStruct</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">4</span> <span class="keyword">x</span> <span class="variable">%MyStruct</span>]<span class="punctuation">,</span> ptr <span class="variable">%my_structs</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>我们可以查看官方提供的<a href="http://llvm.org/docs/GetElementPtr.html">The Often Misunderstood GEP Instruction</a>指南更多地了解<code>getelementptr</code>的机理。</p>
<h2 id="extractvalue和insertvalue"><a href="#extractvalue和insertvalue" class="headerlink" title="extractvalue和insertvalue"></a><code>extractvalue</code>和<code>insertvalue</code></h2><p>除了我们上面讲的这种情况，也就是把结构体分配在栈或者全局变量，然后操作其指针以外，还有什么情况呢？我们考虑这种情况：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; extract_insert_value.ll</span></span><br><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123;</span><br><span class="line">    <span class="type">i32</span><span class="punctuation">,</span></span><br><span class="line">    <span class="type">i32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title">@my_struct</span> <span class="operator">=</span> <span class="keyword">global</span> <span class="variable">%MyStruct</span> &#123; <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="variable">%MyStruct</span><span class="punctuation">,</span> ptr <span class="title">@my_struct</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，我们的结构体是直接放在虚拟寄存器<code>%1</code>里，<code>%1</code>并不是存储<code>@my_struct</code>的指针，而是直接存储这个结构体的值。这时，我们并不能用<code>getelementptr</code>来操作<code>%1</code>，因为这个指令需要的是一个指针。因此，LLVM IR提供了<code>extractvalue</code>和<code>insertvalue</code>指令。</p>
<p>因此，如果要获得<code>@my_struct</code>第二个字段的值，我们需要</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">extractvalue</span> <span class="variable">%MyStruct</span> <span class="variable">%1</span><span class="punctuation">,</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>1</code>就代表第二个字段（从<code>0</code>开始）。</p>
<p>类似地，如果要将<code>%1</code>的第二个字段赋值为<code>233</code>，只需要</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">insertvalue</span> <span class="variable">%MyStruct</span> <span class="variable">%1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">233</span><span class="punctuation">,</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>然后<code>%3</code>就会是<code>%1</code>将第二个字段赋值为<code>233</code>后的值。</p>
<p><code>extractvalue</code>和<code>insertvalue</code>并不只适用于结构体，也同样适用于<strong>存储在虚拟寄存器中的数组</strong>，这里不再赘述。</p>
<h2 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a>标签类型</h2><p>在汇编语言中，一切的控制语句、函数调用都是由标签来控制的，在LLVM IR中，控制语句也是需要标签来完成。其具体的内容我会在之后专门有一篇控制语句的文章来解释。</p>
<h2 id="元数据类型"><a href="#元数据类型" class="headerlink" title="元数据类型"></a>元数据类型</h2><p>在我们使用Clang将C语言程序输出成LLVM IR时，会发现代码的最后几行有</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">!llvm.module.flags</span> <span class="operator">=</span> !&#123;<span class="title">!0</span><span class="punctuation">,</span> <span class="title">!1</span><span class="punctuation">,</span> <span class="title">!2</span><span class="punctuation">,</span> <span class="title">!3</span>&#125;</span><br><span class="line"><span class="title">!llvm.ident</span> <span class="operator">=</span> !&#123;<span class="title">!4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!0</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> !<span class="string">&quot;wchar_size&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">4</span>&#125;</span><br><span class="line"><span class="title">!1</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">8</span><span class="punctuation">,</span> !<span class="string">&quot;PIC Level&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span>&#125;</span><br><span class="line"><span class="title">!2</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">7</span><span class="punctuation">,</span> !<span class="string">&quot;PIE Level&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span>&#125;</span><br><span class="line"><span class="title">!3</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">7</span><span class="punctuation">,</span> !<span class="string">&quot;uwtable&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span>&#125;</span><br><span class="line"><span class="title">!4</span> <span class="operator">=</span> !&#123;!<span class="string">&quot;Homebrew clang version 16.0.6&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>类似于这样的东西。</p>
<p>在LLVM IR中，以<code>!</code>开头的标识符为<strong>元数据</strong>。元数据是为了<em>将额外的信息附加在程序中传递给LLVM后端，使后端能够好地优化或生成代码。</em>用于Debug的信息就是通过元数据形式传递的。我们可以使用<code>-g</code>选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang -S -emit-llvm -g test.c</span><br></pre></td></tr></table></figure>

<p>来在LLVM IR中附加额外的Debug信息。关于元数据，在后续的章节里会有更具体的介绍。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>最后，还有一种叫做属性的概念。属性并不是类型，其一般用于函数。比如说，告诉编译器这个函数不会抛出错误，不需要某些优化等等。我们可以看到</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>() <span class="keyword">nounwind</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>nounwind</code>就是一个属性。</p>
<p>有时候，一个函数的属性会特别特别多，并且有多个函数都有相同的属性。那么，就会有大量重复的篇幅用来给每一个函数说明属性。因此，<strong>LLVM IR引入了属性组的概念</strong>，我们在将一个简单的C程序编译成LLVM IR时，会发现代码中有</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; <span class="keyword">noinline</span> <span class="keyword">nounwind</span> <span class="keyword">optnone</span> <span class="keyword">ssp</span> <span class="keyword">uwtable</span> <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;darwin-stkchk-strong-link&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span><span class="operator">=</span><span class="string">&quot;0&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;probe-stack&quot;</span><span class="operator">=</span><span class="string">&quot;___chkstk_darwin&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span><span class="operator">=</span><span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span><span class="operator">=</span><span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这种一大长串的，就是属性组。属性组总是以<code>#</code>开头。当我们函数需要它的时候，只需要</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span> <span class="variable">#0</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接使用<code>#0</code>即可。关于属性，后续也会有专门的章节进行介绍。</p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>在程序分析领域，往往会强调一对概念：<strong>数据流与控制流</strong>。所谓数据流，就是指一个程序中的数据，从硬盘到内存，从内存到寄存器，等等一系列的数据搬运、处理的过程。这一过程，在之前的文章中已经详细地介绍了。</p>
<p>而控制流，则是指程序执行指令的顺序。最简单地，我们的程序在除了顺序执行指令，还可以通过<code>if</code>语句进行条件跳转，通过<code>for</code>、<code>while</code>语句进行循环，还可以通过函数调用进入到别的函数。凡此种种，都是程序控制流的变化。</p>
<p>在使用LLVM作为编译器的时候，控制流往往就意味着更多的优化可能，如分支布局、函数内联。在使用LLVM作为静态分析工具的过程中，控制流也意味着更高的复杂度，如间接跳转、间接调用的识别和恢复。</p>
<p>因此，我们需要仔细了解LLVM中的控制流。</p>
<h2 id="汇编层面的控制语句"><a href="#汇编层面的控制语句" class="headerlink" title="汇编层面的控制语句"></a>汇编层面的控制语句</h2><p>在大多数语言中，常见的控制语句主要有四种：</p>
<ul>
<li><code>if</code> .. <code>else</code></li>
<li><code>for</code></li>
<li><code>while</code></li>
<li><code>switch</code></li>
</ul>
<p>在汇编语言层面，控制语句则被分解为两种核心的指令：条件跳转与无条件跳转（<code>switch</code>其实还有一些工作，之后会提到）。我们下面分别来看看在汇编层面是怎样实现控制语句的。</p>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if .. else"></a><code>if</code> .. <code>else</code></h3><p>我们有以下C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="comment">// Do something A</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Do something B</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Do something C</span></span><br></pre></td></tr></table></figure>

<p>为了将这个指令改写成汇编指令，我们同时需要条件跳转与无条件跳转。我们用伪代码表示其汇编指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Compare a and b</span><br><span class="line">    Jump to label B if comparison is a is not greater than b // conditional jump</span><br><span class="line">label A:</span><br><span class="line">    Do something A</span><br><span class="line">    Jump to label C // unconditional jump</span><br><span class="line">label B:</span><br><span class="line">    Do something B</span><br><span class="line">label C:</span><br><span class="line">    Do something C</span><br></pre></td></tr></table></figure>

<p>汇编语言通过条件跳转、无条件跳转和三个标签（<code>label A</code>标签实际上没有作用，只不过让代码更加清晰）实现了高级语言层面的<code>if</code> .. <code>else</code>语句。</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a><code>for</code></h3><p>我们有以下C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// Do something A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Do something B</span></span><br></pre></td></tr></table></figure>

<p>为了将这个指令改写为汇编指令，我们同样地需要条件跳转与无条件跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    int i = 0</span><br><span class="line">label start:</span><br><span class="line">    Compare i and 4</span><br><span class="line">    Jump to label B if comparison is i is not less than 4 // conditional jump</span><br><span class="line">label A:</span><br><span class="line">    Do something A</span><br><span class="line">    i++</span><br><span class="line">    Jump to label start // unconditional jump</span><br><span class="line">label B:</span><br><span class="line">    Do something B</span><br></pre></td></tr></table></figure>

<p>而<code>while</code>与<code>for</code>则极其类似，只不过少了初始化与自增的操作，这里不再赘述。</p>
<p>根据我们在汇编语言中积累的经验，我们得出，要实现大多数高级语言的控制语句，我们需要四个东西：</p>
<ul>
<li>标签</li>
<li>无条件跳转</li>
<li>比较大小的指令</li>
<li>条件跳转</li>
</ul>
<h2 id="LLVM-IR层面的控制语句"><a href="#LLVM-IR层面的控制语句" class="headerlink" title="LLVM IR层面的控制语句"></a>LLVM IR层面的控制语句</h2><p>下面就以我们上面的<code>for</code>循环的C语言版本为例，解释如何写其对应的LLVM IR语句。</p>
<p>首先，我们对应的LLVM IR的基本框架为</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                       <span class="comment">; int i = ...</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                   <span class="comment">; ... = 0</span></span><br><span class="line"><span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line"><span class="comment">; Do something A</span></span><br><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>              <span class="comment">; ... = i + 1</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                  <span class="comment">; i = ...</span></span><br><span class="line"><span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<p>这个程序缺少了一些必要的步骤，而我们之后会将其慢慢补上。</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>在LLVM IR中，标签与汇编语言的标签一致，也是以<code>:</code>结尾作标记。我们依照之前写的汇编语言的伪代码，给这个程序加上标签：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                  <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>              <span class="comment">; ... = 0</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>         <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>             <span class="comment">; i = ...</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><p>LLVM IR提供的比较指令为<code>icmp</code>。其接受三个参数：比较方案以及两个比较参数。这样讲比较抽象，我们就来看一下一个最简单的比较指令的例子：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">uge</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="variable">%b</span></span><br></pre></td></tr></table></figure>

<p>这个例子转化为C++语言就是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> comparison_result = ((<span class="type">unsigned</span> <span class="type">int</span>)a &gt;= (<span class="type">unsigned</span> <span class="type">int</span>)b);</span><br></pre></td></tr></table></figure>

<p>这里，<code>uge</code>是比较方案，<code>%a</code>和<code>%b</code>就是用来比较的两个数，而<code>icmp</code>则返回一个<code>i1</code>类型的值，也就是C++中的<code>bool</code>值，用来表示结果是否为真。</p>
<p><code>icmp</code>支持的比较方案很广泛：</p>
<ul>
<li>首先，最简单的是<code>eq</code>与<code>ne</code>，分别代表相等或不相等。</li>
<li>然后，是无符号的比较<code>ugt</code>, <code>uge</code>, <code>ult</code>, <code>ule</code>，分别代表大于、大于等于、小于、小于等于。我们之前在数的表示中提到，LLVM IR中一个整型变量本身的符号是没有意义的，而是需要看在其参与的指令中被看作是什么符号。这里每个方案的<code>u</code>就代表以无符号的形式进行比较。</li>
<li>最后，是有符号的比较<code>sgt</code>, <code>sge</code>, <code>slt</code>, <code>sle</code>，分别是其无符号版本的有符号对应。</li>
</ul>
<p>我们来看加上比较指令之后，我们的例子就变成了：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                               <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                           <span class="comment">; ... = 0</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">    <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">slt</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">4</span> <span class="comment">; Test if i &lt; 4</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>                      <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                          <span class="comment">; i = ...</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<h3 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h3><p>在比较完之后，我们需要条件跳转。我们来看一下我们此刻的目的：若<code>%comparison_result</code>是<code>true</code>，那么跳转到<code>A</code>，否则跳转到<code>B</code>。</p>
<p>LLVM IR为我们提供的条件跳转指令是<code>br</code>，其接受三个参数，第一个参数是<code>i1</code>类型的值，用于作判断；第二和第三个参数分别是值为<code>true</code>和<code>false</code>时需要跳转到的标签。比方说，在我们的例子中，就应该是</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br></pre></td></tr></table></figure>

<p>我们把它加入我们的例子：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                               <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                           <span class="comment">; ... = 0</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">    <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">slt</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">4</span> <span class="comment">; Test if i &lt; 4</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>                      <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                          <span class="comment">; i = ...</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<h3 id="无条件跳转"><a href="#无条件跳转" class="headerlink" title="无条件跳转"></a>无条件跳转</h3><p>无条件跳转更好理解，直接跳转到某一标签处。在LLVM IR中，我们同样可以使用<code>br</code>进行条件跳转。如，如果要直接跳转到<code>start</code>标签处，则可以</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">br</span> label <span class="variable">%start</span></span><br></pre></td></tr></table></figure>

<p>我们也把这加入我们的例子：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                               <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                           <span class="comment">; ... = 0</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">    <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">slt</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">4</span> <span class="comment">; Test if i &lt; 4</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>                      <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                          <span class="comment">; i = ...</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%start</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<p>这样看上去就结束了，然而如果大家把这个代码交给<code>llc</code>的话，并不能编译通过，这是为什么呢？</p>
<h3 id="Basic-block"><a href="#Basic-block" class="headerlink" title="Basic block"></a>Basic block</h3><p>首先，我们来摘录一下LLVM IR的参考指南中<a href="http://llvm.org/docs/LangRef.html#functions">Functions</a>节的一段话：</p>
<blockquote>
<p>A function definition contains a list of basic blocks, forming the CFG (Control Flow Graph) for the function. Each basic block may optionally start with a label (giving the basic block a symbol table entry), contains a list of instructions, and ends with a terminator instruction (such as a branch or function return). If an explicit label name is not provided, a block is assigned an implicit numbered label, using the next value from the same counter as used for unnamed temporaries (see above).</p>
</blockquote>
<p>这段话的大意有几个：</p>
<ul>
<li>一个函数由许多基本块(Basic block)组成</li>
<li>每个基本块包含：<ul>
<li>开头的标签（可省略）</li>
<li>一系列指令</li>
<li>结尾是终结指令</li>
</ul>
</li>
<li>一个基本块没有标签时，会自动赋给它一个标签</li>
</ul>
<p>所谓终结指令，就是指改变执行顺序的指令，如跳转、返回等。</p>
<p>我们来看看我们之前写好的程序是不是符合这个规定。<code>start</code>开头的基本块，在一系列指令后，以</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br></pre></td></tr></table></figure>

<p>结尾，是一个终结指令。<code>A</code>开头的基本块，在一系列指令后，以</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">br</span> label <span class="variable">%start</span></span><br></pre></td></tr></table></figure>

<p>结尾，也是一个终结指令。<code>B</code>开头的基本块，在最后总归是需要函数返回的（这里为了篇幅省略了），所以也一定会带有一个终结指令。</p>
<p>看上去都很符合呀，那为什么编译不通过呢？我们来仔细想一下，我们考虑了所有基本块了吗？要注意到，一个基本块是可以没有名字的，所以，实际上还有一个基本块没有考虑到，就是函数开头的：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>          <span class="comment">; int i = ...</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>      <span class="comment">; ... = 0</span></span><br></pre></td></tr></table></figure>

<p>这个基本块。它并没有以终结指令结尾！</p>
<p>所以，我们把一个终结指令补充在这个基本块的结尾：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                               <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                           <span class="comment">; ... = 0</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%start</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">    <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">slt</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">4</span> <span class="comment">; Test if i &lt; 4</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>                      <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                          <span class="comment">; i = ...</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%start</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<p>这样就完成了我们的例子。</p>
<p>LLVM的工具链甚至为我们提供了可视化控制语句的方法。我们使用之前提到的LLVM工具链中用于优化的<code>opt</code>工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">opt -p dot-cfg for.ll</span><br></pre></td></tr></table></figure>

<p>然后会生成一个<code>.main.dot</code>的文件。如果我们在计算机上装有<a href="http://www.graphviz.org/">Graphviz</a>，那么就可以用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dot .main.dot -Tpng -o for.png</span><br></pre></td></tr></table></figure>

<p>生成其可视化的控制流图（CFG）：</p>
<p><img src="/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/cfg.jpg"></p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a><code>switch</code></h3><p>下面我们来讲讲<code>switch</code>语句。我们有以下C语言程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// do something A</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// do something B</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// do something C</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do something else</span></span><br></pre></td></tr></table></figure>

<p>我们先直接来看其转换成LLVM IR是什么样子的：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="type">i32</span> <span class="variable">%x</span><span class="punctuation">,</span> label <span class="variable">%C</span> [</span><br><span class="line">    <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> label <span class="variable">%A</span></span><br><span class="line">    <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br><span class="line">]</span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line">C:</span><br><span class="line">    <span class="comment">; Do something C</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">    <span class="comment">; Do something else</span></span><br></pre></td></tr></table></figure>

<p>其核心就是第一行的<code>switch</code>指令。其第一个参数<code>i32 %x</code>是用来判断的，也就是我们C语言中的<code>x</code>。第二个参数<code>label %C</code>是C语言中的<code>default</code>分支，这是必须要有的参数。也就是说，我们的<code>switch</code>必须要有<code>default</code>来处理。接下来是一个数组，其意义已经很显然了，如果<code>%x</code>值是<code>0</code>，就去<code>label %A</code>，如果值是<code>1</code>，就去<code>label %B</code>。</p>
<p>LLVM后端对<code>switch</code>语句具体到汇编层面的实现则通常有两种方案：用一系列条件语句或跳转表。</p>
<p>一系列条件语句的实现方式最简单，用伪代码来表示的话就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (x == 0) &#123;</span><br><span class="line">    Jump to label %A</span><br><span class="line">&#125; else if (x == 1) &#123;</span><br><span class="line">    Jump to label %B</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Jump to label %C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是十分符合常理的。然而，我们需要注意到，如果这个<code>switch</code>语句一共有n个分支，那么其查找效率实际上是O(n)。那么，这种实现方案下的<code>switch</code>语句仅仅是<code>if</code> .. <code>else</code>的语法糖，除了增加可维护性，并不会优化什么性能。</p>
<p>跳转表则是一个可以优化性能的<code>switch</code>语句实现方案，其伪代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">labels = [label %A, label %B]</span><br><span class="line">if (x &lt; 0 || x &gt; 1) &#123;</span><br><span class="line">    Jump to label %C</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Jump to labels[x]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这只是一个极其粗糙的近似的实现，我们需要的是理解其基本思想。<strong>跳转表的思想就是利用内存中数组的索引是O(1)复杂度的</strong>，所以我们可以根据目前的<code>x</code>值去查找应该跳转到哪一个地址，这就是跳转表的基本思想。</p>
<p>根据目标平台和<code>switch</code>语句的分支数，LLVM后端会自动选择不同的实现方式去实现<code>switch</code>语句。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a><code>select</code></h3><p>我们经常会遇到一种情况，某一变量的值需要根据条件进行赋值，比如说以下C语言的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        y = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Do something with y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>x</code>大于<code>0</code>，则<code>y</code>为<code>1</code>，否则<code>y</code>为<code>2</code>。这一情况很常见，然而在C语言中，如果要实现这种功能，<code>y</code>需要被实现为可变变量，但实际上无论<code>x</code>如何取值，<code>y</code>只会被赋值一次，并不应该是可变的。</p>
<p>我们知道，LLVM IR中，由于SSA的限制，局部可变变量都必须分配在栈上，虽然LLVM后端最终会进行一定的优化，但写起代码来还需要冗长的<code>alloca</code>, <code>load</code>, <code>store</code>等语句。如果我们按照C语言的思路来写LLVM IR，那么就会是：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%x</span>) &#123;</span><br><span class="line">    <span class="variable">%y</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">sgt</span> <span class="type">i32</span> <span class="variable">%x</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%1</span><span class="punctuation">,</span> label <span class="variable">%btrue</span><span class="punctuation">,</span> label <span class="variable">%bfalse</span></span><br><span class="line"><span class="symbol">btrue:</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> ptr <span class="variable">%y</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">bfalse:</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> ptr <span class="variable">%y</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">    <span class="comment">; do something with %y</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看其编译出的汇编语言是怎样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo:</span><br><span class="line"># %bb.0:</span><br><span class="line">	cmpl	$0, %edi</span><br><span class="line">	jle	.LBB0_2</span><br><span class="line"># %bb.1:                                # %btrue</span><br><span class="line">	movl	$1, -4(%rsp)</span><br><span class="line">	jmp	.LBB0_3</span><br><span class="line">.LBB0_2:                                # %bfalse</span><br><span class="line">	movl	$2, -4(%rsp)</span><br><span class="line">.LBB0_3:                                # %end</span><br><span class="line">	retq</span><br></pre></td></tr></table></figure>

<p>算上注释，C语言代码9行，汇编语言代码11行，LLVM IR代码14行。这LLVM IR同时比低层次和高层次的代码都长，而且这种模式在真实的代码中出现的次数会非常多，这显然是不可以接受的。究其原因，就是这里把<code>y</code>看成了可变变量。那么，有没有什么办法让<code>y</code>不可变但仍然能实现这个功能呢？</p>
<p>首先，我们来看看同样区分可变变量与不可变变量的Rust是怎么做的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn foo(x: i32) &#123;</span><br><span class="line">    let y = if x &gt; 0 &#123; 1 &#125; else &#123; 2 &#125;;</span><br><span class="line">    // Do something with y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让代码简短的方式很简单，把<code>y</code>看作不可变变量，但同时需要语言支持把<code>if</code>语句视作表达式，当<code>x</code>大于<code>0</code>时，这个表达式返回<code>1</code>，否则返回<code>2</code>。这样，就很简单地实现了我们的需求。</p>
<p>LLVM IR中同样也有这样的指令，那就是<code>select</code>，我们来把上面的例子用<code>select</code>改写：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%x</span>) &#123;</span><br><span class="line">    <span class="variable">%result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">sgt</span> <span class="type">i32</span> <span class="variable">%x</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">    <span class="variable">%y</span> <span class="operator">=</span> <span class="keyword">select</span> <span class="type">i1</span> <span class="variable">%result</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span></span><br><span class="line">    <span class="comment">; Do something with %y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>select</code>指令接受三个参数。第一个参数是用来判断的布尔值，也就是<code>i1</code>类型的<code>icmp</code>判断的结果，如果其为<code>true</code>，则返回第二个参数，否则返回第三个参数。极其合理。</p>
<p><code>select</code>不仅可以简化LLVM代码，也可以优化生成的二进制程序。在大部分情况下，在AMD64架构中，LLVM会将<code>select</code>指令编译为<a href="https://www.felixcloutier.com/x86/cmovcc"><code>CMOV</code>cc</a>指令，也就是条件赋值，从而优化了生成的二进制代码。</p>
<h3 id="phi"><a href="#phi" class="headerlink" title="phi"></a><code>phi</code></h3><p><code>select</code>只能支持两个选择，<code>true</code>选择一个分支，<code>false</code>选择另一个分支，我们是不是可以有支持多种选择的类似<code>switch</code>的版本呢？同时，我们也可以换个角度思考，<code>select</code>是根据<code>i1</code>的值来进行判断，我们其实可以根据控制流进行判断。这就是在SSA技术中大名鼎鼎的<code>phi</code>指令。</p>
<p>为了方便起见，我们首先先来看用<code>phi</code>指令实现的我们上面这个代码：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%x</span>) &#123;</span><br><span class="line">    <span class="variable">%result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">sgt</span> <span class="type">i32</span> <span class="variable">%x</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%result</span><span class="punctuation">,</span> label <span class="variable">%btrue</span><span class="punctuation">,</span> label <span class="variable">%bfalse</span></span><br><span class="line"><span class="symbol">btrue:</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">bfalse:</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">    <span class="variable">%y</span> <span class="operator">=</span> <span class="keyword">phi</span> <span class="type">i32</span> [<span class="number">1</span><span class="punctuation">,</span> <span class="variable">%btrue</span>]<span class="punctuation">,</span> [<span class="number">2</span><span class="punctuation">,</span> <span class="variable">%bfalse</span>]</span><br><span class="line">    <span class="comment">; Do something with %y</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，<code>phi</code>的第一个参数是一个类型，这个类型表示其返回类型为<code>i32</code>。接下来则是两个数组，其表示，如果当前的basic block执行的时候，前一个basic block是<code>%btrue</code>，那么返回<code>1</code>，如果前一个basic block是<code>%bfalse</code>，那么返回<code>2</code>。</p>
<p>也就是说，<code>select</code>是根据其第一个参数<code>i1</code>类型的变量的值来决定返回哪个值，而<code>phi</code>则是根据其之前是哪个basic block来决定其返回值。此外，<code>phi</code>之后可以跟无数的分支，如<code>phi i32 [1, %a], [2, %b], [3, %c]</code>等，从而可以支持多分支的赋值。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在汇编层面，一个函数与一个控制语句极其相似，都是由标签组成，只不过在跳转时增加了一些附加的操作。而在LLVM IR层面，函数则得到了更高一层的抽象。</p>
<h2 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>在LLVM中，一个最基本的函数定义的样子我们之前已经遇到过多次，就是<code>@main</code>函数的样子：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数名之后可以加上参数列表，如：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="variable">%b</span>) &#123;</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个函数定义最基本的框架，就是返回值（<code>i32</code>）+函数名（<code>@foo</code>）+参数列表（<code>(i32 %a, i64 %b）</code>）+函数体（<code>&#123; ret i32 0 &#125;</code>）。</p>
<p>我们可以看到，函数的名称和全局变量一样，都是以<code>@</code>开头的。并且，如果我们查看符号表的话，也会发现其和全局变量一样进入了符号表。因此，函数也有和全局变量完全一致的Linkage Types和Visibility Style，来控制函数名在符号表中的出现情况，因此，可以出现如</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="keyword">private</span> <span class="type">i32</span> <span class="title">@foo</span>() &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的修饰符。</p>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>此外，我们还可以在参数列表之后加上属性，也就是控制优化器和代码生成器的指令。如果我们单纯编译一个简单的C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>其编译出的LLVM IR实际上是</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@foo</span>() <span class="variable">#0</span> &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; <span class="keyword">noinline</span> <span class="keyword">nounwind</span> <span class="keyword">optnone</span> <span class="keyword">uwtable</span> <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span><span class="operator">=</span><span class="string">&quot;0&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span><span class="operator">=</span><span class="string">&quot;true&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span><span class="operator">=</span><span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span><span class="operator">=</span><span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;tune-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;generic&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>#0</code>就是一个属性组，其包含了<code>noinline</code>、<code>nounwind</code>等若干个函数的属性。这些属性可以控制LLVM在优化和生成函数时的行为。大部分的属性可以在<a href="http://llvm.org/docs/LangRef.html#function-attributes">Function Attributes</a>一节看到。</p>
<p>当函数的属性比较少时，我们可以直接把属性写在函数定义后面，而不用以属性组的形式来写。例如下面这两种写法都是对的：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>() <span class="keyword">nounwind</span> &#123; <span class="keyword">ret</span> void &#125;</span><br><span class="line"><span class="comment">; or</span></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>() <span class="variable">#0</span> &#123; <span class="keyword">ret</span> void &#125;</span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> &#123;</span><br><span class="line">    <span class="keyword">nounwind</span> <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，无论是在代码编译还是在程序分析的过程中，我们最常处理的都在函数级别。因此，属性在这一过程中就是一个非常关键的概念。我们在编译器前端分析的过程中，遇到了特定的函数，给它加上相应的属性；在编译器后端生成代码时，则判断当前函数是否有相应的属性，从而可以在编译器前后端之间传递信息。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>除了函数定义之外，还有一种情况十分常见，那就是函数声明。<strong>我们在一个编译单元（模块）下，可以使用别的模块的函数，这时候就需要在本模块先声明这个函数，才能保证编译时不出错，从而在链接时正确将声明的函数与别的模块下其定义进行链接。</strong></p>
<p>函数声明也相对比较简单，就是使用<code>declare</code>关键词替换<code>define</code>：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="type">i32</span> <span class="title">@printf</span>(<span class="type">i8</span>*<span class="punctuation">,</span> ...) <span class="variable">#1</span></span><br></pre></td></tr></table></figure>

<p>这个就是在C代码中调用<code>stdio.h</code>库的<code>printf</code>函数时，在LLVM IR代码中可以看到的函数声明，其中<code>#1</code>就是又一大串属性组成的属性组。</p>
<h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>在LLVM IR中，函数的调用与高级语言几乎没有什么区别：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span>) &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@bar</span>() &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>call</code>指令可以像高级语言那样直接调用函数。我们来仔细分析一下这里做了哪几件事：</p>
<ul>
<li>传递参数</li>
<li>执行函数</li>
<li>获得返回值</li>
</ul>
<p>居然能干这么多事，这是汇编语言所羡慕不已的。</p>
<h3 id="执行函数"><a href="#执行函数" class="headerlink" title="执行函数"></a>执行函数</h3><p>我们知道，如果一个函数没有任何参数，返回值也是<code>void</code>类型，也就是说在C语言下这个函数是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么调用这个函数就没有了传递参数和获得返回值这两件事，只剩下执行函数，而这是一个最简单的事，以AMD64架构为例：</p>
<ol>
<li>把函数返回地址压栈</li>
<li>跳转到相应函数的地址</li>
</ol>
<p>函数返回也是一个最简单的事：</p>
<ol>
<li>弹栈获得函数返回地址</li>
<li>跳转到相应的返回地址</li>
</ol>
<p>这个在我们的汇编语言基础中已经反复遇到过多次，相信大家都会十分熟练。</p>
<h3 id="传递参数与获得返回值"><a href="#传递参数与获得返回值" class="headerlink" title="传递参数与获得返回值"></a>传递参数与获得返回值</h3><p>谈到这两点，就不得不说调用约定了。我们知道，在汇编语言中，是没有参数传递和返回值的概念的，有的仅仅是让当前的控制流跳转到指定函数执行。所以，一切的参数传递和返回值都需要我们人为约定。也就是说，我们需要约定两件事：</p>
<ul>
<li>被调用的函数希望知道参数是放在哪里的</li>
<li>调用者希望知道调用函数的返回值是放在哪里的</li>
</ul>
<p>这就是调用约定。不同的调用约定会产生不同的特效，也就产生了许多高级语言的feature。</p>
<h4 id="C调用约定"><a href="#C调用约定" class="headerlink" title="C调用约定"></a>C调用约定</h4><p>最广泛使用的调用约定是C调用约定，也就是各个操作系统的标准库使用的调用约定。在AMD64架构下，C调用约定是System V版本的，<strong>所有参数按顺序放入指定寄存器，如果寄存器不够，剩余的则从右往左顺序压栈。而返回值则是按先后顺序放入寄存器或者放入调用者分配的空间中，如果只有一个返回值，那么就会放在<code>rax</code>里。</strong></p>
<p>在LLVM IR中，函数的调用默认使用C调用约定。为了验证，我们可以写一个简单的程序：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; calling_convention_test.ll</span></span><br><span class="line"><span class="variable">%ReturnType</span> <span class="operator">=</span> <span class="keyword">type</span> &#123; <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span> &#125;</span><br><span class="line"><span class="keyword">define</span> <span class="variable">%ReturnType</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a3</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a4</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a5</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a6</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a7</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a8</span>) &#123;</span><br><span class="line">    <span class="keyword">ret</span> <span class="variable">%ReturnType</span> &#123; <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="variable">%ReturnType</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">3</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">4</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">5</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">6</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">7</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们查看其编译出来的汇编代码。在<code>main</code>函数中，参数传递是：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">movl    <span class="number">$1</span>, %edi</span><br><span class="line">movl    <span class="number">$2</span>, %esi</span><br><span class="line">movl    <span class="number">$3</span>, %edx</span><br><span class="line">movl    <span class="number">$4</span>, %ecx</span><br><span class="line">movl    <span class="number">$5</span>, %r8d</span><br><span class="line">movl    <span class="number">$6</span>, %r9d</span><br><span class="line">movl    <span class="number">$7</span>, (%rsp)</span><br><span class="line">movl    <span class="number">$8</span>, <span class="number">8</span>(%rsp)</span><br><span class="line">callq   foo@PLT</span><br></pre></td></tr></table></figure>

<p>而在<code>foo</code>函数内部，返回值传递是：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">movl    <span class="number">$1</span>, %eax</span><br><span class="line">movl    <span class="number">$2</span>, %edx</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>

<p>如果大家去查阅System V的指南的话，会发现完全符合。</p>
<p>这种System V的调用约定有什么好处呢？其最大的特点在于，当寄存器数量不够时，剩余的参数是按<strong>从右向左</strong>的顺序压栈。这就让基于这种调用约定的高级语言可以更轻松地实现可变参数的feature。所谓可变参数，最典型的例子就是C语言中的<code>printf</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, a, b, c, d);</span><br></pre></td></tr></table></figure>

<p><code>printf</code>可以接受任意数量的参数，其参数的数量是由第一个参数<code>&quot;%d %d %d %d&quot;</code>决定的。有多少个需要格式化的变量，接下来就还有多少个参数。</p>
<p>那么，System V的调用约定又是为什么能满足这样的需求呢？假设我们不考虑之前传入寄存器内的参数，只考虑压入栈内的参数。那么，如果是从右往左的顺序压栈，栈顶就是<code>&quot;%d %d %d %d&quot;</code>的地址，接着依次是<code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>。那么，我们的程序就可以先读栈顶，获得字符串，然后确定有多少个参数，接着就继续在栈上读多少个参数。相反，如果是从左往右顺序压栈，那么程序第一个读到的是<code>d</code>，程序也不知道该读多少个参数。</p>
<h4 id="fastcc"><a href="#fastcc" class="headerlink" title="fastcc"></a>fastcc</h4><p>各种语言的调用约定还有许多，可以参考语言指南的<a href="http://llvm.org/docs/LangRef.html#calling-conventions">Calling Conventions</a>一节。把所有的调用约定都讲一遍显然是不可能且枯燥的。所以，我在这里除了C调用约定之外，只再讲一个调用约定fastcc，以体现不同的调用约定能实现不同的高级语言的feature。</p>
<p>fastcc方案是将变量全都传入寄存器中的方案。这种方案使尾调用优化能更方便地实现。</p>
<p>尾调用会出现在很多场景下，用一个比较平凡的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> foo(a - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到，这个函数在返回时有可能会调用自身，这就叫尾调用。为什么尾调用需要优化呢？我们知道，在正常情况下，调用一个函数会产生函数的栈帧，也就是把函数的参数传入栈，把函数的返回地址传入栈。那么如果<code>a</code>很大，那么调用的函数会越来越多，并且直到最后一个被调用的函数返回之前，所有调用的函数的栈都不会回收，也就是说，我们此时栈上充斥着一层一层被调用函数返回的地址。</p>
<p>然而，由于这个函数是在调用者的返回语句里调用，我们实际上可以复用调用者的栈，这就是尾调用优化的基础思想。我们希望，把这样的尾调用变成循环，从而减少栈的使用。通过将参数都传入寄存器，我们可以避免再将参数传入栈，这就是fastcc为尾调用优化提供的帮助。然后，就可以直接将函数调用变成汇编中的<code>jmp</code>。</p>
<p>我们来看如果用fastcc调用约定，LLVM IR该怎么写：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; tail_call_test.ll</span></span><br><span class="line"><span class="keyword">define</span> <span class="keyword">fastcc</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span>) &#123;</span><br><span class="line">    <span class="variable">%res</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">eq</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%res</span><span class="punctuation">,</span> label <span class="variable">%btrue</span><span class="punctuation">,</span> label <span class="variable">%bfalse</span></span><br><span class="line"><span class="symbol">btrue:</span></span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">bfalse:</span></span><br><span class="line">    <span class="variable">%sub</span> <span class="operator">=</span> <span class="keyword">sub</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">    <span class="variable">%tail_call</span> <span class="operator">=</span> <span class="keyword">tail</span> <span class="keyword">call</span> <span class="keyword">fastcc</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%sub</span>)</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%tail_call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>llc</code>对其编译，并加上<code>-tailcallopt</code>的指令（实际上不加也没关系，LLVM后端会自动进行<a href="http://llvm.org/docs/CodeGenerator.html#sibling-call-optimization">Sibling call optimization</a>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">llc tail_call_test.ll -tailcallopt</span><br></pre></td></tr></table></figure>

<p>其编译而成的汇编代码中，其主体为：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    cmpl    <span class="number">$1</span>, %edi</span><br><span class="line">    <span class="keyword">jne</span>     .LBB0_2</span><br><span class="line">    movl    <span class="number">$1</span>, %eax</span><br><span class="line">    retq    <span class="number">$8</span></span><br><span class="line"><span class="symbol">.LBB0_2:</span></span><br><span class="line">    pushq   %rax</span><br><span class="line">    decl    %edi</span><br><span class="line">    popq    %rax</span><br><span class="line">    <span class="keyword">jmp</span>     foo@PLT</span><br></pre></td></tr></table></figure>

<p>我们可以发现，在结尾，使用的是<code>jmp</code>而不是<code>call</code>，所以从高级语言的角度，就可以看作其将尾部的调用变成了循环。并且，有两个操作：<code>pushq    %rax</code>和<code>popq    %rax</code>。这两个操作只是为了栈对齐，具体可以参考stack overflow上的回答<a href="https://stackoverflow.com/a/45823778/10005095">Why does this function push RAX to the stack as the first operation?</a>。</p>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>与控制语句的可视化类似，我们也可以通过LLVM工具链，获得LLVM IR的函数调用图（Call Graph）。</p>
<p>假设我们有以下LLVM IR:</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; cg.ll</span></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo1</span>() &#123;</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@foo4</span>(<span class="type">i32</span> <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@foo2</span>()</span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@foo3</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo4</span>(<span class="type">i32</span> <span class="variable">%0</span>) &#123;</span><br><span class="line">  <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">sgt</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%true_branch</span><span class="punctuation">,</span> label <span class="variable">%false_branch</span></span><br><span class="line"></span><br><span class="line">true_branch:</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@foo1</span>()</span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%final</span></span><br><span class="line"></span><br><span class="line">false_branch:</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@foo2</span>()</span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%final</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">final:</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@foo3</span>()</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>foo4</code>根据输入，调用<code>foo1</code>或者<code>foo2</code>，最终调用<code>foo3</code>。而<code>foo1</code>则递归调用<code>foo4</code>。</p>
<p>对于这样的LLVM IR，我们使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">opt -p dot-callgraph cg.ll</span><br></pre></td></tr></table></figure>

<p>可以生成一个<code>cg.ll.callgraph.dot</code>的文件。类似CFG，我们可以使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dot cg.ll -Tpng -o cg.png</span><br></pre></td></tr></table></figure>

<p>生成如下图所示的函数调用图：</p>
<p><img src="/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/callCFG.jpg" alt="Call Graph"></p>
<h2 id="内置函数、属性和元数据"><a href="#内置函数、属性和元数据" class="headerlink" title="内置函数、属性和元数据"></a>内置函数、属性和元数据</h2><p>在LLVM IR中，除了基础的数据表示、控制流之外，还有内置函数、属性和元数据等，能够影响二进制程序生成的功能。</p>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>我们回顾一下，LLVM IR的作用实际上是将编译器前端与后端解耦合。编程语言的前端开发者，负责将输入的编程语言代码进行解析，生成LLVM IR；指令集架构的后端开发者，负责将输入的LLVM IR生成为目标架构的二进制指令。因此，LLVM IR提供了若干非常基础的指令，如<code>add</code>、<code>br</code>、<code>call</code>等。这样做的好处在于：</p>
<ul>
<li>对前端开发者而言，这些指令语义足够全，使用方法也和常见高级语言类似。</li>
<li>对后端开发者而言，这些指令相对数目比较少，提供的功能也相对较为独立，在大部分常见的指令集中都有类似的指令与其对应。</li>
</ul>
<p>但是，这样的策略也有其弊端：</p>
<ul>
<li>对前端开发者而言，仍然有部分通用的语义无法被单个指令所涵盖</li>
<li>对后端开发者而言，对一些通用指令的优化无法针对LLVM IR指令来做</li>
</ul>
<h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a><code>memcpy</code></h3><p>以内存拷贝为例。熟悉AMD64或者AArch64的开发者一定知道，在这些支持向量操作的指令集架构中，大规模的内存拷贝往往是通过向量指令来实现的，Glibc中的<code>memcpy</code>就是这样实现的。</p>
<p>但是对于通用编程语言来说，标准库往往不喜欢直接调用libc中的函数，会产生一些不必要的依赖。并且，<code>memcpy</code>用向量操作来实现已经是一个非常通用的方案了，所以能不能复用一些逻辑呢？</p>
<p>对于此类，LLVM IR指令过于基础，但是却非常广泛地使用同一套实现逻辑的情况，LLVM IR提供了「<a href="https://llvm.org/docs/LangRef.html#intrinsic-functions">内置函数</a>」（Intrinsic Functions）功能来解决。</p>
<p>所谓内置函数，我们可以理解成一些可以像普通的LLVM IR函数一样调用的函数，但这些函数不需要开发者自己实现，LLVM的后端开发者提供了这些函数的实现。</p>
<p>例如，LLVM IR提供了<a href="https://llvm.org/docs/LangRef.html#llvm-memcpy-intrinsic"><code>llvm.memcpy</code></a>内置函数，以提供内存的拷贝操作。前端开发者只需要调用这个函数，就可以实现内存拷贝功能了。</p>
<p>我们熟知的Rust语言，在利用LLVM生成二进制程序时，就是使用的这个函数，可以参考其封装的<a href="https://github.com/rust-lang/rust/blob/90c541806f23a127002de5b4038be731ba1458ca/compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp#L1448-L1456"><code>LLVMRustBuildMemCpy</code></a>与调用者<a href="https://github.com/rust-lang/rust/blob/90c541806f23a127002de5b4038be731ba1458ca/compiler/rustc_codegen_llvm/src/builder.rs#L871-L896"><code>memcpy</code></a>。</p>
<h3 id="静态分支预测"><a href="#静态分支预测" class="headerlink" title="静态分支预测"></a>静态分支预测</h3><p>LLVM IR提供的内置函数有许多，这里，我们再以静态分支预测为例，介绍一个常见内置函数。</p>
<p>我们在阅读一些大规模项目源码时，例如Linux内核源码、QEMU源码等，往往会注意到大量使用的<code>likely</code>与<code>unlikely</code>，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (likely(x &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>likely</code>是什么？它是干什么用的？事实上，<code>likely</code>与<code>unlikely</code>往往是通过宏定义实现的，它们的作用是静态分支预测。</p>
<p>我们知道，对于C语言等常见的编程语言的<code>if</code>语句，在生成二进制程序的时候，我们可以交换它的两个分支的位置。紧接着<code>cmp</code>等判断语句的分支，在执行时，不会发生跳转，而另一个分支则需要设置PC寄存器来跳转。这种跳转往往会造成一定程度的性能损耗，这些具体的我在「<a href="https://github.com/Evian-Zhang/learn-assembly-on-Apple-Silicon-Mac">在 Apple Silicon Mac 上入门汇编语言</a>」中的<a href="https://evian-zhang.github.io/learn-assembly-on-Apple-Silicon-Mac/11-%E8%B7%B3%E8%BD%AC.html#%E7%BC%96%E8%AF%91%E6%9C%9F%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B">编译期分支预测</a>一节中有详细阐述。总之，我们需要给编译器一些信息，来排布不同的分支布局。</p>
<p>对于Clang来说，这是通过<a href="https://llvm.org/docs/BranchWeightMetadata.html#built-in-expect-instructions">内置<code>expect</code>指令</a>来实现的，也就是说：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x)       __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x)     __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure>

<p>而<code>__builtin_expect</code>这个内置指令，就会翻译为LLVM IR中的<a href="https://llvm.org/docs/LangRef.html#llvm-expect-intrinsic"><code>llvm.expect</code></a>内置函数，从而实现了静态分支预测。</p>
<h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><p>在C语言中，我们会遇到一个函数的修饰符：<code>inline</code>。这个修饰符会提示编译器，建议编译器在遇到这个函数的调用时，内联这个函数。这类的信息，LLVM会将其看作函数的「<a href="https://llvm.org/docs/LangRef.html#function-attributes">属性</a>」（Attribtues）。</p>
<p>在之前，我们也提到过，我们可以：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>() attr<span class="number">1</span> attr<span class="number">2</span> attr<span class="number">3</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个函数有相同的属性，我们可以用一个属性组的形式来复用：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo1</span>() <span class="variable">#0</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo2</span>() <span class="variable">#0</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; attr<span class="number">1</span> attr<span class="number">2</span> attr<span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<p>LLVM支持的函数属性有多种，我们来看看几个比较容易理解的，由函数属性控制的优化：</p>
<h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><p>函数内联是一个非常复杂的概念，这里我们只是简单地来看一下，下面这个C语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a)</span> __<span class="title function_">attribute__</span><span class="params">((always_inline))</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里声明了<code>foo</code>函数，并且用了一个扩展语法<code>__attribute__((always_inline))</code>，这个语法实际上的作用就是给函数加上<code>alwaysinline</code>的属性。</p>
<p>我们查看其生成的LLVM IR：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> dso_local <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> noundef <span class="variable">%0</span>) <span class="variable">#0</span> &#123;</span><br><span class="line">  <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; <span class="keyword">alwaysinline</span> <span class="keyword">nounwind</span> <span class="keyword">uwtable</span> <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span><span class="operator">=</span><span class="string">&quot;0&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span><span class="operator">=</span><span class="string">&quot;true&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span><span class="operator">=</span><span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span><span class="operator">=</span><span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;tune-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;generic&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，其确实有了<code>alwaysinline</code>这个属性。</p>
<h3 id="帧指针清除优化"><a href="#帧指针清除优化" class="headerlink" title="帧指针清除优化"></a>帧指针清除优化</h3><p>我们再来看一个属性控制的优化：帧指针清除优化（Frame Pointer Elimination）。</p>
<p>在讲这个之前，先讲一个比较小的优化。我们将一个非常简单的C程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译为汇编程序，可以发现，<code>foo</code>函数的汇编代码为：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    pushq   %rbp</span><br><span class="line">    <span class="keyword">movq</span>    %rsp, %rbp</span><br><span class="line">    movl    %edi, -<span class="number">4</span>(%rbp)</span><br><span class="line">    movl    %esi, -<span class="number">8</span>(%rbp)</span><br><span class="line">    popq    %rbp</span><br></pre></td></tr></table></figure>

<p>与我们常识有些违背。为啥这里栈不先增加（也就是对<code>rsp</code>寄存器进行<code>sub</code>），就直接把<code>edi</code>, <code>esi</code>的值移入栈内了呢？<code>-4(%rbp)</code>和<code>-8(%rbp)</code>的内存空间此刻似乎并不属于栈。</p>
<p>这是因为，在System V关于amd64架构的标准中，规定了<code>rsp</code>以下128个字节为red zone。这个区域，信号和异常处理函数均不会使用。因此，一个函数可以放心使用<code>rsp</code>以下128个字节的内容。</p>
<p>同时，我们对栈指针进行操作，一个很重要的原因就是为了进一步函数调用的时候，使用<code>call</code>指令会自动将被调用函数的返回地址压栈，那么就需要在调用<code>call</code>指令之前，保证栈顶指针确实指向栈顶，否则压栈就会覆盖一些数据。</p>
<p>但此时，我们的<code>foo</code>函数并没有调用别的函数，也就不会产生压栈行为。因此，如果在栈帧不超过128个字节的情况下，编译器自动为我们省去了这样的操作。为了验证这一点，我们做一个小的修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; bar(); &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，我们再看编译出的<code>foo</code>函数的汇编代码：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    pushq   %rbp</span><br><span class="line">    <span class="keyword">movq</span>    %rsp, %rbp</span><br><span class="line">    subq    <span class="number">$16</span>, %rsp</span><br><span class="line">    movl    %edi, -<span class="number">4</span>(%rbp)</span><br><span class="line">    movl    %esi, -<span class="number">8</span>(%rbp)</span><br><span class="line">    callq   bar</span><br><span class="line">    addq    <span class="number">$16</span>, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>

<p>确实增加了对<code>rbp</code>的<code>sub</code>和<code>add</code>操作。而此时的<code>bar</code>函数，也没有对<code>rsp</code>的操作。</p>
<p>接下来，就要讲帧指针清除优化了。经过我们上述的讨论，一个函数在进入时会有一些固定动作：</p>
<ol>
<li>把<code>rbp</code>压栈</li>
<li>把<code>rsp</code>放入<code>rbp</code></li>
<li>减<code>rsp</code>，预留栈空间</li>
</ol>
<p>在函数返回之前，也有其相应的操作：</p>
<ol>
<li>加<code>rsp</code>，回收栈空间</li>
<li>把<code>rbp</code>最初的值弹栈回到<code>rbp</code></li>
</ol>
<p>我们刚刚讲的优化，使得没有调用别的函数的函数，可以省略掉进入时的第3步和返回前的第1步。那么，是否还可以继续省略呢？</p>
<p>那么，我们就要考虑为什么需要这些步骤。这些步骤都是围绕<code>rbp</code>进行的，而正是因为<code>rbp</code>经常进行这种操作，所以我们把<code>rbp</code>称为帧指针。之所以要进行这些操作，是因为我们在函数执行的过程中，栈顶指针随着不断调用别的函数，会不断移动，导致我们根据栈顶指针的位置，不太方便确定局部变量的位置。而如果我们在一开始就把<code>rsp</code>的值放在<code>rbp</code>中，那么局部变量的位置相对<code>rbp</code>是固定的，就更好确认了。注意到我们这里说根据<code>rsp</code>的值确认局部变量的位置只是不方便，但并不是不能做到。所以，我们可以增加一些编译器的负担，而把帧指针清除。</p>
<p>帧指针清除在LLVM IR层面其实十分方便，就是什么都不写。我们可以观察</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%b</span>) &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> ptr <span class="variable">%1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%b</span><span class="punctuation">,</span> ptr <span class="variable">%2</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数在编译成汇编语言之后，是：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    movl    %edi, -<span class="number">4</span>(%rsp)</span><br><span class="line">    movl    %esi, -<span class="number">8</span>(%rsp)</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>

<p>不仅没有了栈的增加减少（之前提过的优化），也没有了对<code>rbp</code>的操作（帧指针清除）。</p>
<p>要想恢复这一操作也十分简单，在函数参数列表后加上一个属性<code>&quot;frame-pointer&quot;=&quot;all&quot;</code>：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%b</span>) <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> ptr <span class="variable">%1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%b</span><span class="punctuation">,</span> ptr <span class="variable">%2</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其编译后的汇编程序就是：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    pushq   %rbp</span><br><span class="line">    <span class="keyword">movq</span>    %rsp, %rbp</span><br><span class="line">    movl    %edi, -<span class="number">4</span>(%rbp)</span><br><span class="line">    movl    %esi, -<span class="number">8</span>(%rbp)</span><br><span class="line">    popq    %rbp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>

<p>恢复了往日的雄风。</p>
<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>函数的属性可以在前后端之间传递函数的信息，例如，前端发现某个函数需要后端的特殊处理，就给这个函数加一个自定义的属性。而在LLVM的整个管线中的任意一个位置，我们往往都能读到这个属性，从而可以依据是否有这个属性来做特殊的处理&#x2F;优化。正因如此，之所以函数要有属性，是因为函数是LLVM的优化过程中一个非常重要的基础单元，因此需要保留各种信息。</p>
<p>除此之外，我们有时也会希望每一条指令，或者每一个翻译单元，都可以有类似属性一样的信息，可以在管线中传递&#x2F;过滤，从而能获得一些信息。这在LLVM IR中被称为「<a href="https://llvm.org/docs/LangRef.html#metadata">元数据</a>」（Metadata）。</p>
<h3 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h3><p>说了这么多，元数据具体有什么用处呢？元数据的语法又是怎样的呢？我们来看一个具体的例子。</p>
<p>我们知道，在Clang中，传入<code>-g</code>选项可以生成调试信息。那么，调试信息是怎么在LLVM IR中体现的呢？</p>
<p>我们这样一个<code>debug.c</code>文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang debug.c -g -S -emit-llvm</span><br></pre></td></tr></table></figure>

<p>生成LLVM IR文件，其一部分如下：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local <span class="type">i32</span> <span class="title">@sum</span>(<span class="type">i32</span> noundef <span class="variable">%0</span><span class="punctuation">,</span> <span class="type">i32</span> noundef <span class="variable">%1</span>) <span class="variable">#0</span> <span class="title">!dbg</span> <span class="title">!10</span> &#123;</span><br><span class="line">  <span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="variable">%4</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> ptr <span class="variable">%3</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.dbg.declare</span>(metadata ptr <span class="variable">%3</span><span class="punctuation">,</span> metadata <span class="title">!15</span><span class="punctuation">,</span> metadata <span class="title">!DIExpression</span>())<span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!16</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%4</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.dbg.declare</span>(metadata ptr <span class="variable">%4</span><span class="punctuation">,</span> metadata <span class="title">!17</span><span class="punctuation">,</span> metadata <span class="title">!DIExpression</span>())<span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!18</span></span><br><span class="line">  <span class="variable">%5</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%3</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span><span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!19</span></span><br><span class="line">  <span class="variable">%6</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%4</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span><span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!20</span></span><br><span class="line">  <span class="variable">%7</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="keyword">nsw</span> <span class="type">i32</span> <span class="variable">%5</span><span class="punctuation">,</span> <span class="variable">%6</span><span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!21</span></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%7</span><span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"></span><br><span class="line"><span class="title">!llvm.dbg.cu</span> <span class="operator">=</span> !&#123;<span class="title">!0</span>&#125;</span><br><span class="line"><span class="title">!llvm.module.flags</span> <span class="operator">=</span> !&#123;<span class="title">!2</span><span class="punctuation">,</span> <span class="title">!3</span><span class="punctuation">,</span> <span class="title">!4</span><span class="punctuation">,</span> <span class="title">!5</span><span class="punctuation">,</span> <span class="title">!6</span><span class="punctuation">,</span> <span class="title">!7</span><span class="punctuation">,</span> <span class="title">!8</span>&#125;</span><br><span class="line"><span class="title">!llvm.ident</span> <span class="operator">=</span> !&#123;<span class="title">!9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!0</span> <span class="operator">=</span> distinct <span class="title">!DICompileUnit</span>(language: DW_LANG_C<span class="number">11</span><span class="punctuation">,</span> file: <span class="title">!1</span><span class="punctuation">,</span> producer: <span class="string">&quot;Homebrew clang version 16.0.6&quot;</span><span class="punctuation">,</span> isOptimized: <span class="keyword">false</span><span class="punctuation">,</span> runtimeVersion: <span class="number">0</span><span class="punctuation">,</span> emissionKind: FullDebug<span class="punctuation">,</span> splitDebugInlining: <span class="keyword">false</span><span class="punctuation">,</span> nameTableKind: None)</span><br><span class="line"><span class="title">!1</span> <span class="operator">=</span> <span class="title">!DIFile</span>(filename: <span class="string">&quot;debug.c&quot;</span><span class="punctuation">,</span> directory: <span class="string">&quot;...&quot;</span><span class="punctuation">,</span> checksumkind: CSK_MD<span class="number">5</span><span class="punctuation">,</span> checksum: <span class="string">&quot;...&quot;</span>)</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="title">!10</span> <span class="operator">=</span> distinct <span class="title">!DISubprogram</span>(name: <span class="string">&quot;sum&quot;</span><span class="punctuation">,</span> scope: <span class="title">!1</span><span class="punctuation">,</span> file: <span class="title">!1</span><span class="punctuation">,</span> line: <span class="number">1</span><span class="punctuation">,</span> <span class="keyword">type</span>: <span class="title">!11</span><span class="punctuation">,</span> scopeLine: <span class="number">1</span><span class="punctuation">,</span> flags: DIFlagPrototyped<span class="punctuation">,</span> spFlags: DISPFlagDefinition<span class="punctuation">,</span> unit: <span class="title">!0</span><span class="punctuation">,</span> retainedNodes: <span class="title">!14</span>)</span><br><span class="line"><span class="title">!11</span> <span class="operator">=</span> <span class="title">!DISubroutineType</span>(types: <span class="title">!12</span>)</span><br><span class="line"><span class="title">!12</span> <span class="operator">=</span> !&#123;<span class="title">!13</span><span class="punctuation">,</span> <span class="title">!13</span><span class="punctuation">,</span> <span class="title">!13</span>&#125;</span><br><span class="line"><span class="title">!13</span> <span class="operator">=</span> <span class="title">!DIBasicType</span>(name: <span class="string">&quot;int&quot;</span><span class="punctuation">,</span> size: <span class="number">32</span><span class="punctuation">,</span> encoding: DW_ATE_signed)</span><br><span class="line"><span class="title">!14</span> <span class="operator">=</span> !&#123;&#125;</span><br><span class="line"><span class="title">!15</span> <span class="operator">=</span> <span class="title">!DILocalVariable</span>(name: <span class="string">&quot;a&quot;</span><span class="punctuation">,</span> arg: <span class="number">1</span><span class="punctuation">,</span> scope: <span class="title">!10</span><span class="punctuation">,</span> file: <span class="title">!1</span><span class="punctuation">,</span> line: <span class="number">1</span><span class="punctuation">,</span> <span class="keyword">type</span>: <span class="title">!13</span>)</span><br><span class="line"><span class="title">!16</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">1</span><span class="punctuation">,</span> column: <span class="number">13</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!17</span> <span class="operator">=</span> <span class="title">!DILocalVariable</span>(name: <span class="string">&quot;b&quot;</span><span class="punctuation">,</span> arg: <span class="number">2</span><span class="punctuation">,</span> scope: <span class="title">!10</span><span class="punctuation">,</span> file: <span class="title">!1</span><span class="punctuation">,</span> line: <span class="number">1</span><span class="punctuation">,</span> <span class="keyword">type</span>: <span class="title">!13</span>)</span><br><span class="line"><span class="title">!18</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">1</span><span class="punctuation">,</span> column: <span class="number">20</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!19</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">2</span><span class="punctuation">,</span> column: <span class="number">12</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!20</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">2</span><span class="punctuation">,</span> column: <span class="number">16</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!21</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">2</span><span class="punctuation">,</span> column: <span class="number">14</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!22</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">2</span><span class="punctuation">,</span> column: <span class="number">5</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在生成的LLVM IR中，出现了大量以<code>!</code>开头的符号，这就是元数据的语法。</p>
<p>具体而言，我们看到其中的</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">!12</span> <span class="operator">=</span> !&#123;<span class="title">!13</span><span class="punctuation">,</span> <span class="title">!13</span><span class="punctuation">,</span> <span class="title">!13</span>&#125;</span><br><span class="line"><span class="title">!13</span> <span class="operator">=</span> <span class="title">!DIBasicType</span>(name: <span class="string">&quot;int&quot;</span><span class="punctuation">,</span> size: <span class="number">32</span><span class="punctuation">,</span> encoding: DW_ATE_signed)</span><br></pre></td></tr></table></figure>

<p>这里，<code>!13 = ...</code>生成了一个元数据，其内容为一个给定的结构体<code>DIBasicType</code>，而<code>!12</code>这个元数据的内容，则并不是一个给定的结构体，而是由三个<code>!13</code>这个元数据组成的结构。也就是说，元数据的组织相对比较灵活。</p>
<p>在<code>sum</code>函数体中，我们可以看到，几乎每条指令后都附加了一个元数据，在代码下半部分找到对应的元数据，其实就是这行指令对应C语言中源代码里的位置，也就是调试信息中的location。</p>
<p>此外，我们还可以看到<code>llvm.dbg.declare</code>内置函数的调用。这个函数的作用是标记源代码中变量的地址。例如：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> ptr <span class="variable">%3</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">call</span> void <span class="title">@llvm.dbg.declare</span>(metadata ptr <span class="variable">%3</span><span class="punctuation">,</span> metadata <span class="title">!15</span><span class="punctuation">,</span> metadata <span class="title">!DIExpression</span>())<span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!16</span></span><br></pre></td></tr></table></figure>

<p>这里就是指，源代码中位于<code>!15</code>元数据处的变量，也就是<code>a</code>，其在生成的二进制程序中，位于<code>%3</code>变量。</p>
<p>LLVM中的调试信息非常全面且复杂，具体可以看官方文档<a href="https://llvm.org/docs/SourceLevelDebugging.html">Source Level Debugging with LLVM</a>。</p>
<h3 id="控制流完整性"><a href="#控制流完整性" class="headerlink" title="控制流完整性"></a>控制流完整性</h3><p>元数据的另一个用途，就在于控制流完整性保护。当一个攻击者攻击一个二进制程序的时候，最低级的攻击者只是让它崩溃，造成DoS攻击。高级的攻击者，往往想让这个程序执行自己想让它执行的命令。而这一途径，在现代攻击环境下，往往是通过函数指针覆盖来实现的。</p>
<p>举一个例子来说，在前几年，有一个非常著名的漏洞<a href="https://twitter.com/axi0mX/status/1177542201670168576?s=20">checkm8</a>。这个漏洞可以攻击苹果的大部分iPhone设备，并且由于代码处于ROM中，所以被认为无法修复。其具体的分析可以看<a href="https://habr.com/en/companies/dsec/articles/472762/">Technical analysis of the checkm8 exploit</a>和<a href="https://zhuanlan.zhihu.com/p/87456653">iPhone史诗级漏洞checkm8攻击原理浅析 - Gh0u1L5的文章 - 知乎</a>。我们这里只需要了解一点，它的核心是，Apple代码中有一个结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device_io_request</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *callback;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里<code>callback</code>是一个函数指针，在程序执行中会被调用。攻击者通过某种方法，强行覆盖了这个函数指针的值，从而让程序执行自己想要执行的函数。</p>
<p>为了抵御这种攻击，我们往往会采用控制流完整性（Control Flow Integrity, CFI）策略。最简单的思路是，我们在写程序时，函数指针所指向的函数，肯定是有限个确定的函数。那么，我们可以在执行函数指针所对应的间接调用时，检查调用目标是否是那有限个确定的函数，就可以保证不会出现之前的这种问题了。</p>
<p>但是，如何确定这个函数指针究竟能指向哪些函数呢？这个问题非常复杂，编译器往往是做不到这件事的。因此，现在一般会使用比较弱化的控制流完整性策略。在LLVM中，我们可以通过传递<code>-fsanitize=cfi-icall</code>来启用LLVM-CFI所提供的控制流完整性策略（需要同时通过<code>-flto</code>开启LTO），例如，我们有以下程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*f)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo1</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo2</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> a)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">baz</span><span class="params">(f func)</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将其保存为<code>cfi.c</code>，然后在命令行中使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang cfi.c -flto -fsanitize=cfi-icall -S -emit-llvm</span><br></pre></td></tr></table></figure>

<p>可以生成一个开启了LLVM-CFI策略的LLVM IR代码。</p>
<p>那么，LLVM-CFI策略是什么呢？由于其相对比较复杂，具体可以参考<a href="https://clang.llvm.org/docs/ControlFlowIntegrityDesign.html">Control Flow Integrity Design Documentation</a>，我们这里只是非常粗略地讲。</p>
<p>在上述代码中，<code>baz</code>函数接收一个函数指针，然后调用了这个函数指针。这个函数指针的类型是，不接收参数，也没有返回值。而LLVM-CFI采用的策略则是，只要满足这个类型的函数，都被认为是可以被函数指针所指向的。反之，如果不满足，则被拒绝。也就是说，在这个代码中，<code>foo1</code>、<code>foo2</code>都是满足的，而<code>bar</code>函数，因为它接收一个<code>int</code>类型的参数，所以不满足。</p>
<p>那么，具体是怎么实现的呢？我们来看看它的LLVM IR代码，其一部分为：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@foo1</span>() <span class="variable">#0</span> <span class="title">!type</span> <span class="title">!9</span> <span class="title">!type</span> <span class="title">!10</span> &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@foo2</span>() <span class="variable">#0</span> <span class="title">!type</span> <span class="title">!9</span> <span class="title">!type</span> <span class="title">!10</span> &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@bar</span>(<span class="type">i32</span> noundef <span class="variable">%0</span>) <span class="variable">#0</span> <span class="title">!type</span> <span class="title">!11</span> <span class="title">!type</span> <span class="title">!12</span> &#123;</span><br><span class="line">  <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> ptr <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@baz</span>(ptr noundef <span class="variable">%0</span>) <span class="variable">#0</span> <span class="title">!type</span> <span class="title">!13</span> <span class="title">!type</span> <span class="title">!14</span> &#123;</span><br><span class="line">  <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">alloca</span> ptr<span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> ptr <span class="variable">%0</span><span class="punctuation">,</span> ptr <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">load</span> ptr<span class="punctuation">,</span> ptr <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%4</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i1</span> <span class="title">@llvm.type.test</span>(ptr <span class="variable">%3</span><span class="punctuation">,</span> metadata !<span class="string">&quot;_ZTSFvvE&quot;</span>)<span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%4</span><span class="punctuation">,</span> label <span class="variable">%6</span><span class="punctuation">,</span> label <span class="variable">%5</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>:                                                <span class="comment">; preds = %1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.ubsantrap</span>(<span class="type">i8</span> <span class="number">2</span>) <span class="variable">#3</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line">  <span class="keyword">unreachable</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>:                                                <span class="comment">; preds = %1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="variable">%3</span>()</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!9</span> <span class="operator">=</span> !&#123;<span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> !<span class="string">&quot;_ZTSFvvE&quot;</span>&#125;</span><br><span class="line"><span class="title">!10</span> <span class="operator">=</span> !&#123;<span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> !<span class="string">&quot;_ZTSFvvE.generalized&quot;</span>&#125;</span><br><span class="line"><span class="title">!11</span> <span class="operator">=</span> !&#123;<span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> !<span class="string">&quot;_ZTSFviE&quot;</span>&#125;</span><br><span class="line"><span class="title">!12</span> <span class="operator">=</span> !&#123;<span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> !<span class="string">&quot;_ZTSFviE.generalized&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在<code>baz</code>函数中，在调用这个函数指针，也就是<code>call void %3()</code>之前，被插入了一部分代码：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">  <span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">load</span> ptr<span class="punctuation">,</span> ptr <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%4</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i1</span> <span class="title">@llvm.type.test</span>(ptr <span class="variable">%3</span><span class="punctuation">,</span> metadata !<span class="string">&quot;_ZTSFvvE&quot;</span>)<span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%4</span><span class="punctuation">,</span> label <span class="variable">%6</span><span class="punctuation">,</span> label <span class="variable">%5</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line"><span class="number">5</span>:                                                <span class="comment">; preds = %1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.ubsantrap</span>(<span class="type">i8</span> <span class="number">2</span>) <span class="variable">#3</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line">  <span class="keyword">unreachable</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br></pre></td></tr></table></figure>

<p>在这里，首先调用了<code>llvm.type.test</code>这个内置函数。这个内置函数的作用是查看<code>ptr %3</code>这个函数的类型，是否是<code>!&quot;_ZTSFvvE&quot;</code>这个元数据所代表的类型，如果不是的话，就跳转，调用<code>llvm.ubsantrap</code>报告错误。而我们可以看到，<code>foo1</code>、<code>foo2</code>、<code>bar</code>都被附加了一些元数据，查看代码的下半部分，可以看到，<code>foo1</code>、<code>foo2</code>的元数据是<code>!&quot;_ZTSFvvE&quot;</code>，而<code>bar</code>的元数据是<code>!&quot;_ZTSFviE&quot;</code>。因此，如果攻击者想让这个间接调用前往<code>bar</code>函数，就会被拒绝，从而保护了控制流的完整性。</p>
]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>project</tag>
        <tag>Flang</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年9月</title>
    <url>/2023/09/05/2023%E5%B9%B49%E6%9C%88/</url>
    <content><![CDATA[<h1 id="问题日志"><a href="#问题日志" class="headerlink" title="问题日志"></a>问题日志</h1><span id="more"></span>

<h2 id="Flang运行命令flang-function-f90-o-function-exe遇到问题："><a href="#Flang运行命令flang-function-f90-o-function-exe遇到问题：" class="headerlink" title="Flang运行命令flang function.f90 -o function.exe遇到问题："></a>Flang运行命令<code>flang function.f90 -o function.exe</code>遇到问题：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: cannot find -lflangmain</span><br><span class="line">/usr/bin/ld: cannot find -lflang</span><br><span class="line">/usr/bin/ld: cannot find -lflangrti</span><br><span class="line">/usr/bin/ld: cannot find -lpgmath</span><br><span class="line">clang-14: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure>

<p>解决办法：<a href="https://blog.51cto.com/crocodile/964277?articleABtest=1">解决&#x2F;usr&#x2F;bin&#x2F;ld: cannot find -lxxx_crocodile的记录空间的技术博客_51CTO博客</a></p>
<p>分析原因：编译Flang生成的动态库没有放到&#x2F;usr&#x2F;lib中，因此在使用时找不到该库。现在需要将这些文件放到系统指定查找的位置。</p>
<p>也就是将编译好的文件复制到默认查找的库的地址下去：<code>sudo cp -a lib* /usr/lib/</code>，这样就能解决问题了。</p>
<h2 id="linux下的so、a和o文件的区别"><a href="#linux下的so、a和o文件的区别" class="headerlink" title="linux下的so、a和o文件的区别"></a>linux下的so、a和o文件的区别</h2><p>如一个C程序，经过gcc编译后得到的依次是：.i,.s,.o。分别是预处理文件、汇编文件和二进制文件（单元编译的结果），将许多单元编译的.o文件链接成一个文件后，便是编译产物。</p>
<p>.o是中间文件，相当于windows系统下的.obj文件 。</p>
<p>.a为静态库，是好多个.o合在一起,用于静态链接， 相当于windows系统下的lib。</p>
<p>.so 为共享库，是shared object,用于动态链接的，相当于windows系统下的dll。</p>
<h2 id="gcc的编译过程"><a href="#gcc的编译过程" class="headerlink" title="gcc的编译过程"></a>gcc的编译过程</h2><p>编译过程的分步执行：<br>为了更好地理解gcc的工作过程，我们可以让在gcc工作的<strong>4个阶段</strong>中的任何一个阶段中停止下来。相关的参数有：<br><strong>-E</strong><br>预编译后停下来，生成后缀为 <strong>.i 的预编译文件</strong>。<br><strong>-c</strong><br>编译后停下来，生成后缀为 <strong>.o 的目标文件</strong>。<br><strong>-S</strong><br>汇编后停下来，生成后缀为 <strong>.s 的汇编源文件</strong>。</p>
<p>第一步：进行预编译，使用 -E 参数<br><code>gcc -E test.c -o test.i</code><br>查看 test.i 文件中的内容，会发现 stdio.h 的内容确实都插到文件里去了，而其他应当被预处理的宏定义也都做了相应的处理。<br>第二步：将 test.i 编译为目标代码，使用 -c 参数<br><code>gcc -c test.c -o test.o</code><br>第三步：生成汇编源文件<br><code>gcc -S test.c -o test.s</code><br>第四步：将生成的目标文件链接成可执行文件<br><code>gcc test.o - o test</code></p>
<p>对于稍微复杂的情况，比如有多个源代码文件、需要链接库或有其他比较特别的要求，就要给定适当的调用选项参数。</p>
<h2 id="解决Flang和IKOS适配问题的思路"><a href="#解决Flang和IKOS适配问题的思路" class="headerlink" title="解决Flang和IKOS适配问题的思路"></a>解决Flang和IKOS适配问题的思路</h2><p><img src="/paper_source/2023%E5%B9%B49%E6%9C%88/Flang%E4%B8%8EIKOS%E9%80%82%E9%85%8D%E6%80%9D%E8%B7%AF.jpg" alt="image-20230906101050110"></p>
<h2 id="pragma-once的使用规则"><a href="#pragma-once的使用规则" class="headerlink" title="pragma once的使用规则"></a>pragma once的使用规则</h2><p><code>#pragma once</code>是一个比较常用的C&#x2F;C++<a href="https://so.csdn.net/so/search?q=%E9%A2%84%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020">预处理</a>指令，只要在头文件的最开始加入这条预处理指令，就能够保证头文件只被编译一次，防止头文件被重复引用。</p>
<p><strong>“被重复引用”</strong>指<a href="https://so.csdn.net/so/search?q=%E5%A4%B4%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">头文件</a>在cpp文件中多次被include，include嵌套造可能现象造成头文件多次引用。</p>
<p>作用都是为了避免同一个被 #include 多次，或者避免头文件嵌套包含（参照前置声明的笔记）。需要特别注意的是：</p>
<ul>
<li><p>#pragma once 并不是C++的原生语法，而是编译器的一种支持，所以并不是所有的编译器都能够支持。#ifndef 则为C++的标准。</p>
</li>
<li><p>#ifndef 依赖于不重复的宏名称，保证了包含在 #endif 的内容不会被重复包含，这个内容可以是一个文件的所有内容，或者仅仅是一段代码。而 #pragma once 则是针对物理文件的一个标记，标记该文件不会被 #include 多次，不能只针对文件中某段代码进行标记。而且，#pragma once 不能保证多个文件的拷贝不会被重复包含，但这种错误更容易发现，且 #pragma once 大大提高了编译效率。</p>
</li>
<li><p>一般建议用 #pragma once，因为一个类声明和定义各占用一个物理文件，即使类声明之外的内容，也应该是和该类有关，比如非模板类中声明了模板接口，则需要在同一个文件定义该模板接口。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 自定义的宏名称</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 自定义的宏名称</span></span><br><span class="line">...整个文件的内容，或某段代码...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记当前物理文件只会被包含一次，但如果文件有多个拷贝，也会被重复包含</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once </span></span><br></pre></td></tr></table></figure>

<h2 id="namespace：命名空间的定义"><a href="#namespace：命名空间的定义" class="headerlink" title="namespace：命名空间的定义"></a>namespace：命名空间的定义</h2><p>在C语言中只有一个全局作用域：</p>
<ol>
<li>C语言中所有的全局标识符共享一个作用域</li>
<li>标识符之间可能发生冲突</li>
</ol>
<p>C++中提出了命名空间的概念：</p>
<ol>
<li>命名空间将全局作用域分成不同的部分</li>
<li>不同命名空间中的标识符可以同名而不会发生冲突</li>
<li>命名空间可以发生嵌套</li>
<li>全局作用域也叫默认命名空间</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Name</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">namespace</span> Internal</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*...*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++命名空间的使用：</p>
<ol>
<li>使用整个命名空间：<code>using namespace name;</code></li>
<li>使用命名空间中的变量：<code>using name::variable;</code></li>
<li>使用默认命名空间中的变量:  <code>::variable;</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> First </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> Second</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">namespace</span> Internal <span class="comment">//嵌套命名空间</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">P</span>  <span class="comment">//嵌套命名空间</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x;</span><br><span class="line">			<span class="type">int</span> y;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> First; <span class="comment">//使用整个命名空间</span></span><br><span class="line">	<span class="keyword">using</span> Second::Internal::P;  <span class="comment">//使用嵌套的命名空间</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;First::i = %d\n&quot;</span>, i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Second::i = %d\n&quot;</span>, Second::i);  <span class="comment">//使用命名空间中的变量</span></span><br><span class="line"> </span><br><span class="line">	P p = &#123; <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p.x = %d\n&quot;</span>, p.x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p.y = %d\n&quot;</span>, p.y);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unordered-map容器用法"><a href="#unordered-map容器用法" class="headerlink" title="unordered_map容器用法"></a>unordered_map容器用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap;</span><br><span class="line">    <span class="comment">//向 umap 容器添加新键值对</span></span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Java教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Linux教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出 umap 存储键值对的数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap size = &quot;</span> &lt;&lt; umap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//使用迭代器输出 umap 容器存储的所有键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体使用讲解见网址：<a href="http://c.biancheng.net/view/7231.html">C++ STL unordered_map容器用法详解 (biancheng.net)</a></p>
<h2 id="C-语法中explicit关键字的使用及示例"><a href="#C-语法中explicit关键字的使用及示例" class="headerlink" title="C++语法中explicit关键字的使用及示例"></a>C++语法中explicit关键字的使用及示例</h2><p><code>explicit</code> 是 C++ 语言中的一个关键字，它可以用来修饰单个参数的构造函数，表示该构造函数只能显式调用，禁止隐式转换。在 C++11 中，<code>explicit</code> 还可以用来修饰类型转换函数，表示只能显式进行类型转换。</p>
<p>下面是一个简单的示例，演示了 <code>explicit</code> 的使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : <span class="built_in">m_x</span>(x) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_x</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span> x)</span> : m_x(x) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_x</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.get_x() = &quot;</span> &lt;&lt; a.<span class="built_in">get_x</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b.get_x() = &quot;</span> &lt;&lt; b.<span class="built_in">get_x</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1 = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">funcA</span>(a1); <span class="comment">// 可以隐式转换</span></span><br><span class="line">    <span class="comment">// A a2 = &#x27;a&#x27;; // 错误：不允许隐式转换</span></span><br><span class="line"></span><br><span class="line">    B b1 = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// funcB(b1); // 错误：只能显式转换</span></span><br><span class="line">    <span class="built_in">funcB</span>(<span class="built_in">static_cast</span>&lt;B&gt;(<span class="number">3</span>)); <span class="comment">// 正确：显式转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详情见<a href="https://zhuanlan.zhihu.com/p/624294266">C++语法糖(explicit关键字)详解以及示例代码 - 知乎 (zhihu.com)</a></p>
<h2 id="C-中的noexcept关键字的用法"><a href="#C-中的noexcept关键字的用法" class="headerlink" title="C++中的noexcept关键字的用法"></a>C++中的noexcept关键字的用法</h2><p>在C++11标准中引入了<code>noexcept</code>关键字，它用于指示函数是否可能抛出异常。<code>noexcept</code>可以用于函数声明和函数定义中，如果将函数标记为<code>noexcept</code>，那么编译器就可以进行一些优化，从而提高程序性能。</p>
<p><code>noexcept</code>关键字可以放在函数声明和函数定义的括号后面，表示该函数不会抛出任何异常。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多细节请看[C++语法糖(noexcept关键字)详解以及示例代码 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/624737461#:~:text=%E5%9C%A8C%2B%2B11%E6%A0%87%E5%87%86%E4%B8%AD%E5%BC%95%E5%85%A5%E4%BA%86noexcept%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E5%AE%83%E7%94%A8%E4%BA%8E%E6%8C%87%E7%A4%BA%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E5%8F%AF%E8%83%BD%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E3%80%82,noexcept%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%B0%86%E5%87%BD%E6%95%B0%E6%A0%87%E8%AE%B0%E4%B8%BAnoexcept%EF%BC%8C%E9%82%A3%E4%B9%88%E7%BC%96%E8%AF%91%E5%99%A8%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E3%80%82">https://zhuanlan.zhihu.com/p/624737461#:~:text=在C%2B%2B11标准中引入了noexcept关键字，它用于指示函数是否可能抛出异常。,noexcept可以用于函数声明和函数定义中，如果将函数标记为noexcept，那么编译器就可以进行一些优化，从而提高程序性能。</a> noexcept关键字可以放在函数声明和函数定义的括号后面，表示该函数不会抛出任何异常。)</p>
<h2 id="C-中的const关键字使用"><a href="#C-中的const关键字使用" class="headerlink" title="C++中的const关键字使用"></a>C++中的const关键字使用</h2><p><strong>const修饰成员函数：常函数</strong></p>
<ul>
<li>成员函数后加<code>const</code>后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字<code>mutable</code>后，在常函数中依然可以修改</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		m_A = <span class="number">0</span>;</span><br><span class="line">		m_B = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">	<span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//const Type* const pointer;</span></span><br><span class="line">		<span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">		<span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line">		<span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//mA = 10000;</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">	person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象访问成员函数</span></span><br><span class="line">	person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节请看<a href="https://zhuanlan.zhihu.com/p/403182089">C++中const的5种用法总结 - 知乎 (zhihu.com)</a></p>
<h2 id="C-中的delete关键字使用"><a href="#C-中的delete关键字使用" class="headerlink" title="C++中的delete关键字使用"></a>C++中的delete关键字使用</h2><p><code>delete</code>有2个作用：</p>
<ol>
<li>释放<code>new</code>分配的动态内存；</li>
<li>阻止编译器自动合成函数；</li>
</ol>
<p><strong>释放new分配的动态内存</strong></p>
<p><code>delete</code>需要与<code>new</code>配对使用，其参数可以是指向一块内存首地址或空指针（<code>nullptr</code>）。不能对同一块内存多次delete，但是可以对空指针多次<code>delete</code>。</p>
<p>注意<code>delete</code>和<code>delete[] </code>的区别：</p>
<ul>
<li><code>delete p </code>释放<code>p</code>指向的（单个）内存，可用于释放单个内存对象；</li>
<li><code>delete []p </code>释放<code>p</code>指向的内存区块，可用于释放一组内存（数组）；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放基本类型内存</span></span><br><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">delete</span> pi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放类对象内存</span></span><br><span class="line"><span class="type">int</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> ps; <span class="comment">// 会调用string类析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放数组类型内存</span></span><br><span class="line"><span class="type">int</span> *pa = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> []pa;</span><br></pre></td></tr></table></figure>

<p><strong>阻止编译器合成函数</strong></p>
<p>适用于C++11以上版本。</p>
<p>如果没有为类编写<strong>构造函数、析构函数、拷贝构造函数、拷贝赋值运算符，以及移动拷贝函数、移动赋值运算符</strong>，编译器可能会为类合成默认的函数版本。显式使用<code>delete</code>，可以阻止编译器合成对应函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObj</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyObj</span>() = <span class="keyword">delete</span>; <span class="comment">// 阻止编译器合成构造函数，会导致类无法实例化</span></span><br><span class="line">  <span class="function">MyObj&amp; <span class="title">MyObj</span><span class="params">(<span class="type">const</span> MyObj &amp;)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 阻止编译器合成拷贝构造函数，会导致类无法拷贝构造，如std::cin, std::cout</span></span><br><span class="line">  MyObj&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyObj &amp;) = <span class="keyword">delete</span>; <span class="comment">// 阻止合成赋值运算符，会导致类无法拷贝，如cin, cout, cerr</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>与<code>delete</code>对应的是<code>default</code>，<code>default</code>显式告诉编译器使用编译器自动合成的函数。<br>合成的默认构造函数，只有基类子对象和类类型对象会被初始化，而其他所有的非静态成员（如整数，指针，数组等），都不会初始化，对他们进行初始化的应该是程序员，而非编译器。</p>
<p>如果类包含了需要动态创建对象的指针，就不能依靠合成的构造函数、拷贝构造函数、拷贝赋值运算符。</p>
<p>详情见<a href="https://www.cnblogs.com/fortunely/p/14554114.html">C++&gt; delete关键字初探 - 明明1109 - 博客园 (cnblogs.com)</a></p>
<h2 id="C-中的友元函数和友元类"><a href="#C-中的友元函数和友元类" class="headerlink" title="C++中的友元函数和友元类"></a>C++中的友元函数和友元类</h2><p>在 C++ 中，一个类中可以有 <code>public</code>、<code>protected</code>、<code>private </code>三种属性的成员，通过对象可以访问 <code>public </code>成员，只有本类中的函数可以访问本类的 private 成员。现在，我们来介绍一种例外情况——友元（friend）。借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。</p>
<p>friend 的意思是朋友，或者说是好友，与好友的关系显然要比一般人亲密一些。我们会对好朋友敞开心扉，倾诉自己的秘密，而对一般人会谨言慎行，潜意识里就自我保护。在 C++ 中，这种友好关系可以用<code>friend</code>关键字指明，中文多译为“友元”，借助友元可以访问与其有好友关系的类中的私有成员。如果你对“友元”这个名词不习惯，可以按原文 friend 理解为朋友。</p>
<p>友元函数<br>在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。</p>
<p><strong>友元函数可以访问当前类中的所有成员，包括 <code>public</code>、<code>protected</code>、<code>private</code> 属性的。</strong></p>
<p>细节请看<a href="https://blog.51cto.com/u_15080016/4567286">C++友元函数和友元类（C++ friend关键字）_51CTO博客_c++ 友元</a></p>
<h2 id="C-中智能指针unique-ptr使用"><a href="#C-中智能指针unique-ptr使用" class="headerlink" title="C++中智能指针unique_ptr使用"></a>C++中智能指针unique_ptr使用</h2><p>C++ 标准提供了 3 种智能指针，分别是 <code>shared_ptr</code>、<code>unique_ptr</code> 和 <code>weak_ptr</code>，本节我们给大家讲解 <code>unique_ptr</code> 智能指针的特性和用法。</p>
<blockquote>
<p>关于 shared_ptr 智能指针，可以阅读《<a href="http://c.biancheng.net/view/7898.html">C++11 shared_ptr智能指针</a>》一节；关于 weak_ptr 智能指针，可以阅读《<a href="http://c.biancheng.net/view/vip_8673.html">C++11 weak_ptr智能指针</a>》一节。</p>
</blockquote>
<p>作为智能指针的一种，<code>unique_ptr</code> 指针自然也具备“在适当时机自动释放堆内存空间”的能力。和 <code>shared_ptr </code>指针最大的不同之处在于，unique_ptr 指针指向的堆内存无法同其它 unique_ptr 共享，也就是说，每个 <code>unique_ptr </code>指针都独自拥有对其所指堆内存空间的所有权。</p>
<blockquote>
<p>这也就意味着，每个 unique_ptr 指针指向的堆内存空间的引用计数，都只能为 1，一旦该 unique_ptr 指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。</p>
</blockquote>
<p><code>unique_ptr </code>智能指针是以模板类的形式提供的，<code>unique_ptr&lt;T&gt;</code>（T 为指针所指数据的类型）定义在<code>&lt;memory&gt;</code>头文件，并位于 <code>std </code>命名空间中。因此，要想使用 <code>unique_ptr </code>类型指针，程序中应首先包含如下1条语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>unique_ptr智能指针的创建</strong></p>
<p>考虑到不同实际场景的需要，<code>unique_ptr&lt;T&gt;</code> 模板类提供了多个实用的构造函数，这里给读者列举了几种常用的构造<code>unique_ptr</code>智能指针的方式。</p>
<ol>
<li><p>通过以下 2 种方式，可以创建出空的 unique_ptr 指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code> unique_ptr</code> 指针的同时，也可以明确其指向。例如：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>基于<code> unique_ptr</code> 类型指针不共享各自拥有的堆内存，因此 C++11 标准中的 <code>unique_ptr</code> 模板类没有提供拷贝构造函数，只提供了移动构造函数。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(p4)</span></span>;<span class="comment">//错误，堆内存不共享</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>;<span class="comment">//正确，调用移动构造函数</span></span><br></pre></td></tr></table></figure>

<p>值得一提的是，对于调用移动构造函数的 p4 和 p5 来说，p5 将获取 p4 所指堆空间的所有权，而 p4 将变成空指针（<code>nullptr</code>）。默认情况下，<code>unique_ptr</code> 指针采用 <code>std::default_delete&lt;T&gt; </code>方法释放堆内存。当然，我们也可以自定义</p>
<ol start="4">
<li>符合实际场景的释放规则。值得一提的是，和 <code>shared_ptr</code> 指针不同，为 <code>unique_ptr</code> 自定义释放规则，只能采用函数对象的方式。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的释放规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myDel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>, myDel&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//std::unique_ptr&lt;int, myDel&gt; p6(new int, myDel());</span></span><br></pre></td></tr></table></figure>

<p>详细内容请见<a href="http://c.biancheng.net/view/7909.html">C++11 unique_ptr智能指针详解 (biancheng.net)</a>、<a href="https://zhuanlan.zhihu.com/p/404771979">C++内存管理——unique_ptr - 知乎 (zhihu.com)</a></p>
<h2 id="C-中的static关键字的使用"><a href="#C-中的static关键字的使用" class="headerlink" title="C++中的static关键字的使用"></a>C++中的static关键字的使用</h2><ol>
<li><p>全局静态变量，在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。<strong>内存中的位置：</strong> 静态存储区，在整个程序运行期间一直存在。<strong>初始化</strong>：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<strong>作用域</strong>：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
</li>
<li><p>局部静态变量，在局部变量之前加上关键字<code>static</code>，局部变量就成为一个局部静态变量。内存中的位置：静态存储区。初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>
</li>
<li><p>静态函数，在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是<code>extern</code>的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。函数的实现使用<code>static</code>修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；warning：不要再头文件中声明<code>static</code>的全局函数，不要在cpp内声明非<code>static</code>的全局函数，<br>如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p>
</li>
<li><p>类的静态成员，在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。</p>
</li>
<li><p>类的静态函数，静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。</p>
</li>
</ol>
<p>详情请查阅<a href="https://blog.csdn.net/u011718663/article/details/118218407">C++ Static关键字作用介绍_WhiteTian的博客-CSDN博客</a></p>
<h2 id="C-中的override的使用"><a href="#C-中的override的使用" class="headerlink" title="C++中的override的使用"></a>C++中的override的使用</h2><h3 id="virtual："><a href="#virtual：" class="headerlink" title="virtual："></a><code>virtual</code>：</h3><ul>
<li>放在函数的返回值前面，用于表示该成员函数为虚函数</li>
<li>父类虚函数前必须写；子类虚函数前可以省略（不管省不省略，该函数在子类中也是虚函数类型）</li>
<li>virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义</li>
</ul>
<h3 id="override："><a href="#override：" class="headerlink" title="override："></a><code>override</code>：</h3><ul>
<li>父类的虚函数不可使用</li>
<li>放在子类虚函数的参数列表后（如果函数有尾指返回类型，那么要放在尾指返回类型后），用来说明此函数为覆盖(重写)父类的虚函数。如果类方法在类外进行定义，那么override不能加</li>
<li>不一定强制要求子类声明这个关键字，但是建议使用</li>
<li>这是C++11标准填入的</li>
</ul>
<h3 id="final："><a href="#final：" class="headerlink" title="final："></a><code>final</code>：</h3><ul>
<li>如果我们定义的一个虚函数不想被派生类覆盖（重写），那么可以在虚函数之后添加一个final关键字，声明这个虚函数不可以被派生类所覆盖（重写）</li>
<li>如果函数有尾指返回类型，那么要放在尾指返回类型后</li>
</ul>
<p>细节见<a href="https://cloud.tencent.com/developer/article/1784495">C++:44—关键字virtual、override、final-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h2 id="C-中的static-cast怎么用"><a href="#C-中的static-cast怎么用" class="headerlink" title="C++中的static_cast怎么用"></a>C++中的<code>static_cast</code>怎么用</h2><p>仅根据表达式中存在的类型，将<code> expression</code> 转换为<code>type-id</code>类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static_cast</span> &lt;type-id&gt; ( expression )</span><br></pre></td></tr></table></figure>

<p>在标准 C++ 中，不进行运行时类型检查来帮助确保转换的安全。 在 C++&#x2F;CX 中，将执行编译时和运行时检查。 有关更多信息，请参见 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/casting?view=msvc-170">强制转换</a>中定义的接口的私有 C++ 特定实现。</p>
<p><code>static_cast</code> 运算符可用于将指向基类的指针转换为指向派生类的指针等操作。 此类转换并非始终安全。</p>
<p>通常使用 <code>static_cast</code> 转换数值数据类型，例如将枚举型转换为整型或将整型转换为浮点型，而且你能确定参与转换的数据类型。 <code>static_cast</code> 转换安全性不如 <code>dynamic_cast</code> 转换，因为 <code>static_cast</code> 不执行运行时类型检查，而 <code>dynamic_cast</code> 执行该检查。 对不明确的指针的 <code>dynamic_cast</code> 将失败，而 <code>static_cast</code>的返回结果看似没有问题；这是危险的。 尽管 <code>dynamic_cast</code>转换更加安全，但是 <code>dynamic_cast</code>*只适用于指针或引用，而且运行时类型检查也是一项开销。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/dynamic-cast-operator?view=msvc-170">dynamic_cast 运算符</a>。</p>
<p>详情请见<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/static-cast-operator?view=msvc-170">static_cast 运算符 | Microsoft Learn</a></p>
<h2 id="C-中的-ifdef怎么用"><a href="#C-中的-ifdef怎么用" class="headerlink" title="C++中的# ifdef怎么用"></a>C++中的<code># ifdef</code>怎么用</h2><p>可以在任何可以使用 <code>#if</code> 的地方使用 <code>#ifdef</code>*和 <code>#ifndef</code>指令。 如果定义了 <code>identifier</code>，<code>#ifdef``identifier</code> 语句等效于 <code>#if 1</code>。 如果 <code>identifier</code> 尚未定义或未被 <code>#undef</code>指令定义，它等效于 <code>#if 0</code>。 这些指令只检查使用 <code>#define</code> 定义的标识符是否存在，而不检查在 C 或 C++ 源代码中声明的标识符。</p>
<p>提供这些指令只是为了实现与该语言的早期版本的兼容性。 首选与 <code>#if</code> 指令一起使用的 <code>defined(``identifier</code>)&#96; 常量表达式。</p>
<p><code>#ifndef</code> 指令检查与 <code>#ifdef</code>检查的条件相反的情况。 如果尚未定义标识符，或者如果它的定义已用 <code>#undef</code> 删除，则条件为 <code>true</code>（非零值）。 否则，条件为 <code>false </code>(0)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ifdef_ifndef.CPP</span></span><br><span class="line"><span class="comment">// compile with: /Dtest /c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> test</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> final</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="C-中的-if-elif-endif怎么用"><a href="#C-中的-if-elif-endif怎么用" class="headerlink" title="C++中的# if, # elif, # endif怎么用"></a>C++中的<code># if, # elif, # endif</code>怎么用</h2><p>源文件中的每个 <code>#if </code>指令必须与表示结束的<code> #endif</code> 指令匹配。 任意数量的 <code>#elif</code> 指令可以出现在 #if 和<code>#endif</code>指令之间，但最多允许一个<code>#else</code>指令。 <code>#else </code>指令（如果有）必须是<code>#endif</code>之前的最后一个指令。</p>
<p><code>#if、#elif、#else </code>和 <code>#endif </code>指令可以嵌套在其他<code>#if</code>指令的 text 部分中。 每个嵌套的 <code>#else、#elif 或 #endif </code>指令属于最靠近的前面的 #if 指令。</p>
<p>所有条件编译指令（如 #if 和 #ifdef）都必须在文件末尾之前匹配一个 #endif 关闭指令。 否则会生成错误消息。 当条件编译指令包含在包含文件中时，这些指令必须满足相同的条件：包含文件的末尾不能有未匹配的条件编译指令。</p>
<p>在 #elif 命令后面的行部分中执行宏替换，以便能够在 constant-expression 中使用宏调用。</p>
<p>预处理器选择 text 的给定匹配项之一以进行进一步处理。 text 中指定的块可以是文本的任意序列。 它可占用多个行。 通常，text 是对编译器或预处理器有意义的程序文本。</p>
<p>预处理器处理选定的 text，并将其传递给编译器。 如果 text 包含预处理器指令，则预处理器将执行这些指令。 仅编译预处理器所选的文本块。</p>
<p>预处理器通过计算每个 #if 或 #elif 指令后面的常量表达式来选择单个 text 项，直到找到实际（非零）常量表达式。 它选择所有文本（包括以 <strong>#</strong> 开头的其他预处理器指令），直到其关联的 #elif、#else 或 #endif。</p>
<p>如果 constant-expression 的所有匹配项都为 false，或者 #elif 指令未出现，则预处理器将选择 #else 子句后面的文本块。 如果没有 #else 子句，并且 #if 块中的 constant-expression 的所有实例都为 false，则不选择文本块。</p>
<p>constant-expression 是具有下列其他限制的整数常量表达式：</p>
<ul>
<li>表达式必须具有整型，并且只能包含整数常量、字符常量和 defined 运算符。</li>
<li>表达式不能使用 <strong><code>sizeof</code></strong> 或 type-cast 运算符。</li>
<li>目标环境无法表示整数的所有范围。</li>
<li>转换以与类型 <strong><code>long</code></strong> 相同的方式表示类型 **<code>int</code>**，并以与类型 <strong><code>unsigned long</code></strong> 相同的方式表示类型 **<code>unsigned int</code>**。</li>
<li>转换器可以将字符常量转换为与目标环境的集不同的代码值集。 若要确定目标环境的属性，请使用为该环境生成的应用程序来检查 LIMITS.H 宏的值。</li>
<li>该表达式不得查询环境，并且必须不受与目标计算机上的实现详细信息的影响。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CREDIT)</span></span><br><span class="line">    <span class="built_in">credit</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(DEBIT)</span></span><br><span class="line">    <span class="built_in">debit</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printerror</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> DLEVEL &gt; 5</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SIGNAL  1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> STACKUSE == 1</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> STACK   200</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> STACK   100</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SIGNAL  0</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> STACKUSE == 1</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> STACK   100</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> STACK   50</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DLEVEL == 0</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STACK 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DLEVEL == 1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STACK 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DLEVEL &gt; 5</span></span><br><span class="line">    <span class="built_in">display</span>( debugptr );</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STACK 200</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>具体请看<a href="https://learn.microsoft.com/zh-cn/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=msvc-170">#if、#elif、#else 和 #endif 指令 (C&#x2F;C++) | Microsoft Learn</a></p>
<h2 id="C-中的typename和class的区别"><a href="#C-中的typename和class的区别" class="headerlink" title="C++中的typename和class的区别"></a>C++中的<code>typename</code>和<code>class</code>的区别</h2><p>在 C++ Template 中很多地方都用到了 typename 与 class 这两个关键字，而且好像可以替换，是不是这两个关键字完全一样呢?</p>
<p>相信学习 C++ 的人对 class 这个关键字都非常明白，class 用于定义类，在模板引入 c++ 后，最初定义模板的方法为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;......</span><br></pre></td></tr></table></figure>

<p>这里 class 关键字表明T是一个类型，后来为了避免 class 在这两个地方的使用可能给人带来混淆，所以引入了 typename 这个关键字，它的作用同 class 一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;......</span><br></pre></td></tr></table></figure>

<p>在模板定义语法中关键字 class 与 typename 的作用完全一样。</p>
<p>typename 难道仅仅在模板定义中起作用吗？其实不是这样，typename 另外一个作用为：**使用嵌套依赖类型(nested depended name)**，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span>：</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> LengthType;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyMethod</span><span class="params">( T myarr )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> T::LengthType LengthType; </span><br><span class="line">    LengthType length = myarr.GetLength; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候 typename 的作用就是告诉 c++ 编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有 typename，编译器没有任何办法知道 T::LengthType 是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。</p>
<h2 id="C-中的void-怎么用"><a href="#C-中的void-怎么用" class="headerlink" title="C++中的void*怎么用"></a>C++中的<code>void*</code>怎么用</h2><p>首先<code>void*</code>中的void代表一个任意的数据类型，”星号”代表一个指针，所以其就是一个任意数据类型的指针。</p>
<blockquote>
<p>对于指定数据类型的指针如<code>int* ，double*</code>等，他们的sizeof都是4个字节，因为都是一个指针，只是指针指向的数据类型不一致。</p>
</blockquote>
<p><strong>当函数传参时不确定数据类型时或者支持多种数据类型传递时。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">(<span class="type">int</span> type,<span class="type">void</span>* pArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span>* d = (<span class="type">double</span>*)pArgs;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span>* i = (<span class="type">int</span>*)pArgs;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数返回值不需要考虑类型，只关心返回的大小。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>

<p>代码使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span>* b = <span class="literal">nullptr</span>;</span><br><span class="line">b = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br></pre></td></tr></table></figure>

<p>可以看到<code>malloc</code>返回值类型为<code>void*</code>，其只返回分配内存的大小，不关心分配后的内存你是使用int还是double类型进行划分.</p>
<blockquote>
<p>注意：函数外部在接收到void*格式的返回值时，需要强转为自己的数据类型才能使用。</p>
</blockquote>
<p><strong>当void*作为函数的参数类型或者返回值类型时，说明该函数可以接收或者返回任意类型的指针。</strong></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* _say(<span class="type">void</span>* pArgs) &#123;</span><br><span class="line">    <span class="keyword">return</span> pArgs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> _a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">10.8</span>;</span><br><span class="line">    <span class="type">int</span>* _pi = &amp;_a;</span><br><span class="line">    <span class="type">float</span>* pf = &amp;f;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *(<span class="type">int</span>*)_say(_pi) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *(<span class="type">float</span>*)_say(pf) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10.8</span></span><br></pre></td></tr></table></figure>

<p>代码中可以看出参数<code>void* pArgs</code>可以使用任意类型的实参，返回值也可以返回任意类型的指针，但是最终需要转换为具体类型才能使用。</p>
<p><code>void*</code>在C++中的作用其实就是为了实现<strong>泛型编程</strong>，和Java中使用Object来表示是一样的，所以又称为通用指针和泛指针，不过<strong>C++中大部分情况下会使用模板编程来实现泛型</strong>。</p>
<h2 id="在项目中用doxygen写项目注释"><a href="#在项目中用doxygen写项目注释" class="headerlink" title="在项目中用doxygen写项目注释"></a>在项目中用doxygen写项目注释</h2><p><strong>Doxygen语法简介</strong></p>
<p>所谓<code>Doxygen</code>语法就是在写程序注视时候按照<code>Doxygen</code>语法规则来写注释。只有按照标准的注释规则来写注释，生成的文档才会非常漂亮，否则乱七八糟的。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>字段名</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>@file</td>
<td>文件名</td>
<td>file [&lt; name &gt;]</td>
</tr>
<tr>
<td>@brief</td>
<td>简介</td>
<td>brief { brief description }</td>
</tr>
<tr>
<td>@author</td>
<td>作者</td>
<td>author { list of authors }</td>
</tr>
<tr>
<td>@mainpage</td>
<td>主页信息</td>
<td>mainpage [(title)]</td>
</tr>
<tr>
<td>@date</td>
<td>年-月-日</td>
<td>date { date description }</td>
</tr>
<tr>
<td>@author</td>
<td>版本号</td>
<td>version { version number }</td>
</tr>
<tr>
<td>@copyright</td>
<td>版权</td>
<td>copyright { copyright description }</td>
</tr>
<tr>
<td>@param</td>
<td>参数</td>
<td>param [(dir)] &lt; parameter-name&gt; { parameter description }</td>
</tr>
<tr>
<td>@return</td>
<td>返回</td>
<td>return { description of the return value }</td>
</tr>
<tr>
<td>@retval</td>
<td>返回值</td>
<td>retval { description }</td>
</tr>
<tr>
<td>@bug</td>
<td>漏洞</td>
<td>bug { bug description }</td>
</tr>
<tr>
<td>@details</td>
<td>细节</td>
<td>details { detailed description }</td>
</tr>
<tr>
<td>@pre</td>
<td>前提条件</td>
<td>pre { description of the precondition }</td>
</tr>
<tr>
<td>@see</td>
<td>参考</td>
<td>see { references }</td>
</tr>
<tr>
<td>@link</td>
<td>连接(与@see类库，{@link <a href="https://link.zhihu.com/?target=http://www.google.com">http://www.google.com</a>})</td>
<td>link &lt; link-object&gt;</td>
</tr>
<tr>
<td>@throw</td>
<td>异常描述</td>
<td>throw &lt; exception-object&gt; { exception description }</td>
</tr>
<tr>
<td>@todo</td>
<td>待处理</td>
<td>todo { paragraph describing what is to be done }</td>
</tr>
<tr>
<td>@warning</td>
<td>警告信息</td>
<td>warning { warning message }</td>
</tr>
<tr>
<td>@deprecated</td>
<td>弃用说明。可用于描述替代方案，预期寿命等</td>
<td>deprecated { description }</td>
</tr>
<tr>
<td>@example</td>
<td>弃用说明。可用于描述替代方案，预期寿命等</td>
<td>deprecated { description }</td>
</tr>
</tbody></table>
<p><strong>文件注释</strong></p>
<p>一般放在文件开头</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @file 文件名</span><br><span class="line"> * @brief 简介</span><br><span class="line"> * @details 细节</span><br><span class="line"> * @author 作者</span><br><span class="line"> * @version 版本号</span><br><span class="line"> * @date 年-月-日</span><br><span class="line"> * @copyright 版权</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p><strong>函数注释</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * @brief 函数描述</span><br><span class="line">  * @param 参数描述</span><br><span class="line">  * @return 返回描述</span><br><span class="line">  * @retval 返回值描述</span><br><span class="line">  */</span><br></pre></td></tr></table></figure>

<p>细节请看<a href="https://zhuanlan.zhihu.com/p/510925324">干货|教你使用Doxygen制作漂亮的程序文档 - 知乎 (zhihu.com)</a></p>
<h2 id="C-中的this和-this的作用和区别"><a href="#C-中的this和-this的作用和区别" class="headerlink" title="C++中的this和*this的作用和区别"></a>C++中的<code>this</code>和<code>*this</code>的作用和区别</h2><p><code>return *this</code>返回的是当前对象的克隆或者本身（若返回类型为A， 则是克隆， 若返回类型为A&amp;， 则是本身 ）。<code>return this</code>返回当前对象的地址（指向当前对象的指针）。</p>
<p>具体请见<a href="https://blog.csdn.net/u011663005/article/details/106151786">C++中this与*this的区别_北海的星辰大海的博客-CSDN博客</a></p>
<h2 id="C-中的initializer-list类型的简单使用"><a href="#C-中的initializer-list类型的简单使用" class="headerlink" title="C++中的initializer_list类型的简单使用"></a>C++中的<code>initializer_list</code>类型的简单使用</h2><p><strong>initializer_list</strong>是C++11提供的新数据类型，和<code>vector</code>一样，<code>initializer_list</code>也是一种模板类型。可以使用<code>.begin(), .end()</code> 等方法。</p>
<p>因为C++11扩大了初始化列表的适用范围，使其可用于所有内置类型和用户定义的类型。使用初始化列表时，可添加&#x3D;等于号，也可不添加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  a=&#123;<span class="number">0</span>&#125; ; </span><br><span class="line"><span class="type">int</span>  b&#123;<span class="number">0</span>&#125; ;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125; ;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; ;</span><br></pre></td></tr></table></figure>

<p>由此可见，<code>initializer_list</code> 还有一种用法是在构造函数或者其他函数中作为参数输入。能够简化一些操作。两个小例子：</p>
<p>第一个例子是在类中的构造函数中接收初始化列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyNumber</span>(<span class="type">const</span> std::initializer_list&lt;<span class="type">int</span>&gt; &amp;v) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> itm : v) &#123;</span><br><span class="line">            mVec.<span class="built_in">push_back</span>(itm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> itm : mVec) &#123;</span><br><span class="line">        std::cout &lt;&lt; itm &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; mVec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyNumber m = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    m.<span class="built_in">print</span>();  <span class="comment">// 1 2 3 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个例子是在普通函数中接受初始化列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(initializer_list&lt;<span class="type">double</span>&gt; il)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">average</span><span class="params">(<span class="type">const</span> initializer_list&lt;<span class="type">double</span>&gt; &amp;ril)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(initializer_list&lt;<span class="type">double</span>&gt; il)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> tmp : il) sum += tmp;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">average</span><span class="params">(<span class="type">const</span> initializer_list&lt;<span class="type">double</span>&gt; &amp;ril)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ril.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp : ril) sum += tmp;</span><br><span class="line">		<span class="keyword">return</span> sum / ril.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum:&quot;</span> &lt;&lt; <span class="built_in">sum</span>(&#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;) &lt;&lt; <span class="string">&quot;, ave:&quot;</span> &lt;&lt; <span class="built_in">average</span>(&#123; <span class="number">2.0</span>, <span class="number">3</span>, <span class="number">4</span> &#125;) &lt;&lt; endl;</span><br><span class="line">	initializer_list&lt;<span class="type">double</span>&gt; dl = &#123; <span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">3.5</span>, <span class="number">4.5</span>, <span class="number">5.5</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum:&quot;</span> &lt;&lt; <span class="built_in">sum</span>(dl) &lt;&lt; <span class="string">&quot;, ave:&quot;</span> &lt;&lt; <span class="built_in">average</span>(dl) &lt;&lt; endl;</span><br><span class="line">	dl = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum:&quot;</span> &lt;&lt; <span class="built_in">sum</span>(dl) &lt;&lt; <span class="string">&quot;, ave:&quot;</span> &lt;&lt; <span class="built_in">average</span>(dl) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-运算符优先级"><a href="#C-运算符优先级" class="headerlink" title="C++运算符优先级"></a>C++运算符优先级</h2><p>C++运算符优先级，是描述在计算机运算计算表达式时执行运算的先后顺序。 先执行具有较高优先级的运算，然后执行较低优先级的运算。 例如，我们常说的先执行相乘和除，再执行加减运算。</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>结合性</th>
<th>运算符</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>左结合</td>
<td>() [] -&gt; .</td>
<td>圆括号 下标运算符 指向结构体成员运算符 结构体成员运算符</td>
</tr>
<tr>
<td>2</td>
<td>右结合</td>
<td>! ~ ++ – + - (类型) * &amp; sizeof</td>
<td>逻辑非运算符 按位取反运算符 前缀增量运算符 前缀减量运算符 正号运算符 负号运算符 类型转换运算符 指针运算符 地址运算符 长度运算符</td>
</tr>
<tr>
<td>3</td>
<td>左结合</td>
<td>* &#x2F; %</td>
<td>乘法运算符 除法运算符 取余运算符</td>
</tr>
<tr>
<td>4</td>
<td>左结合</td>
<td>+ -</td>
<td>加法运算符 减法运算符</td>
</tr>
<tr>
<td>5</td>
<td>左结合</td>
<td>&lt;&lt; &gt;&gt;</td>
<td>左移运算符 右移运算符</td>
</tr>
<tr>
<td>6</td>
<td>左结合</td>
<td>&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td>
<td>关系运算符</td>
</tr>
<tr>
<td>7</td>
<td>左结合</td>
<td>&#x3D;&#x3D; !&#x3D;</td>
<td>等于运算符 不等于运算符</td>
</tr>
<tr>
<td>8</td>
<td>左结合</td>
<td>&amp;</td>
<td>按位与运算符</td>
</tr>
<tr>
<td>9</td>
<td>左结合</td>
<td>^</td>
<td>按位异或运算符</td>
</tr>
<tr>
<td>10</td>
<td>结合性</td>
<td>|</td>
<td>按位或运算符</td>
</tr>
<tr>
<td>11</td>
<td>左结合</td>
<td>&amp;&amp;</td>
<td>逻辑与运算符</td>
</tr>
<tr>
<td>12</td>
<td>左结合</td>
<td>||</td>
<td>逻辑或运算符</td>
</tr>
<tr>
<td>13</td>
<td>右结合</td>
<td>? :</td>
<td>条件运算符</td>
</tr>
<tr>
<td>14</td>
<td>右结合</td>
<td>&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D;</td>
<td>赋值运算符</td>
</tr>
<tr>
<td>15</td>
<td>左结合</td>
<td>,</td>
<td>逗号运算符</td>
</tr>
</tbody></table>
<p> 细节请看<a href="https://www.cnblogs.com/shangdawei/p/3883702.html">C++ 运算符优先级列表 - IAmAProgrammer - 博客园 (cnblogs.com)</a></p>
<h2 id="C-中for循环的几种用法"><a href="#C-中for循环的几种用法" class="headerlink" title="C++中for循环的几种用法"></a>C++中<code>for</code>循环的几种用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span> **)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">list</span><span class="params">(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下标法 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout&lt;&lt;list[i]; <span class="comment">//or list.at(i)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 迭代器 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = list.<span class="built_in">begin</span>(); iter != list.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout&lt;&lt;*iter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* STL函数 */</span></span><br><span class="line">    for_each(list.<span class="built_in">begin</span>(), list.<span class="built_in">end</span>(), [](<span class="type">int</span> item)&#123; cout&lt;&lt;item; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C++11新增加 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> each : list) &#123;</span><br><span class="line">        cout&lt;&lt;each;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详情请见<a href="https://cloud.tencent.com/developer/article/1463130">C++ for循环的几种用法-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h2 id="提问IKOS关于AR的问题"><a href="#提问IKOS关于AR的问题" class="headerlink" title="提问IKOS关于AR的问题"></a>提问IKOS关于AR的问题</h2><blockquote>
<p>Hi, everyone! do you have some syntactic details, or documentation, about your own design of the abstract representation language (AR)? When I read the source code, I find that there is a lot designed in it and it is not intuitive enough. Thank you guys! Thank you for doing the work for the program analysis and open-sourcing the results so that I have the opportunity to learn from it!</p>
</blockquote>
<blockquote>
<p>Unfortunately, AR is pretty loosely documented.<br>In a way, it is pretty similar to the LLVM language: <a href="https://llvm.org/docs/LangRef.html">https://llvm.org/docs/LangRef.html</a><br>Each instruction is pretty much translated 1:1 into AR.<br>You can find the implementation of the translation in <a href="https://github.com/NASA-SW-VnV/ikos/blob/master/frontend/llvm/src/import/function.cpp#L305">https://github.com/NASA-SW-VnV/ikos/blob/master/frontend/llvm/src/import/function.cpp#L305</a><br>The major differences are:</p>
<ul>
<li>AR integer types are either signed or unsigned. LLVM integers do not have a signedness.</li>
<li>AR has a concept of local variables. LLVM has a<a href="https://llvm.org/docs/LangRef.html#alloca-instruction"> <code>alloca</code> instruction</a> that allocates memory on the stack (effectively a local variable).</li>
<li>AR has names for variables, LLVM doesn’t (names are in the debugging information, which uses a different format)</li>
<li>LLVM phi nodes and branching are translated into <code>ar::Comparison</code> statement within the control flow graph. Basically, <code>ar::Comparison</code> is an assert. To translate a <code>if(cond) &#123; x =1 &#125; else &#123; x = 2 &#125;</code> you would have 2 basic blocks, one with <code>Comparison(cond, NE, 0)</code> and one with <code>Comparison(cond, EQ, 0)</code>.</li>
</ul>
</blockquote>
<h2 id="LLVM-IR中的bitcast指令用法"><a href="#LLVM-IR中的bitcast指令用法" class="headerlink" title="LLVM IR中的bitcast指令用法"></a>LLVM IR中的bitcast指令用法</h2><p>在 LLVM IR 中，<code>bitcast</code> 是一条指令，用于将一个值按照指定的类型进行位级别的转换，而不改变其内部表示。</p>
<p><code>bitcast</code> 指令的语法如下：</p>
<figure class="highlight llvm"><figcaption><span>IR</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="variable">%result</span> <span class="operator">=</span> <span class="keyword">bitcast</span> &lt;source_type&gt; &lt;value&gt; <span class="keyword">to</span> &lt;destination_type&gt;</span><br></pre></td></tr></table></figure>

<p>例如，下面的 LLVM IR 代码演示了将一个整数转换为浮点数的示例：</p>
<figure class="highlight llvm"><figcaption><span>IR</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="variable">%value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%ptr</span>	<span class="comment">;从指针%ptr加载一个整数值</span></span><br><span class="line"><span class="variable">%float_value</span> <span class="operator">=</span> <span class="keyword">bitcast</span> <span class="type">i32</span> <span class="variable">%int_value</span> <span class="keyword">to</span> float	<span class="comment">;将整数值转换为浮点数</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，首先使用<code>load</code>指令从指针 <code>%ptr </code>加载一个整数值，并将其保存在 <code>%int_value</code> 变量中。然后，使用 <code>bitcast </code>指令将 <code>%int_value </code>的内部表示按照浮点数类型进行转换，并将结果保存在 <code>%float_value</code> 变量中。</p>
<p>需要注意的是，bitcast 指令只是对内部表示进行位级别的转换，并不改变值的语义。因此，在使用 <code>bitcast</code> 指令时，需要确保源类型和目标类型具有相同的大小和对齐方式，以避免不确定的行为。</p>
<p>此外，<code>bitcast </code>指令还可以用于指针类型的转换，例如将指向一个类型的指针转换为指向另一个类型的指针。这在某些情况下可以用于类型的转换和指针的重新解释。</p>
<p>详情请看<a href="https://wenku.csdn.net/answer/4jwo82yi7n">LLVM IR bitcast指令用法 - CSDN文库</a></p>
<h2 id="vim的用法"><a href="#vim的用法" class="headerlink" title="vim的用法"></a>vim的用法</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zou@zou-VirtualBox:~/Downloads/FortranProgram/chap03$ vim -<span class="built_in">help</span></span><br><span class="line">VIM - Vi IMproved 8.1 (2018 May 18, compiled Aug 18 2023 03:41:54)</span><br><span class="line"></span><br><span class="line">Usage: vim [arguments] [file ..]       edit specified file(s)</span><br><span class="line">   or: vim [arguments] -               <span class="built_in">read</span> text from stdin</span><br><span class="line">   or: vim [arguments] -t tag          edit file <span class="built_in">where</span> tag is defined</span><br><span class="line">   or: vim [arguments] -q [errorfile]  edit file with first error</span><br><span class="line"></span><br><span class="line">Arguments:</span><br><span class="line">   --			Only file names after this</span><br><span class="line">   -v			Vi mode (like <span class="string">&quot;vi&quot;</span>)</span><br><span class="line">   -e			Ex mode (like <span class="string">&quot;ex&quot;</span>)</span><br><span class="line">   -E			Improved Ex mode</span><br><span class="line">   -s			Silent (batch) mode (only <span class="keyword">for</span> <span class="string">&quot;ex&quot;</span>)</span><br><span class="line">   -d			Diff mode (like <span class="string">&quot;vimdiff&quot;</span>)</span><br><span class="line">   -y			Easy mode (like <span class="string">&quot;evim&quot;</span>, modeless)</span><br><span class="line">   -R			Readonly mode (like <span class="string">&quot;view&quot;</span>)</span><br><span class="line">   -Z			Restricted mode (like <span class="string">&quot;rvim&quot;</span>)</span><br><span class="line">   -m			Modifications (writing files) not allowed</span><br><span class="line">   -M			Modifications <span class="keyword">in</span> text not allowed</span><br><span class="line">   -b			Binary mode</span><br><span class="line">   -l			Lisp mode</span><br><span class="line">   -C			Compatible with Vi: <span class="string">&#x27;compatible&#x27;</span></span><br><span class="line">   -N			Not fully Vi compatible: <span class="string">&#x27;nocompatible&#x27;</span></span><br><span class="line">   -V[N][fname]		Be verbose [level N] [<span class="built_in">log</span> messages to fname]</span><br><span class="line">   -D			Debugging mode</span><br><span class="line">   -n			No swap file, use memory only</span><br><span class="line">   -r			List swap files and <span class="built_in">exit</span></span><br><span class="line">   -r (with file name)	Recover crashed session</span><br><span class="line">   -L			Same as -r</span><br><span class="line">   -A			Start <span class="keyword">in</span> Arabic mode</span><br><span class="line">   -H			Start <span class="keyword">in</span> Hebrew mode</span><br><span class="line">   -T &lt;terminal&gt;	Set terminal <span class="built_in">type</span> to &lt;terminal&gt;</span><br><span class="line">   --not-a-term		Skip warning <span class="keyword">for</span> input/output not being a terminal</span><br><span class="line">   --ttyfail		Exit <span class="keyword">if</span> input or output is not a terminal</span><br><span class="line">   -u &lt;vimrc&gt;		Use &lt;vimrc&gt; instead of any .vimrc</span><br><span class="line">   --noplugin		Don<span class="string">&#x27;t load plugin scripts</span></span><br><span class="line"><span class="string">   -p[N]		Open N tab pages (default: one for each file)</span></span><br><span class="line"><span class="string">   -o[N]		Open N windows (default: one for each file)</span></span><br><span class="line"><span class="string">   -O[N]		Like -o but split vertically</span></span><br><span class="line"><span class="string">   +			Start at end of file</span></span><br><span class="line"><span class="string">   +&lt;lnum&gt;		Start at line &lt;lnum&gt;</span></span><br><span class="line"><span class="string">   --cmd &lt;command&gt;	Execute &lt;command&gt; before loading any vimrc file</span></span><br><span class="line"><span class="string">   -c &lt;command&gt;		Execute &lt;command&gt; after loading the first file</span></span><br><span class="line"><span class="string">   -S &lt;session&gt;		Source file &lt;session&gt; after loading the first file</span></span><br><span class="line"><span class="string">   -s &lt;scriptin&gt;	Read Normal mode commands from file &lt;scriptin&gt;</span></span><br><span class="line"><span class="string">   -w &lt;scriptout&gt;	Append all typed commands to file &lt;scriptout&gt;</span></span><br><span class="line"><span class="string">   -W &lt;scriptout&gt;	Write all typed commands to file &lt;scriptout&gt;</span></span><br><span class="line"><span class="string">   -x			Edit encrypted files</span></span><br><span class="line"><span class="string">   --startuptime &lt;file&gt;	Write startup timing messages to &lt;file&gt;</span></span><br><span class="line"><span class="string">   -i &lt;viminfo&gt;		Use &lt;viminfo&gt; instead of .viminfo</span></span><br><span class="line"><span class="string">   --clean		&#x27;</span>nocompatible<span class="string">&#x27;, Vim defaults, no plugins, no viminfo</span></span><br><span class="line"><span class="string">   -h  or  --help	Print Help (this message) and exit</span></span><br><span class="line"><span class="string">   --version		Print version information and exit</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h2 id="ubuntu上的一些常见指令"><a href="#ubuntu上的一些常见指令" class="headerlink" title="ubuntu上的一些常见指令"></a>ubuntu上的一些常见指令</h2><ul>
<li><strong>pwd（present working directory）</strong></li>
</ul>
<p>显示当前的工作目录&#x2F;路径。</p>
<ul>
<li><strong>cd (change directory)</strong></li>
</ul>
<p>改变目录，用于输入需要前往的路径&#x2F;目录。</p>
<p>有一些特殊命令也很常用 :</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">前往同一级的另一个目录</span><br><span class="line">cd ../directory name</span><br><span class="line">cd .. 表示进入上层目录</span><br><span class="line">cd ../.. 进入上上层目录，后面还可以加更多。</span><br><span class="line">前往同一级的另一个目录</span><br><span class="line">cd ../directory name</span><br><span class="line">cd -  //表示返回上一次的目录</span><br><span class="line">cd ~  //进入home主目录，即/home/用户名的简写</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ls (list)</strong></li>
</ul>
<p>ls 显示当前目录下的文件（不包括隐藏文件和缓存文件等）；</p>
<p>列出目录下所有文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ls -a </span><br></pre></td></tr></table></figure>

<p>ll , 以列表形式显示当前路径下的所有文件的详细信息（包括隐藏文件和缓存文件等）。</p>
<ul>
<li><strong>mkdir (make directory)</strong></li>
</ul>
<p>创建目录，后面接上directory的名字。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mkdir I_dont_care //创建一个“我不在乎”目录</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>rm (remove)</strong></li>
</ul>
<p>删除文件，后面接上要删除的文件名。如果要删除目录，需要这样写：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">rm -I &lt;目录名&gt;  //这样做会删除指定目录中的所有子目录和包含的文件</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>touch</strong></li>
</ul>
<p>创建任意格式的文件，包括源代码、文本等等，通过后缀来决定。例如，.cpp&#x2F;.cc是c++源代码，而.py是python源代码。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">touch hello_world.cpp  //创建hello_world源代码</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>cp (copy)</strong></li>
</ul>
<p>复制命令。通用格式为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cp -? &lt;源文件/源目录&gt; &lt;目的目录&gt;  //第一个&quot;-?&quot;表示参数，出发地在左，目的地在右</span><br></pre></td></tr></table></figure>

<p>特别的，如果想把某目录下所有文件都复制，可以使用参数-r</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cp -r cangjingkong/ xuexi    //将canjingkong目录下的所有资源都复制到xuexi目录中</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>mv (move)</strong></li>
</ul>
<p>移动+重命名命令。格式类似于cp命令</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mv -? &lt;源文件/源目录&gt; &lt;目的目录&gt; //第一个&quot;-?&quot;表示参数，出发地在左，目的地在右</span><br></pre></td></tr></table></figure>

<p>以移动txt文件为例 可以分为以下三种情况：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mv a.txt b.txt                 //出发地和目的地是同一路径，名称从a.txt变为b.txt，那仅仅是重命名</span><br><span class="line">mv ~/目录1/a.txt ~/目录2       //出发地和目的地是不同路径，没有指定新的名称，那仅仅是移动</span><br><span class="line">mv ~/目录1/a.txt ~/目录2/b.txt //出发地和目的地是不同路径，指定了新的名称，那就是移动+重命名</span><br></pre></td></tr></table></figure>

<p>常用的例子有，</p>
<p>移动目录到另一目录中</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mv 目录1/ 目录2</span><br></pre></td></tr></table></figure>

<p>将某目录下所有的文件和目录都移动到当前目录下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mv ~/videos/p_hub .</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>gedit</strong></li>
</ul>
<p>在桌面临时新建一个text editor（文本编辑器）显示文件内的文本，并且支持修改。按ctrl+c退出文件显示。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">gedit &lt;文件名&gt;</span><br></pre></td></tr></table></figure>

<p>例如，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gedit single_ladies_contacts.csv</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>cat</strong></li>
</ul>
<p>在终端打印出文本内容。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cat &lt;文件名&gt;  //在terminal内部打印，和gedit相区分</span><br></pre></td></tr></table></figure>

<p>具体请看链接<a href="https://zhuanlan.zhihu.com/p/392986700">Ubuntu常用命令 总结整理 - 知乎 (zhihu.com)</a></p>
<h2 id="回归测试是什么"><a href="#回归测试是什么" class="headerlink" title="回归测试是什么"></a>回归测试是什么</h2><p>回归测试（Regression Testing）是软件测试的一种类型，用于验证在进行软件修改或更新后，旧的功能仍然能够按照预期的方式正常工作，同时新功能或修复的问题也没有引入新的错误。回归测试旨在确保软件在经过修改后，仍然保持了与之前版本相同的稳定性和兼容性。</p>
<p>以下是回归测试的一些关键特点和解释：</p>
<ol>
<li><p><strong>目的</strong>：回归测试的主要目标是检测新的代码更改是否对现有功能产生了负面影响。它有助于确保已有的软件功能没有退化或损害，并且新功能、改进或修复的问题是有效的。</p>
</li>
<li><p><strong>自动化</strong>：由于回归测试需要频繁地运行，通常采用自动化测试工具来执行。这些工具能够自动运行一系列测试用例，并比较测试结果与预期结果，以检测潜在的问题。</p>
</li>
<li><p><strong>选择测试用例</strong>：回归测试通常不需要覆盖所有可能的测试场景，而是集中在关键的测试用例上，以验证最重要的功能是否正常工作。选择测试用例的方法可以基于风险分析、业务需求或之前的缺陷历史。</p>
</li>
<li><p><strong>持续集成</strong>：在持续集成（Continuous Integration）工作流程中，回归测试是一个关键的环节。每当代码库中有新的提交时，自动化回归测试将运行，以确保新的更改没有破坏现有的代码。</p>
</li>
<li><p><strong>快速反馈</strong>：回归测试的目标之一是提供快速的反馈，以便开发团队能够尽早修复潜在的问题。如果回归测试发现了错误，开发人员可以尽快进行修复，而不是等到问题进入生产环境。</p>
</li>
<li><p><strong>版本控制</strong>：回归测试通常与版本控制系统集成，以确保每个版本的软件都经过了适当的回归测试。这有助于跟踪软件的演化和改进。</p>
</li>
</ol>
<p>总之，回归测试是一种关键的软件测试方法，旨在确保软件在不断进行修改和更新的过程中仍然保持了稳定性和质量。它有助于减少新功能引入的风险，同时维护现有功能的可靠性。</p>
<h2 id="阅读LLVM-IR"><a href="#阅读LLVM-IR" class="headerlink" title="阅读LLVM IR"></a>阅读LLVM IR</h2><p>当你提到LLVM IR语句时，你是在谈论低级虚拟指令集（Low-Level Virtual Instruction Set），它是由LLVM编译器框架使用的中间表示形式。LLVM IR用于表示源代码的中间表示，通常是在编译源代码到目标代码的过程中使用。</p>
<p>以下是一些常见的LLVM IR语句以及它们的解释：</p>
<ol>
<li><p><strong>声明变量</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%x = alloca i32</span><br></pre></td></tr></table></figure>
<p>这个语句创建一个名为<code>%x</code>的整数类型（<code>i32</code>）的变量。</p>
</li>
<li><p><strong>赋值</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">store i32 42, i32* %x</span><br></pre></td></tr></table></figure>
<p>这个语句将整数值42存储到变量<code>%x</code>中。</p>
</li>
<li><p><strong>加载变量</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%val = load i32, i32* %x</span><br></pre></td></tr></table></figure>
<p>这个语句从变量<code>%x</code>中加载整数值，并将其存储到<code>%val</code>中。</p>
</li>
<li><p><strong>条件分支</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">br i1 %condition, label %trueLabel, label %falseLabel</span><br></pre></td></tr></table></figure>
<p>这个语句根据条件<code>%condition</code>的值，选择跳转到<code>%trueLabel</code>或<code>%falseLabel</code>。</p>
</li>
<li><p><strong>循环</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">br label %loopHeader</span><br><span class="line">; ...</span><br><span class="line">%loopHeader:</span><br><span class="line">; 循环体</span><br><span class="line">br i1 %loopCondition, label %loopHeader, label %afterLoop</span><br><span class="line">%afterLoop:</span><br></pre></td></tr></table></figure>
<p>这个语句表示一个简单的循环结构，根据<code>%loopCondition</code>的值反复执行循环体，直到条件不满足，然后跳转到<code>%afterLoop</code>。</p>
</li>
<li><p><strong>函数调用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%result = call i32 @myFunction(i32 %arg1, i32 %arg2)</span><br></pre></td></tr></table></figure>
<p>这个语句调用名为<code>myFunction</code>的函数，传递两个整数参数<code>%arg1</code>和<code>%arg2</code>，并将返回值存储在<code>%result</code>中。</p>
</li>
</ol>
<p>这些示例涵盖了LLVM IR中的一些基本语句。LLVM IR是一种灵活且强大的中间表示，用于优化和生成目标代码。不同的编译器和工具可以使用LLVM IR来执行各种优化和分析，以改进程序的性能和可靠性。</p>
<h2 id="由Flang转换的Fortran程序"><a href="#由Flang转换的Fortran程序" class="headerlink" title="由Flang转换的Fortran程序"></a>由Flang转换的Fortran程序</h2><p>原来的Fortran程序：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> main</span><br><span class="line">	<span class="keyword">integer</span> a</span><br><span class="line">	<span class="keyword">integer</span> b</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> main</span><br></pre></td></tr></table></figure>

<p>转换后的LLVM IR是这样的：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; this block is definition that is related to sourcefile</span></span><br><span class="line"><span class="comment">; ModuleID = &#x27;/tmp/defineVariabl-775d8e.ll&#x27;</span></span><br><span class="line">source_filename <span class="operator">=</span> <span class="string">&quot;/tmp/defineVariabl-775d8e.ll&quot;</span></span><br><span class="line"><span class="keyword">target</span> <span class="keyword">datalayout</span> <span class="operator">=</span> <span class="string">&quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line"><span class="keyword">target</span> <span class="keyword">triple</span> <span class="operator">=</span> <span class="string">&quot;x86_64-unknown-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title">@.C310_MAIN_</span> <span class="operator">=</span> <span class="keyword">internal</span> <span class="keyword">constant</span> <span class="type">i64</span> <span class="number">0</span></span><br><span class="line"><span class="title">@.C311_MAIN_</span> <span class="operator">=</span> <span class="keyword">internal</span> <span class="keyword">constant</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line"><span class="title">@.C309_MAIN_</span> <span class="operator">=</span> <span class="keyword">internal</span> <span class="keyword">constant</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@MAIN_</span>() <span class="title">!dbg</span> <span class="title">!5</span> &#123;</span><br><span class="line">L.entry:</span><br><span class="line">  <span class="variable">%a_329</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="variable">%0</span> <span class="operator">=</span> <span class="keyword">bitcast</span> <span class="type">i32</span>* <span class="title">@.C309_MAIN_</span> <span class="keyword">to</span> <span class="type">i8</span>*</span><br><span class="line">  <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">bitcast</span> void (...)* <span class="title">@fort_init</span> <span class="keyword">to</span> void (<span class="type">i8</span>*<span class="punctuation">,</span> ...)*</span><br><span class="line">  <span class="keyword">call</span> void (<span class="type">i8</span>*<span class="punctuation">,</span> ...) <span class="variable">%1</span>(<span class="type">i8</span>* <span class="variable">%0</span>)</span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%L.LB1_335</span></span><br><span class="line"></span><br><span class="line">L.LB<span class="number">1</span>_<span class="number">335</span>:                                        <span class="comment">; preds = %L.entry</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%a_329</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span><span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!8</span></span><br><span class="line">  <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">bitcast</span> <span class="type">i32</span>* <span class="title">@.C309_MAIN_</span> <span class="keyword">to</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!9</span></span><br><span class="line">  <span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">bitcast</span> void (...)* <span class="title">@f90_stop08a</span> <span class="keyword">to</span> void (<span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i64</span><span class="punctuation">,</span> ...)*<span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!9</span></span><br><span class="line">  <span class="keyword">call</span> void (<span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i64</span><span class="punctuation">,</span> ...) <span class="variable">%3</span>(<span class="type">i8</span>* <span class="variable">%2</span><span class="punctuation">,</span> <span class="type">i8</span>* <span class="keyword">null</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span>)<span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!9</span></span><br><span class="line">  <span class="keyword">ret</span> void<span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@f90_stop08a</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@fort_init</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="title">!llvm.module.flags</span> <span class="operator">=</span> !&#123;<span class="title">!0</span><span class="punctuation">,</span> <span class="title">!1</span>&#125;</span><br><span class="line"><span class="title">!llvm.dbg.cu</span> <span class="operator">=</span> !&#123;<span class="title">!2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!0</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> !<span class="string">&quot;Dwarf Version&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">4</span>&#125;</span><br><span class="line"><span class="title">!1</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> !<span class="string">&quot;Debug Info Version&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">3</span>&#125;</span><br><span class="line"><span class="title">!2</span> <span class="operator">=</span> distinct <span class="title">!DICompileUnit</span>(language: DW_LANG_Fortran<span class="number">90</span><span class="punctuation">,</span> file: <span class="title">!3</span><span class="punctuation">,</span> producer: <span class="string">&quot; F90 Flang - 1.5 2017-05-01&quot;</span><span class="punctuation">,</span> isOptimized: <span class="keyword">false</span><span class="punctuation">,</span> flags: <span class="string">&quot;&#x27;+flang -emit-llvm -S defineVariabl.f90 -o defineVariable.ll&#x27;&quot;</span><span class="punctuation">,</span> runtimeVersion: <span class="number">0</span><span class="punctuation">,</span> emissionKind: FullDebug<span class="punctuation">,</span> enums: <span class="title">!4</span><span class="punctuation">,</span> retainedTypes: <span class="title">!4</span><span class="punctuation">,</span> globals: <span class="title">!4</span><span class="punctuation">,</span> imports: <span class="title">!4</span><span class="punctuation">,</span> nameTableKind: None)</span><br><span class="line"><span class="title">!3</span> <span class="operator">=</span> <span class="title">!DIFile</span>(filename: <span class="string">&quot;defineVariabl.f90&quot;</span><span class="punctuation">,</span> directory: <span class="string">&quot;/home/zou/Downloads/FortranProgram/easyBenchmark&quot;</span>)</span><br><span class="line"><span class="title">!4</span> <span class="operator">=</span> !&#123;&#125;</span><br><span class="line"><span class="title">!5</span> <span class="operator">=</span> distinct <span class="title">!DISubprogram</span>(name: <span class="string">&quot;main&quot;</span><span class="punctuation">,</span> scope: <span class="title">!2</span><span class="punctuation">,</span> file: <span class="title">!3</span><span class="punctuation">,</span> line: <span class="number">1</span><span class="punctuation">,</span> <span class="keyword">type</span>: <span class="title">!6</span><span class="punctuation">,</span> scopeLine: <span class="number">1</span><span class="punctuation">,</span> spFlags: DISPFlagDefinition | DISPFlagMainSubprogram<span class="punctuation">,</span> unit: <span class="title">!2</span><span class="punctuation">,</span> retainedNodes: <span class="title">!4</span>)</span><br><span class="line"><span class="title">!6</span> <span class="operator">=</span> <span class="title">!DISubroutineType</span>(<span class="keyword">cc</span>: DW_CC_program<span class="punctuation">,</span> types: <span class="title">!7</span>)</span><br><span class="line"><span class="title">!7</span> <span class="operator">=</span> !&#123;<span class="keyword">null</span>&#125;</span><br><span class="line"><span class="title">!8</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">4</span><span class="punctuation">,</span> column: <span class="number">1</span><span class="punctuation">,</span> scope: <span class="title">!5</span>)</span><br><span class="line"><span class="title">!9</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">5</span><span class="punctuation">,</span> column: <span class="number">1</span><span class="punctuation">,</span> scope: <span class="title">!5</span>)</span><br><span class="line"><span class="title">!10</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">6</span><span class="punctuation">,</span> column: <span class="number">1</span><span class="punctuation">,</span> scope: <span class="title">!5</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@.C310_MAIN_</span> <span class="operator">=</span> <span class="keyword">internal</span> <span class="keyword">constant</span> <span class="type">i64</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这行LLVM IR代码表示一个内部常量的定义，名为@.C310_MAIN_，其类型为i64（64位整数），并且其初始值为0。让我们逐一解释这个代码：</p>
<ul>
<li><p><code>@.C310_MAIN_</code>: 这是一个LLVM IR中的符号名，用作常量的名称。符号名以<code>@</code>开头，通常用于全局变量和常量。</p>
</li>
<li><p><code>internal</code>: 这个关键字表示@.C310_MAIN_是一个内部常量，它的可见性被限制在当前编译单元内。这意味着它不能在其他编译单元中被引用，只能在当前编译单元内使用。</p>
</li>
<li><p><code>constant</code>: 这表明@.C310_MAIN_是一个常量，它的值在编译时就确定了，不能在运行时更改。</p>
</li>
<li><p><code>i64</code>: 这是@.C310_MAIN_的数据类型，表示64位整数。</p>
</li>
<li><p><code>0</code>: 这是@.C310_MAIN_的初始值，表示这个常量的值是0。</p>
</li>
</ul>
<p>这行代码的作用是在LLVM IR中定义一个64位整数常量@.C310_MAIN_，其值为0。在后续的LLVM IR代码中，可以使用@.C310_MAIN_来引用这个常量，就像引用任何其他全局变量或常量一样。这有助于提高代码的可读性和维护性，因为可以使用有意义的名称来代替数字0。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%a_329</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>这行LLVM IR代码表示在当前函数的栈帧上分配存储空间来存储一个32位整数（i32类型），并要求按4字节对齐。让我们逐一解释这个代码：</p>
<ul>
<li><p><code>%a_329</code>: 这是一个局部变量的名称，以<code>%</code>开头，用于在当前函数中引用这个变量。这个变量的名字是<code>a_329</code>。</p>
</li>
<li><p><code>alloca</code>: 这是LLVM IR中的一条指令，用于在当前函数的栈帧上分配内存。它用于创建局部变量的存储空间。</p>
</li>
<li><p><code>i32</code>: 这是要分配的内存块的数据类型，表示32位整数。</p>
</li>
<li><p><code>align 4</code>: 这是对齐要求，表示内存块的起始地址应该是4的倍数。这是一种常见的对齐方式，有助于提高内存访问的效率。</p>
</li>
</ul>
<p>因此，这行代码的作用是在当前函数的栈帧上分配了一块用于存储32位整数的内存空间，并将其命名为<code>%a_329</code>。后续的代码可以使用<code>%a_329</code>来引用这个局部变量，并在其中存储和访问32位整数的值。这是在函数内部定义局部变量的一种方式，用于存储临时数据或计算结果。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%0</span> <span class="operator">=</span> <span class="keyword">bitcast</span> <span class="type">i32</span>* <span class="title">@.C309_MAIN_</span> <span class="keyword">to</span> <span class="type">i8</span>*</span><br></pre></td></tr></table></figure>

<p>这行LLVM IR代码表示了一个位转换（bitcast）操作，将一个指向32位整数（i32<em>）的指针<code>@.C309_MAIN_</code>转换为指向8位整数（i8</em>，也就是字节）的指针。让我们逐一解释这个代码：</p>
<ul>
<li><p><code>%0</code>: 这是一个临时值的名称，以<code>%</code>开头，用于在LLVM IR中引用这个位转换操作的结果。<code>%0</code>通常用于表示临时变量或操作结果。</p>
</li>
<li><p><code>bitcast</code>: 这是LLVM IR中的一条指令，用于执行位转换操作。位转换操作允许将一个数据类型的值解释为另一个数据类型，但不会改变其实际存储内容，只是改变了视图。</p>
</li>
<li><p><code>i32* @.C309_MAIN_</code>: 这表示一个指向32位整数（i32*）的指针，这个指针的名称是<code>@.C309_MAIN_</code>。这个指针通常用于引用某个变量或内存位置。</p>
</li>
<li><p><code>to i8*</code>: 这表示将原始的32位整数指针转换为指向8位整数（i8*，也就是字节）的指针。这种位转换操作通常用于将不同数据类型的数据以字节为单位进行操作。</p>
</li>
</ul>
<p>所以，这行代码的作用是将名为<code>@.C309_MAIN_</code>的32位整数指针转换为指向8位整数（字节）的指针，并将结果存储在<code>%0</code>中，以便后续的LLVM IR代码可以使用<code>%0</code>来引用这个新的字节指针。这种转换通常在处理底层内存操作或数据类型转换时使用。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">bitcast</span> void (...)* <span class="title">@fort_init</span> <span class="keyword">to</span> void (<span class="type">i8</span>*<span class="punctuation">,</span> ...)*</span><br></pre></td></tr></table></figure>

<p>这行LLVM IR代码表示一个位转换（bitcast）操作，将一个函数指针<code>@fort_init</code>，指向接受任意数量参数的函数（void (…)），转换为一个函数指针，指向接受第一个参数为指向8位整数（i8<em>）的指针，其余参数可以是任意数量的参数的函数（void (i8</em>, …)）。让我们逐一解释这个代码：</p>
<ul>
<li><p><code>%1</code>: 这是一个临时值的名称，以<code>%</code>开头，用于在LLVM IR中引用这个位转换操作的结果。<code>%1</code>通常用于表示临时变量或操作结果。</p>
</li>
<li><p><code>bitcast</code>: 这是LLVM IR中的一条指令，用于执行位转换操作。位转换操作允许将一个函数指针的类型转换为另一个函数指针的类型。</p>
</li>
<li><p><code>void (...)* @fort_init</code>: 这表示一个函数指针，<code>@fort_init</code>指向一个接受任意数量参数的函数，返回类型为<code>void</code>。这种函数指针通常用于表示可变参数函数，其中<code>...</code>表示可接受不定数量的参数。</p>
</li>
<li><p><code>to void (i8*, ...)*</code>: 这表示将原始的函数指针<code>@fort_init</code>转换为一个新的函数指针，指向一个接受第一个参数为指向8位整数（i8*）的指针，其余参数可以是任意数量的参数的函数。这种转换通常用于调整函数的参数类型，以便在调用该函数时传递正确类型的参数。</p>
</li>
</ul>
<p>所以，这行代码的作用是将函数指针<code>@fort_init</code>从接受任意数量参数的函数类型转换为接受第一个参数为指向8位整数（i8*）的指针，其余参数可以是任意数量的参数的函数类型，并将结果存储在<code>%1</code>中，以便后续的LLVM IR代码可以使用<code>%1</code>来引用这个新的函数指针。这种转换通常在需要与不同参数类型的函数交互时使用。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> void (<span class="type">i8</span>*<span class="punctuation">,</span> ...) <span class="variable">%1</span>(<span class="type">i8</span>* <span class="variable">%0</span>)</span><br></pre></td></tr></table></figure>

<p>这行LLVM IR代码表示一个函数调用操作。让我们逐一解释这个代码：</p>
<ul>
<li><p><code>call</code>: 这是LLVM IR中用于执行函数调用的指令。</p>
</li>
<li><p><code>void (i8*, ...)* %1</code>: 这部分表示要调用的函数。<code>%1</code>是一个函数指针，它指向一个接受第一个参数为指向8位整数（i8*）的指针，其余参数可以是任意数量的参数的函数。这意味着我们将调用由<code>%1</code>指向的函数。</p>
</li>
<li><p><code>(i8* %0)</code>: 这是传递给函数的参数列表。在这里，我们传递了一个参数，即<code>i8*</code>类型的值，它是之前进行位转换（bitcast）操作时得到的结果，即<code>%0</code>。</p>
</li>
</ul>
<p>所以，这行代码的作用是调用由函数指针<code>%1</code>所指向的函数，传递了一个参数，即<code>%0</code>。这种调用通常用于动态地调用不同类型或不定参数的函数，具体函数的实现由<code>%1</code>所指向的函数决定。这种机制通常在与函数指针或可变参数函数交互时使用。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%a_329</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span><span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!8</span></span><br></pre></td></tr></table></figure>

<p>这是一个LLVM IR语句的示例，让我解释一下：</p>
<ul>
<li><p><code>store i32 1, i32* %a_329</code>：这个语句表示将整数值1存储到指针变量<code>%a_329</code>指向的位置。具体来说，它将整数值1存储到<code>%a_329</code>指向的32位整数（<code>i32</code>）的内存位置。</p>
</li>
<li><p><code>align 4</code>：这是一个对齐（alignment）选项，它指定了存储操作的对齐方式。在这里，数据被4字节对齐，这意味着它将被存储在内存中的地址应该是4的倍数。对齐通常用于优化内存访问。</p>
</li>
<li><p><code>!dbg !8</code>：这是调试信息的一部分，它指向调试元数据。<code>!dbg</code>后面的<code>!8</code>可能是一个引用，它将链接到源代码中的调试信息，以帮助调试器在源代码级别调试程序。</p>
</li>
</ul>
<p>综合起来，这个语句的作用是将整数值1存储到指针变量<code>%a_329</code>指向的内存位置，并要求对齐方式为4字节。调试信息<code>!dbg !8</code>则用于调试和源代码关联。这是编译器生成的一条低级指令，通常在LLVM IR的中间表示中出现，用于在编译过程中管理和操作数据。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">!llvm.module.flags</span> <span class="operator">=</span> !&#123;<span class="title">!0</span><span class="punctuation">,</span> <span class="title">!1</span>&#125;</span><br><span class="line"><span class="title">!llvm.dbg.cu</span> <span class="operator">=</span> !&#123;<span class="title">!2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!0</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> !<span class="string">&quot;Dwarf Version&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">4</span>&#125;</span><br><span class="line"><span class="title">!1</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> !<span class="string">&quot;Debug Info Version&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">3</span>&#125;</span><br><span class="line"><span class="title">!2</span> <span class="operator">=</span> distinct <span class="title">!DICompileUnit</span>(language: DW_LANG_Fortran<span class="number">90</span><span class="punctuation">,</span> file: <span class="title">!3</span><span class="punctuation">,</span> producer: <span class="string">&quot; F90 Flang - 1.5 2017-05-01&quot;</span><span class="punctuation">,</span> isOptimized: <span class="keyword">false</span><span class="punctuation">,</span> flags: <span class="string">&quot;&#x27;+flang -emit-llvm -S defineVariabl.f90 -o defineVariable.ll&#x27;&quot;</span><span class="punctuation">,</span> runtimeVersion: <span class="number">0</span><span class="punctuation">,</span> emissionKind: FullDebug<span class="punctuation">,</span> enums: <span class="title">!4</span><span class="punctuation">,</span> retainedTypes: <span class="title">!4</span><span class="punctuation">,</span> globals: <span class="title">!4</span><span class="punctuation">,</span> imports: <span class="title">!4</span><span class="punctuation">,</span> nameTableKind: None)</span><br><span class="line"><span class="title">!3</span> <span class="operator">=</span> <span class="title">!DIFile</span>(filename: <span class="string">&quot;defineVariabl.f90&quot;</span><span class="punctuation">,</span> directory: <span class="string">&quot;/home/zou/Downloads/FortranProgram/easyBenchmark&quot;</span>)</span><br><span class="line"><span class="title">!4</span> <span class="operator">=</span> !&#123;&#125;</span><br><span class="line"><span class="title">!5</span> <span class="operator">=</span> distinct <span class="title">!DISubprogram</span>(name: <span class="string">&quot;main&quot;</span><span class="punctuation">,</span> scope: <span class="title">!2</span><span class="punctuation">,</span> file: <span class="title">!3</span><span class="punctuation">,</span> line: <span class="number">1</span><span class="punctuation">,</span> <span class="keyword">type</span>: <span class="title">!6</span><span class="punctuation">,</span> scopeLine: <span class="number">1</span><span class="punctuation">,</span> spFlags: DISPFlagDefinition | DISPFlagMainSubprogram<span class="punctuation">,</span> unit: <span class="title">!2</span><span class="punctuation">,</span> retainedNodes: <span class="title">!4</span>)</span><br><span class="line"><span class="title">!6</span> <span class="operator">=</span> <span class="title">!DISubroutineType</span>(<span class="keyword">cc</span>: DW_CC_program<span class="punctuation">,</span> types: <span class="title">!7</span>)</span><br><span class="line"><span class="title">!7</span> <span class="operator">=</span> !&#123;<span class="keyword">null</span>&#125;</span><br><span class="line"><span class="title">!8</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">4</span><span class="punctuation">,</span> column: <span class="number">1</span><span class="punctuation">,</span> scope: <span class="title">!5</span>)</span><br><span class="line"><span class="title">!9</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">5</span><span class="punctuation">,</span> column: <span class="number">1</span><span class="punctuation">,</span> scope: <span class="title">!5</span>)</span><br><span class="line"><span class="title">!10</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">6</span><span class="punctuation">,</span> column: <span class="number">1</span><span class="punctuation">,</span> scope: <span class="title">!5</span>)</span><br></pre></td></tr></table></figure>

<p>这些代码片段看起来是LLVM调试信息的一部分，用于在编译器生成的中间表示代码（LLVM IR）中存储关于源代码的元数据和调试信息。让我解释一下这些代码：</p>
<ol>
<li><p><code>!llvm.module.flags = !&#123;!0, !1&#125;</code>：这行代码包含了模块级别的标志，可能包括有关Dwarf调试信息和调试版本的信息。<code>!0</code>和<code>!1</code>是后面两个标志的引用。</p>
</li>
<li><p><code>!0 = !&#123;i32 2, !&quot;Dwarf Version&quot;, i32 4&#125;</code>：这个标志表示Dwarf调试信息的版本。在这里，Dwarf版本被设置为4。</p>
</li>
<li><p><code>!1 = !&#123;i32 2, !&quot;Debug Info Version&quot;, i32 3&#125;</code>：这个标志表示调试信息的版本。在这里，调试信息版本被设置为3。</p>
</li>
<li><p><code>!2 = distinct !DICompileUnit(...)</code>：这是一个表示编译单元的调试信息，其中包含了有关源代码文件、编译器版本、是否进行了优化等信息。这对于调试非常重要。</p>
</li>
<li><p><code>!3 = !DIFile(...)</code>：这是一个表示源文件的调试信息，其中包含了源文件的名称和目录信息。</p>
</li>
<li><p><code>!4 = !&#123;&#125;</code>：这个标志表示一个空的列表，通常用于一些调试信息的元素，比如枚举、全局变量、导入等等。</p>
</li>
<li><p><code>!5 = distinct !DISubprogram(...)</code>：这个标志表示一个子程序（或函数）的调试信息，包括名称、源文件、行号等信息。在这里，它代表名为”main”的程序入口点。</p>
</li>
<li><p><code>!6 = !DISubroutineType(...)</code>：这个标志表示子程序的类型信息，包括调用约定等信息。在这里，它指示DW_CC_program调用约定，表示这是一个程序的入口点。</p>
</li>
<li><p><code>!7 = !&#123;null&#125;</code>：这个标志表示一个空的类型列表，通常用于描述子程序的参数和返回类型。</p>
</li>
<li><p><code>!8</code>, <code>!9</code>, <code>!10</code> 是不同的DILocation标志，用于表示源代码中不同位置的行和列号。这些信息对于在调试器中定位和调试代码非常重要。</p>
</li>
</ol>
<p>总之，这些调试信息是为了帮助开发人员在LLVM IR级别调试程序时能够将代码映射回源代码，以便更容易地理解和解决问题。这些信息通常由编译器生成，并与生成的目标代码一起提供给调试器。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> void <span class="title">@f90_stop08a</span>(...)</span><br></pre></td></tr></table></figure>

<p>这是一个LLVM IR中的声明语句，它声明了一个名为 <code>f90_stop08a</code> 的函数，该函数返回 <code>void</code>，即没有返回值，并且接受一个或多个参数，但在声明中没有提供参数的具体类型或数量。这种声明通常用于与其他编译单元或库函数进行链接，而具体的函数定义则在另一个地方提供。在这里，<code>@f90_stop08a</code> 函数的具体实现将在其他地方定义或链接到程序中。这种方式可以在不暴露函数内部实现细节的情况下使用外部函数。</p>
<h2 id="LLVM-IR中有很多bitcast语句"><a href="#LLVM-IR中有很多bitcast语句" class="headerlink" title="LLVM IR中有很多bitcast语句"></a>LLVM IR中有很多<code>bitcast</code>语句</h2><p>这个有什么作用？</p>
]]></content>
      <categories>
        <category>log</category>
        <category>learn</category>
      </categories>
      <tags>
        <tag>project</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>clion的使用</title>
    <url>/2023/09/05/clion%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="将Clion作为编程工具"><a href="#将Clion作为编程工具" class="headerlink" title="将Clion作为编程工具"></a>将Clion作为编程工具</h2><span id="more"></span>

<p>首先将Clion中的一些快捷指令快速记录，以备后续之需。目前的工作主要是将Clion作为C++语言的开发工具，加上在ubuntu上使用十分方便。</p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li>ALT+1：显示隐藏工程栏</li>
<li>CTRL+&#x2F;：注释or解注释光标所在行</li>
<li>CTRL+SHIFT+&#x2F;：注释or解注释选中的多行代码</li>
<li>在某个函数的上面一行输入&#x2F;**+ENTER：快速生成某种格式的注释（for 大型项目）</li>
<li>CTRL+D：快速复制光标所在行</li>
<li>CTRL+X：快速剪切光标所在行</li>
<li>CTRL+W：实现某个字符、某个字符串、某段代码的扩选（智能扩选）</li>
<li>ALT+SHIFT+INSERT：按以下此组合建，在选中代码，可以实现多行某段代码的选中</li>
<li>CTRL+ALT+ “-” or “+” ：展开or折叠光标所在的花括号</li>
<li>CTRL+SHIFT+ “-” or “+” ：展开or折叠所有花括号</li>
<li>CTRL+鼠标左键：由函数声明跳转到函数定义 or 由函数定义跳转回函数声明</li>
<li>CTRL+ALT+R：重新格式化代码</li>
<li>ALT+ENTER：智能提示代码错误与解决方案</li>
<li>CTRL+F：匹配查找代码</li>
<li>CTRL+Z：返回编辑前</li>
<li>SHIFT+CTRL+Z：返回编辑后信息</li>
<li>CTRL+F：查找</li>
<li>CTRL+R：替换</li>
<li>CTRL+L：向后查找</li>
<li>CTRL+Shift+L：向前查找</li>
<li>CTRL+ALT+S：设置</li>
<li>Shift+F10：运行</li>
<li>Shift+F9：调试</li>
</ul>
<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><ul>
<li>单步运行（不跳转至其他标签，仅在本程序内）</li>
<li>单步运行（可调转到自己编写的库or头文件）</li>
<li>单步运行（可强制跳转到第三方库or头文件）</li>
<li>从第三方库跳回源文件</li>
<li>监测选中的变量</li>
</ul>
]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>IKOS</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>和符老师讨论</title>
    <url>/2023/07/14/%E5%92%8C%E7%AC%A6%E8%80%81%E5%B8%88%E8%AE%A8%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="2023-8-22讨论"><a href="#2023-8-22讨论" class="headerlink" title="2023-8-22讨论"></a>2023-8-22讨论</h2><span id="more"></span>

<p>哪些地方可以做？</p>
<p>陈：之前的想法：</p>
<p><img src="C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20230822101758868.png" alt="image-20230822101758868"></p>
<p>陈：需要考虑哪些效果预期比现在效果更好？</p>
<p>陈：利用已有前端IKOS（不变式生成能力比Clam好），先实现简单的例子，基于已有工作（博士论文，发在群里）、IC3（没听清楚）。</p>
<p>符：考虑现在比较好的方法，过程间结合图论的方法（不同的上下文调用到同一个图上，在图的算法上解决？已有很多工作做这个内容）。</p>
<p>陈：发文章需要带点新的内容，传统程序分析可能比较难，如现在流行的部分程序分析（partial），&#x3D;&#x3D;增量式程序分析（代码演化、变更时，未变更部分不用重新分析，只分析已修改部分）&#x3D;&#x3D;。</p>
<p>陈：过程间分析的瓶颈：代码量大需过程间时，在大规模和精度之间平衡？怎么找到平衡？韩国学者工作：selective上下文敏感。</p>
<p><img src="C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20230822101813289.png" alt="image-20230822101813289"></p>
<p>符：抽象解释解决嵌套循环问题困难，约束求解相对较好？</p>
<p>陈：应用场景的结合：数组（约束求解做过相关工作，但比较初级）、浮点（未做过相关工作，有待考虑）、过程间？</p>
<p>符：数组，自动分段，10年左右提出，进展较少。</p>
<p>符：浮点，基于约束的方法，相比于数组创新力更强。</p>
<p>陈：增量式程序分析：约束求解和抽象解释能否结合？（incremental）</p>
]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>chat</tag>
      </tags>
  </entry>
  <entry>
    <title>ikos的使用</title>
    <url>/2023/09/05/ikos%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="IKOS-Analyzer"><a href="#IKOS-Analyzer" class="headerlink" title="IKOS Analyzer"></a>IKOS Analyzer</h1><span id="more"></span>

<p>This folder contains the implementation of the analyzer.</p>
<h2 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h2><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#installation">Installation</a><ul>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#build-and-install">Build and Install</a></li>
<li><a href="#tests">Tests</a></li>
<li><a href="#documentation">Documentation</a></li>
</ul>
</li>
<li><a href="#how-to-run-ikos">How to run IKOS</a></li>
<li><a href="#analyze-a-whole-project-with-ikos-scan">Analyze a whole project with ikos-scan</a></li>
<li><a href="#examine-a-report-with-ikos-view">Examine a report with ikos-view</a></li>
<li><a href="#analysis-options">Analysis Options</a><ul>
<li><a href="#checks">Checks</a></li>
<li><a href="#numerical-abstract-domains">Numerical abstract domains</a></li>
<li><a href="#entry-points">Entry points</a></li>
<li><a href="#multi-threading">Multi-threading</a></li>
<li><a href="#optimization-level">Optimization level</a></li>
<li><a href="#inter-procedural-vs-intra-procedural">Inter-procedural vs Intra-procedural</a></li>
<li><a href="#fixpoint-engine-parameters">Fixpoint engine parameters</a></li>
<li><a href="#partitioning">Partitioning</a></li>
<li><a href="#hardware-addresses">Hardware addresses</a></li>
<li><a href="#other-analysis-options">Other analysis options</a></li>
</ul>
</li>
<li><a href="#report-options">Report Options</a><ul>
<li><a href="#format">Format</a></li>
<li><a href="#file">File</a></li>
<li><a href="#status-filter">Status Filter</a></li>
<li><a href="#analysis-filter">Analysis Filter</a></li>
<li><a href="#verbosity">Verbosity</a></li>
<li><a href="#other-report-options">Other report options</a></li>
</ul>
</li>
<li><a href="#apron-support">APRON Support</a></li>
<li><a href="#analysis-assumptions">Analysis Assumptions</a></li>
<li><a href="#analyze-an-embedded-software-requiring-a-cross-compiler">Analyze an embedded software requiring a cross-compiler</a></li>
<li><a href="#model-library-functions-to-reduce-warnings">Model library functions to reduce warnings</a></li>
<li><a href="#overview-of-the-source-code">Overview of the source code</a></li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The IKOS Analyzer is an abstract interpretation-based static analyzer that aims at proving the absence of runtime errors in C and C++ programs.</p>
<p>See <a href="#checks">Checks</a> for the full list of available checks.</p>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>IKOS Analyzer can be installed independently from the other components, but we recommend to build the analyzer from the root directory. To do so, follow the instructions in the root <a href="../README.md">README.md</a>.</p>
<h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><p>To build and run the analyzer, you will need the following dependencies:</p>
<ul>
<li>A C++ compiler that supports C++14 (gcc &gt;&#x3D; 4.9.2 or clang &gt;&#x3D; 3.4)</li>
<li>CMake &gt;&#x3D; 3.4.3</li>
<li>GMP &gt;&#x3D; 4.3.1</li>
<li>Boost &gt;&#x3D; 1.55</li>
<li>Python 2 &gt;&#x3D; 2.7.3 or Python 3 &gt;&#x3D; 3.3</li>
<li>SQLite &gt;&#x3D; 3.6.20</li>
<li>TBB &gt;&#x3D; 2</li>
<li>LLVM and Clang 14.0.x</li>
<li>(Optional) APRON &gt;&#x3D; 0.9.10</li>
<li>(Optional) Pygments</li>
<li>IKOS Core</li>
<li>IKOS AR</li>
<li>IKOS LLVM Frontend</li>
</ul>
<h3 id="Build-and-Install"><a href="#Build-and-Install" class="headerlink" title="Build and Install"></a>Build and Install</h3><p>To build and install the analyzer, run the following commands in the <code>analyzer</code> directory:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake \</span><br><span class="line">    -DCMAKE_INSTALL_PREFIX=/path/to/analyzer-install-directory \</span><br><span class="line">    -DLLVM_CONFIG_EXECUTABLE=/path/to/llvm/bin/llvm-config \</span><br><span class="line">    -DCORE_ROOT=/path/to/core-install-directory \</span><br><span class="line">    -DAR_ROOT=/path/to/ar-install-directory \</span><br><span class="line">    -DFRONTEND_LLVM_ROOT=/path/to/frontend-llvm-install-directory \</span><br><span class="line">    ..</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>

<h3 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h3><p>To build and run the tests, simply type:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make check</span><br></pre></td></tr></table></figure>

<h3 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h3><p>To build the documentation, you will need <a href="http://www.doxygen.org/">Doxygen</a>.</p>
<p>Then, simply type:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make doc</span><br><span class="line">$ open doc/html/index.html</span><br></pre></td></tr></table></figure>

<h2 id="How-to-run-IKOS"><a href="#How-to-run-IKOS" class="headerlink" title="How to run IKOS"></a>How to run IKOS</h2><p>Suppose we want to analyze the following C program in a file, called <em>loop.c</em>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span>: <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"> <span class="number">3</span>: <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"> <span class="number">4</span>:     <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">for</span> (;i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="number">6</span>:         a[i] = i;</span><br><span class="line"> <span class="number">7</span>:     &#125;</span><br><span class="line"> <span class="number">8</span>:     a[i] = i;</span><br><span class="line"> <span class="number">9</span>:     <span class="built_in">printf</span>(<span class="string">&quot;%i&quot;</span>, a[i]);</span><br><span class="line"><span class="number">10</span>: &#125;</span><br></pre></td></tr></table></figure>

<p>To analyze this program with IKOS, simply run:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos loop.c</span><br></pre></td></tr></table></figure>

<p>You shall see the following output. IKOS reports two occurrences of buffer overflow at line 8 and 9.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] Compiling loop.c</span><br><span class="line">[*] Running ikos preprocessor</span><br><span class="line">[*] Running ikos analyzer</span><br><span class="line">[*] Translating LLVM bitcode to AR</span><br><span class="line">[*] Running liveness analysis</span><br><span class="line">[*] Running widening hint analysis</span><br><span class="line">[*] Running interprocedural value analysis</span><br><span class="line">[*] Analyzing entry point &#x27;main&#x27;</span><br><span class="line">[*] Checking properties for entry point &#x27;main&#x27;</span><br><span class="line"></span><br><span class="line"># Time stats:</span><br><span class="line">clang        : 0.037 sec</span><br><span class="line">ikos-analyzer: 0.023 sec</span><br><span class="line">ikos-pp      : 0.007 sec</span><br><span class="line"></span><br><span class="line"># Summary:</span><br><span class="line">Total number of checks                : 7</span><br><span class="line">Total number of unreachable checks    : 0</span><br><span class="line">Total number of safe checks           : 5</span><br><span class="line">Total number of definite unsafe checks: 2</span><br><span class="line">Total number of warnings              : 0</span><br><span class="line"></span><br><span class="line">The program is definitely UNSAFE</span><br><span class="line"></span><br><span class="line"># Results</span><br><span class="line">loop.c: In function &#x27;main&#x27;:</span><br><span class="line">loop.c:8:10: error: buffer overflow, trying to access index 10 of global variable &#x27;a&#x27; of 10 elements</span><br><span class="line">    a[i] = i;</span><br><span class="line">         ^</span><br><span class="line">loop.c: In function &#x27;main&#x27;:</span><br><span class="line">loop.c:9:18: error: buffer overflow, trying to access index 10 of global variable &#x27;a&#x27; of 10 elements</span><br><span class="line">    printf(&quot;%i&quot;, a[i]);</span><br><span class="line">                 ^</span><br></pre></td></tr></table></figure>

<p>The <code>ikos</code> command takes a source file (<code>.c</code>, <code>.cpp</code>) or a LLVM bitcode file (<code>.bc</code>) as input, analyzes it to find runtime errors (also called undefined behaviors), creates a result database <code>output.db</code> in the current working directory and prints a report.</p>
<p>In the report, each line has one of the following status:</p>
<ul>
<li><strong>safe</strong>: the statement is proven safe;</li>
<li><strong>error</strong>: the statement always results into an error (or is unreachable);</li>
<li><strong>unreachable</strong>: the statement is never executed;</li>
<li><strong>warning</strong> may mean three things:<ol>
<li>the statement results into an error for some executions, or</li>
<li>the static analyzer did not have enough information to conclude (check dependent on an external input, for instance), or</li>
<li>the static analyzer was not powerful enough to prove the absence of errors;</li>
</ol>
</li>
</ul>
<p>By default, ikos shows warnings and errors directly in your terminal, like a compiler would do.</p>
<p>If the analysis report is too big, you shall use:</p>
<ul>
<li><code>ikos-report output.db</code> to examine the report in your terminal</li>
<li><code>ikos-view output.db</code> to examine the report in a web interface</li>
</ul>
<h2 id="Analyze-a-whole-project-with-ikos-scan"><a href="#Analyze-a-whole-project-with-ikos-scan" class="headerlink" title="Analyze a whole project with ikos-scan"></a>Analyze a whole project with ikos-scan</h2><p>To run IKOS on a large project, you shall use ikos-scan.</p>
<p>ikos-scan is a command line utility that runs the static analyzer over a codebase after performing a regular build.</p>
<p>The ikos-scan command works by overriding the environment variables <code>CC</code> and <code>CXX</code> to intercept the compiler commands. Behind the scene, it builds the original program as well as the LLVM bitcode file that is necessary to run the analyzer.</p>
<p>To use ikos-scan, just prefix your build commands with <code>ikos-scan</code>. For instance, to analyze pkg-config:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tar xf pkg-config-0.29.2.tar.gz</span><br><span class="line">$ cd pkg-config-0.29.2</span><br><span class="line">$ ikos-scan ./configure</span><br><span class="line">[...]</span><br><span class="line">$ ikos-scan make</span><br><span class="line">[...]</span><br><span class="line">Analyze pkg-config? [Y/n]</span><br></pre></td></tr></table></figure>

<p>ikos-scan will produce a <code>.bc</code> file for each executable in your project. You can analyze them with specific options using <code>ikos [options] program.bc</code>.</p>
<h2 id="Examine-a-report-with-ikos-view"><a href="#Examine-a-report-with-ikos-view" class="headerlink" title="Examine a report with ikos-view"></a>Examine a report with ikos-view</h2><p>ikos-view provides a web interface to examine IKOS results. It is available directly in the analyzer.</p>
<p>The web interface shows the source code with syntax highlighting, and allows you to filter the warnings by checks.</p>
<p>To use ikos-view, first run the analyzer on your project to generate a result database <code>output.db</code>, then simply run:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos-view output.db</span><br></pre></td></tr></table></figure>

<p>It will start a web server. You can then launch your favorite web browser and visit <a href="http://localhost:8080/">http://localhost:8080</a></p>
<p>Note that if you want syntax highlighting, you will need to install <a href="http://pygments.org/">Pygments</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pip install --user pygments</span><br></pre></td></tr></table></figure>

<h2 id="Analysis-Options"><a href="#Analysis-Options" class="headerlink" title="Analysis Options"></a>Analysis Options</h2><p>This section describes the most relevant options of the analyzer.</p>
<h3 id="Checks"><a href="#Checks" class="headerlink" title="Checks"></a>Checks</h3><p>The list of available checks are:</p>
<ul>
<li><strong>buffer overflow analysis</strong>, <code>-a=boa</code>: checks for buffer overflows and out-of-bound array accesses.</li>
<li><strong>division by zero analysis</strong>, <code>-a=dbz</code>: checks for integer divisions by zero.</li>
<li><strong>null pointer analysis</strong>, <code>-a=nullity</code>: checks for null pointer dereferences.</li>
<li><strong>assertion prover</strong>, <code>-a=prover</code>: prove user-defined properties, using <code>__ikos_assert(condition)</code>.</li>
<li><strong>unaligned pointer analysis</strong>, <code>-a=upav</code>: checks for unaligned pointer dereferences.</li>
<li><strong>uninitialized variable analysis</strong>, <code>-a=uva</code>: checks for read of uninitialized variables.</li>
<li><strong>signed integer overflow analysis</strong>, <code>-a=sio</code>: checks for signed integer overflows.</li>
<li><strong>unsigned integer overflow analysis</strong>, <code>-a=uio</code>: checks for unsigned integer overflows.</li>
<li><strong>shift count analysis</strong>, <code>-a=shc</code>: checks for invalid shifts, where the amount shifted is greater or equal to the bit-width of the left operand, or less than zero.</li>
<li><strong>pointer overflow analysis</strong>, <code>-a=poa</code>: checks for pointer arithmetic overflows.</li>
<li><strong>pointer comparison analysis</strong>, <code>-a=pcmp</code>: checks for pointer comparisons between pointers referring to different objects.</li>
<li><strong>soundness analysis</strong>, <code>-a=sound</code>: checks for instructions that could make the analysis unsound, i.e miss bugs.</li>
<li><strong>function call analysis</strong>, <code>-a=fca</code>: checks for function calls through function pointers of the wrong type.</li>
<li><strong>dead code analysis</strong>, <code>-a=dca</code>: checks for unreachable statements.</li>
<li><strong>double free analysis</strong>, <code>-a=dfa</code>: checks for double free, invalid free, use after free and use after return.</li>
<li><strong>debugger</strong>, <code>-a=dbg</code>: prints debug information, using <code>__ikos_print_values(&quot;desc&quot;, x)</code> and <code>__ikos_print_invariant()</code>.</li>
<li><strong>memory watcher</strong>, <code>-a=watch</code>: prints memory writes at a given memory location, using <code>__ikos_watch_mem(ptr, size)</code>.</li>
</ul>
<p>By default, all the checks are enabled except:</p>
<ul>
<li><strong>unaligned pointer analysis</strong>, because it needs a congruence domain to generate meaningful results. See <a href="#numerical-abstract-domains">Numerical abstract domains</a>.</li>
<li><strong>unsigned integer overflow analysis</strong>, because it is not an undefined behavior according to the C standard.</li>
<li><strong>pointer overflow analysis</strong>, because it is redundant with the buffer overflow analysis.</li>
<li><strong>memory watcher</strong>, because it is slow.</li>
</ul>
<p>If you want to run specific checks, use the <code>-a</code> parameter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos -a=boa,nullity test.c</span><br></pre></td></tr></table></figure>

<p>Note that you can use the wildcard character <code>*</code>, <code>+</code> and <code>-</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos -a=&#x27;*,-sio&#x27; test.c</span><br></pre></td></tr></table></figure>

<p>In this example, all the checks are enabled except signed integer overflow checks.</p>
<h3 id="Numerical-abstract-domains"><a href="#Numerical-abstract-domains" class="headerlink" title="Numerical abstract domains"></a>Numerical abstract domains</h3><p>IKOS is based on the theory of <a href="https://www.di.ens.fr/~cousot/AI/IntroAbsInt.html">Abstract Interpretation</a>. The analysis uses a numerical abstract domain internally to model integer variables.</p>
<p>The list of available numerical abstract domains are:</p>
<ul>
<li><code>-d=interval</code>: The interval domain, see <a href="https://www.di.ens.fr/~cousot/COUSOTpapers/publications.www/CousotCousot-POPL-77-ACM-p238--252-1977.pdf">CC77</a>.</li>
<li><code>-d=congruence</code>: The congruence domain, see <a href="http://www.tandfonline.com/doi/abs/10.1080/00207168908803778">Gra89</a>.</li>
<li><code>-d=interval-congruence</code>: The reduced product of interval and congruence.</li>
<li><code>-d=dbm</code>: The Difference-Bound Matrices domain, see <a href="https://www-apr.lip6.fr/~mine/publi/article-mine-padoII.pdf">PADO01</a>.</li>
<li><code>-d=var-pack-dbm</code>: The Difference-Bound Matrices domain with variable packing, see <a href="https://seahorn.github.io/papers/vmcai16.pdf">VMCAI16</a>.</li>
<li><code>-d=var-pack-dbm-congruence</code>: The reduced product of DBM with variable packing and congruence.</li>
<li><code>-d=gauge</code>: The gauge domain, see <a href="https://ti.arc.nasa.gov/publications/4767/download/">CAV12</a>.</li>
<li><code>-d=gauge-interval-congruence</code>: The reduced product of gauge, interval and congruence.</li>
<li><code>-d=apron-interval</code>: The APRON interval domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_21.html#SEC54">Box</a>.</li>
<li><code>-d=apron-octagon</code>: The APRON octagon domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/oct_doc.html">Oct</a>.</li>
<li><code>-d=apron-polka-polyhedra</code>: The APRON polka polyhedra domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_25.html#SEC58">NewPolka</a>.</li>
<li><code>-d=apron-polka-linear-equalities</code>: The APRON polka linear equalities domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_25.html#SEC58">NewPolka</a>.</li>
<li><code>-d=apron-ppl-polyhedra</code>: The APRON PPL polyhedra domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_29.html#SEC65">PPL</a>.</li>
<li><code>-d=apron-ppl-linear-congruences</code>: The APRON PPL linear congruences domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_29.html#SEC65">PPL</a>.</li>
<li><code>-d=apron-pkgrid-polyhedra-lin-cong</code>: The APRON Pkgrid polyhedra and linear congruences domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_33.html#SEC69">Pkgrid</a>.</li>
<li><code>-d=var-pack-apron-octagon</code>: The APRON octagon domain with variable packing.</li>
<li><code>-d=var-pack-apron-polka-polyhedra</code>: The APRON Polka polyhedra domain with variable packing.</li>
<li><code>-d=var-pack-apron-polka-linear-equalities</code>: The APRON Polka linear equalities domain with variable packing.</li>
<li><code>-d=var-pack-apron-ppl-polyhedra</code>: The APRON PPL polyhedra domain with variable packing.</li>
<li><code>-d=var-pack-apron-ppl-linear-congruences</code>: The APRON PPL linear congruences domain with variable packing.</li>
<li><code>-d=var-pack-apron-pkgrid-polyhedra-lin-cong</code>: The APRON Pkgrid polyhedra and linear congruences domain with variable packing.</li>
</ul>
<p>By default, IKOS uses the fastest and least precise numerical domain, the <strong>interval</strong> domain. If you want to run the analysis with a specific domain, use the <code>-d</code> parameter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos -d=var-pack-dbm test.c</span><br></pre></td></tr></table></figure>

<p>For most users, we recommend to analyze your project with the fastest and least precise domain (i.e, interval) first, and then try slower but more precise domains until the analysis is too long for you. This is the best way to reach a low rate of false positives (i.e, warnings).</p>
<p>Here is a list of numerical domains, sorted from the fastest and least precise to the slowest and most precise:</p>
<ul>
<li><code>-d=interval</code></li>
<li><code>-d=gauge-interval-congruence</code></li>
<li><code>-d=var-pack-dbm</code></li>
<li><code>-d=var-pack-apron-octagon</code></li>
<li><code>-d=var-pack-apron-ppl-polyhedra</code></li>
<li><code>-d=dbm</code></li>
<li><code>-d=apron-octagon</code></li>
<li><code>-d=apron-ppl-polyhedra</code></li>
</ul>
<p>You should consider running different analyses in this specific order.</p>
<p>Please also note that:</p>
<ul>
<li>Floating point variables are safely ignored.</li>
<li>In order to use the <strong>APRON</strong> abstract domain, you need to build IKOS with APRON first. See <a href="#apron-support">APRON Support</a>.</li>
</ul>
<h3 id="Entry-points"><a href="#Entry-points" class="headerlink" title="Entry points"></a>Entry points</h3><p>By default, the analyzer assumes the entry point of the program is <code>main</code>. You can specify a list of entry points using the <code>--entry-points</code> parameter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos --entry-points=foo,bar test.c</span><br></pre></td></tr></table></figure>

<p>IKOS analyses each entry point independently, as if they were running in different processes.</p>
<h3 id="Multi-threading"><a href="#Multi-threading" class="headerlink" title="Multi-threading"></a>Multi-threading</h3><p>The analyzer can use multi-threading to speed up the analysis. You can specify the number of threads to use with the <code>--jobs</code> or <code>-j</code> parameter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos --jobs=4 test.c</span><br></pre></td></tr></table></figure>

<p>Use <code>-j</code> to use all available threads. By default, the analyzer only uses one thread.</p>
<p><strong>Warning:</strong> APRON numerical abstract domains are currently NOT thread-safe and might cause crashes.</p>
<h3 id="Optimization-level"><a href="#Optimization-level" class="headerlink" title="Optimization level"></a>Optimization level</h3><p>The parameter <code>--opt</code> allows you to set the optimization level. Optimizations are performed by running a set of LLVM passes on the analyzed code.</p>
<p>Available levels are:</p>
<ul>
<li><strong>none</strong>: Disable all optimizations.</li>
<li><strong>basic</strong>: Basic set of optimizations (similar to <code>-O1</code>). This is the default value.</li>
<li><strong>aggressive</strong>: Aggressive optimizations (similar to <code>-O3</code>). This is not recommended since it might hide errors. The translation from LLVM to AR might fail because of unsupported instructions.</li>
</ul>
<h3 id="Inter-procedural-vs-Intra-procedural"><a href="#Inter-procedural-vs-Intra-procedural" class="headerlink" title="Inter-procedural vs Intra-procedural"></a>Inter-procedural vs Intra-procedural</h3><p>An <strong>inter-procedural</strong> analysis analyzes a function considering its call stack while an <strong>intra-procedural</strong> analysis ignores it. The former produces more precise results than the latter but it is often much more expensive.</p>
<p>By default, IKOS performs an inter-procedural analysis. Use <code>--proc=intra</code> to perform an intra-procedural analysis.</p>
<h3 id="Fixpoint-engine-parameters"><a href="#Fixpoint-engine-parameters" class="headerlink" title="Fixpoint engine parameters"></a>Fixpoint engine parameters</h3><p>The analyzer uses the theory of Abstract Interpretation to compute a fixpoint of the semantic of the program. The fixpoint engine can be tuned using several parameters.</p>
<p>When visiting a loop, the engine will first compute a fixed number of iterations, then use a widening strategy periodically to approximate the behavior of the loop, until convergence.</p>
<p>The fixed number of iterations performed before the widening strategy can be set using <code>--widening-delay</code>. By default, it is 1.</p>
<p>The period of the widening strategy can be set using <code>--widening-period</code>. By default, it is 1, thus the widening strategy is always applied.</p>
<p>The widening strategy can be set using <code>--widening-strategy=</code>:</p>
<ul>
<li><strong>widen</strong>: Use the widening operator to approximate the behavior of the loop (default)</li>
<li><strong>join</strong>: Use the join operator, effectively computing all iterations (very slow)</li>
</ul>
<p>After reaching a fixpoint, the engine will perform extra iterations to regain precision using a narrowing strategy, until convergence.</p>
<p>The narrowing strategy can be set using <code>--narrowing-strategy=</code>:</p>
<ul>
<li><strong>narrow</strong>: Use the narrowing operator, ensuring a fast convergence</li>
<li><strong>meet</strong>: Use the meet operator, convergence can be slow</li>
<li><strong>auto</strong>: Use the narrowing operator if available for the numerical abstract domain. Otherwise, perform 2 iterations using the meet operator (default)</li>
</ul>
<p>You can specify a fixed number of narrowing iterations to perform using <code>--narrowing-iterations</code>.</p>
<p>You can specify the widening delay for a given function using <code>--widening-delay-functions</code>. For instance, <code>--widening-delay-functions=&quot;main:10, f:32&quot;</code>.</p>
<h3 id="Partitioning"><a href="#Partitioning" class="headerlink" title="Partitioning"></a>Partitioning</h3><p>The analyzer can use abstract domain partitioning based on integer variables using the <code>--partitioning</code> option.</p>
<p>Using <code>--partitioning=return</code>, the analyzer will split the states at the end of a function according to the function return codes.</p>
<p>This can be used to improve the precision of the analysis on the following code pattern:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> status = xxx();</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Error in xxx</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = yyy();</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">// Error in yyy</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    zzz();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Instead of performing the abstract union and lose precision, the analyzer will keep 3 invariants for each outcome of the <code>init</code> function.</p>
<p>Using <code>--partitioning=manual</code>, the analyzer will split the states according to the values of a given integer variable, set with <code>__ikos_partitioning_var_int(x)</code>.</p>
<p>By default, partitioning is disabled.</p>
<h3 id="Hardware-addresses"><a href="#Hardware-addresses" class="headerlink" title="Hardware addresses"></a>Hardware addresses</h3><p>In C code for embedded systems, it is usual to read or write at specific addresses to communicate with the hardware. By default, IKOS treats memory accesses at specific addresses as errors.</p>
<p>You can provide the <code>--hardware-addresses</code> parameter to specify a range of valid memory addresses:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos --hardware-addresses=0x20-0x40 project.bc</span><br></pre></td></tr></table></figure>

<p>During the analysis, IKOS will assume that memory accesses in the range <code>[0x20, 0x40]</code> (in bytes, inclusive) are safe.</p>
<h3 id="Other-analysis-options"><a href="#Other-analysis-options" class="headerlink" title="Other analysis options"></a>Other analysis options</h3><ul>
<li><code>--globals-init</code>: use the given strategy for initialization of global variables.</li>
<li><code>--no-init-globals</code>: disable global variable initialization for the given entry points.</li>
<li><code>--no-liveness</code>: disable the liveness analysis.</li>
<li><code>--no-pointer</code>: disable the pointer analysis.</li>
<li><code>--no-widening-hints</code>: disable the detection of widening hints.</li>
<li><code>--no-fixpoint-cache</code>: disable the cache of fixpoint for called functions.</li>
<li><code>--no-checks</code>: disable all the checks</li>
<li><code>--argc</code>: specify the value of <code>argc</code> for the analysis.</li>
<li><code>--no-libc</code>: do not use libc intrinsics. Useful for bare metal programming.</li>
</ul>
<p>See <code>ikos --help</code> for more information.</p>
<h2 id="Report-Options"><a href="#Report-Options" class="headerlink" title="Report Options"></a>Report Options</h2><p>This section describes the most relevant report options supported by <code>ikos</code> and <code>ikos-report</code>.</p>
<h3 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h3><p>You can specify the format of the report using the <code>--format</code> (or <code>-f</code>) parameter.</p>
<p>Available formats are:</p>
<ul>
<li><strong>text</strong>: Text format, convenient for the terminal;</li>
<li><strong>csv</strong>: CSV format, convenient for spreadsheet import;</li>
<li><strong>json</strong>: JSON format, convenient for developers.</li>
<li><strong>web</strong>: Web interface, using ikos-view.</li>
<li><strong>no</strong>: Disable the report.</li>
</ul>
<p>By default, if the report has less than 15 entries, it will be printed out using the text format.</p>
<p>We recommend to use <a href="#examine-a-report-with-ikos-view">ikos-view</a> to examine reports of large projects.</p>
<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>By default, the report is generated on the standard output. You can write it into a file using <code>--report-file=/path/to/report</code></p>
<h3 id="Status-Filter"><a href="#Status-Filter" class="headerlink" title="Status Filter"></a>Status Filter</h3><p>Use <code>--status-filter</code> to filter unwanted checks.</p>
<p>Possible values are: <strong>error</strong>, <strong>warning</strong>, <strong>safe</strong>, <strong>unreachable</strong>.</p>
<p>Note that you can use the wildcard character <code>*</code>, <code>+</code> and <code>-</code>.</p>
<h3 id="Analysis-Filter"><a href="#Analysis-Filter" class="headerlink" title="Analysis Filter"></a>Analysis Filter</h3><p>Use <code>--analyses-filter</code> to filter unwanted checks.</p>
<p>Possible values are described in <a href="#checks">Checks</a>.</p>
<p>Note that you can use the wildcard character <code>*</code>, <code>+</code> and <code>-</code>. For instance:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos-report --analyses-filter=&#x27;*,-boa&#x27; output.db</span><br></pre></td></tr></table></figure>

<p>This will generate a report with all the checks, except buffer overflows.</p>
<h3 id="Verbosity"><a href="#Verbosity" class="headerlink" title="Verbosity"></a>Verbosity</h3><p>Use <code>--report-verbosity [1-4]</code> to specify the verbosity. A verbosity of one will give you very short messages, where a verbosity of 4 will provide you with all the information the analyzer has.</p>
<h4 id="Other-report-options"><a href="#Other-report-options" class="headerlink" title="Other report options"></a>Other report options</h4><p>See <code>ikos-report --help</code> for more information.</p>
<h2 id="APRON-Support"><a href="#APRON-Support" class="headerlink" title="APRON Support"></a>APRON Support</h2><p><a href="http://apron.cri.ensmp.fr/library/">APRON</a> is a C library for static analysis using Abstract Interpretation. It implements several complex abstract domains, such as the Polyhedra domain.</p>
<p>IKOS provides a wrapper for APRON, allowing you to use any APRON abstract domain in the analyzer.</p>
<p>To use APRON, first download, build and install it. Consider using the svn trunk. You will also need to build APRON with <a href="http://bugseng.com/products/ppl/">Parma Polyhedra Library</a> enabled. Set <code>HAS_PPL = 1</code> and define <code>PPL_PREFIX</code> in your <code>Makefile.config</code></p>
<p>Now, to build IKOS with APRON support, just provide the option <code>-DAPRON_ROOT=/path/to/apron-install</code> when running cmake. For instance:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake \</span><br><span class="line">    -DCMAKE_INSTALL_PREFIX=/path/to/ikos-install \</span><br><span class="line">    -DAPRON_ROOT=/path/to/apron-install \</span><br><span class="line">    ..</span><br></pre></td></tr></table></figure>

<p>See <a href="#numerical-abstract-domains">Numerical abstract domains</a> for the list of numerical abstract domains.</p>
<h2 id="Analysis-Assumptions"><a href="#Analysis-Assumptions" class="headerlink" title="Analysis Assumptions"></a>Analysis Assumptions</h2><p>This section describes the assumptions made by the analyzer about the code.</p>
<p>First, the analyzed code is compiled with the <strong>Clang</strong> compiler using the host target. Thus, Clang is responsible for specifying the data model (size of types), the data layout (alignments), the endianness, the signedness of <code>char</code>, the semantic of floating points, etc. depending on the host target. The analyzer uses the generated LLVM bitcode from Clang. This means that you can get different results depending on your host target.</p>
<p>During the analysis, the analyzer will make the following assumptions:</p>
<ul>
<li>The program is single-threaded.</li>
<li>The program does not receive signals.</li>
<li>The program does not receive interrupts.</li>
<li>Extern functions (without implementation) do not update global variables.</li>
<li>Extern functions can write on their pointer parameters, but only with one level of indirection:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>** p)</span>; <span class="comment">// Assume to write on *p but not **p</span></span><br></pre></td></tr></table></figure></li>
<li>Extern functions do not call user-defined functions (no callbacks).</li>
<li>Extern functions can throw exceptions.</li>
<li>Extern functions return well-initialized values.</li>
<li>Recursive function calls can update any value in memory.</li>
<li>Recursive function calls can throw exceptions.</li>
<li>Recursive function calls return well-initialized values.</li>
<li>Assembly codes are treated as extern function calls.</li>
<li>C standard library functions do not throw exceptions.</li>
</ul>
<h2 id="Analyze-an-embedded-software-requiring-a-cross-compiler"><a href="#Analyze-an-embedded-software-requiring-a-cross-compiler" class="headerlink" title="Analyze an embedded software requiring a cross-compiler"></a>Analyze an embedded software requiring a cross-compiler</h2><p>Running the analyzer on an embedded software that requires a cross-compiler can be challenging.</p>
<p>You should try to use <a href="#analyze-a-whole-project-with-ikos-scan">ikos-scan</a> first, but this will probably fail with compiler errors.</p>
<p>To solve this issue, you will need to create an alternative build file that compiles everything to LLVM bitcode. For instance, if you use <code>make</code>, you could create <code>Makefile.llvm</code> based on <code>Makefile</code>.</p>
<p>In the alternative build file:</p>
<ul>
<li>Locate the build rules that generate intermediate object files (<code>.o</code>).</li>
<li>In these rules, add the flag <code>-save-temps=obj</code> to the cross-compiler commands. This will generate a preprocessed file <code>.i</code> in addition to the <code>.o</code>.</li>
<li>At the end of these rules, add a command to compile the preprocessed file <code>.i</code> to LLVM bitcode <code>.bc</code> using: <code>clang -c -emit-llvm -D_FORTIFY_SOURCE=0 -D__IKOS__ -g -O0 -Xclang -disable-O0-optnone &lt;file.i&gt; -o &lt;file.bc&gt;</code>.</li>
<li>Locate the build rules that link the intermediate object files into binaries or shared libraries.</li>
<li>At the end of these rules, link the LLVM bitcodes <code>.bc</code> together using <code>llvm-link</code>.</li>
</ul>
<p>For instance, in <code>Makefile.llvm</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%.o: %.c</span><br><span class="line">	$(CC) -c $(CPPFLAGS) $(CFLAGS) -save-temps=obj $&lt; -o $@</span><br><span class="line">	clang -c -emit-llvm -D_FORTIFY_SOURCE=0 -D__IKOS__ -g -O0 -Xclang -disable-O0-optnone $(subst .o,.i,$@) -o $(subst .o,.bc,$@)</span><br><span class="line"></span><br><span class="line">program: a.o b.o</span><br><span class="line">	$(CC) $(CPPFLAGS) $(CFLAGS) a.o b.o -o $@</span><br><span class="line">	llvm-link a.bc b.bc -o $@.bc</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -f *.o *.i *.s *.bc</span><br></pre></td></tr></table></figure>

<p>Then, run your build tool using the alternative build file to generate the LLVM bitcode (e.g, <code>make -f Makefile.llvm</code>).</p>
<p>You can finally analyze your program by running ikos on the generated LLVM bitcode file (e.g, <code>ikos program.bc</code>).</p>
<h2 id="Model-library-functions-to-reduce-warnings"><a href="#Model-library-functions-to-reduce-warnings" class="headerlink" title="Model library functions to reduce warnings"></a>Model library functions to reduce warnings</h2><p>The analyzer doesn’t require the libraries used by your program. It will consider library functions as unknown extern functions and make some <a href="#analysis-assumptions">assumptions</a> about them.</p>
<p>The analyzer will produce a warning for each call to an unknown function. You can use <code>ikos-report --analyses-filter=sound output.db</code> to list these warnings, or filter the “ignored call side effect” in ikos-view.</p>
<p>You can model library functions to improve the precision of the analysis and reduce the number of warnings. To model a library function, simply write a small implementation for it and link it in your program. This is usually called a “stub”.</p>
<p>For instance, a stub for <code>fgets</code> could be:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ikos/analyzer/intrinsic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">fgets</span><span class="params">(<span class="type">char</span>* <span class="keyword">restrict</span> str, <span class="type">int</span> size, FILE* <span class="keyword">restrict</span> stream)</span> &#123;</span><br><span class="line">    __ikos_assert(size &gt;= <span class="number">0</span>);</span><br><span class="line">    __ikos_forget_mem(stream, <span class="keyword">sizeof</span>(FILE));</span><br><span class="line">    __ikos_abstract_mem(str, size);</span><br><span class="line">    <span class="keyword">return</span> __ikos_nondet_int() ? str : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The analyzer provides helper functions to implement these stubs, see <a href="include/ikos/analyzer/intrinsic.h">include&#x2F;ikos&#x2F;analyzer&#x2F;intrinsic.h</a></p>
<p>Note that most functions of the C standard library are already modeled, but not all of them.</p>
<h2 id="Overview-of-the-source-code"><a href="#Overview-of-the-source-code" class="headerlink" title="Overview of the source code"></a>Overview of the source code</h2><p>The following illustrates the directory structure of this folder:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── doc</span><br><span class="line">│   └── doxygen</span><br><span class="line">│       └── latex</span><br><span class="line">├── include</span><br><span class="line">│   └── ikos</span><br><span class="line">│       └── analyzer</span><br><span class="line">│           ├── analysis</span><br><span class="line">│           │   ├── execution_engine</span><br><span class="line">│           │   ├── pointer</span><br><span class="line">│           │   └── value</span><br><span class="line">│           ├── checker</span><br><span class="line">│           ├── database</span><br><span class="line">│           │   └── table</span><br><span class="line">│           ├── json</span><br><span class="line">│           ├── support</span><br><span class="line">│           └── util</span><br><span class="line">├── python</span><br><span class="line">│   └── ikos</span><br><span class="line">│       └── view</span><br><span class="line">│           ├── static</span><br><span class="line">│           │   ├── css</span><br><span class="line">│           │   └── js</span><br><span class="line">│           └── template</span><br><span class="line">├── script</span><br><span class="line">├── src</span><br><span class="line">│   ├── analysis</span><br><span class="line">│   │   ├── pointer</span><br><span class="line">│   │   └── value</span><br><span class="line">│   │       └── machine_int_domain</span><br><span class="line">│   ├── checker</span><br><span class="line">│   ├── database</span><br><span class="line">│   │   └── table</span><br><span class="line">│   ├── json</span><br><span class="line">│   └── util</span><br><span class="line">└── test</span><br><span class="line">    └── regression</span><br></pre></td></tr></table></figure>

<h4 id="doc-x2F"><a href="#doc-x2F" class="headerlink" title="doc&#x2F;"></a>doc&#x2F;</h4><p>Contains Doxygen files.</p>
<h4 id="include-x2F"><a href="#include-x2F" class="headerlink" title="include&#x2F;"></a>include&#x2F;</h4><ul>
<li><a href="include/ikos/analyzer/intrinsic.h">include&#x2F;ikos&#x2F;analyzer&#x2F;intrinsic.h</a> contains definition of IKOS intrinsics that can be used in analyzed source code.</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-analysis"><a href="#include-x2F-ikos-x2F-analyzer-x2F-analysis" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;analysis"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;analysis</h5><ul>
<li><p><a href="include/ikos/analyzer/analysis/call_context.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;call_context.hpp</a> contains definition of a call context and the call context factory.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/context.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;context.hpp</a> contains definition of the global context of the analyzer.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/literal.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;literal.hpp</a> contains definition of the literal factory. It converts an AR operand to an AR-independent format.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/liveness.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;liveness.hpp</a> contains definition of the liveness analysis. It computes the set of live and dead variables for all functions.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/memory_location.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;memory_location.hpp</a> contains definition of symbolic memory locations (global, stack, heap-allocated, etc), and the memory location factory.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/option.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;option.hpp</a> contains definition of analysis options.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/variable.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;variable.hpp</a> contains definition of variables (local, global, etc), and the variable factory.</p>
</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-execution-engine"><a href="#include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-execution-engine" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine</h5><ul>
<li><p><a href="include/ikos/analyzer/analysis/execution_engine/context_insensitive.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine&#x2F;context_insensitive.hpp</a> contains definition of <code>ContextInsensitiveCallExecutionEngine</code>, a call execution engine for context-insensitive analyses.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/execution_engine/engine.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine&#x2F;engine.hpp</a> contains definition of base classes for execution engines. It defines an API to execute AR statements.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/execution_engine/inliner.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine&#x2F;inliner.hpp</a> contains definition of <code>InlineCallExecutionEngine</code>, a call execution engine performing dynamic inlining.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/execution_engine/numerical.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine&#x2F;numerical.hpp</a> contains definition of <code>NumericalExecutionEngine</code>, the main execution engine of the analyzer. It executes AR statements on an abstract domain.</p>
</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-pointer"><a href="#include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-pointer" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer</h5><ul>
<li><p><a href="include/ikos/analyzer/analysis/pointer/constraint.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer&#x2F;constraint.hpp</a> contains definition of <code>PointerConstraintsGenerator</code>, a generator of pointer constraints given an AR function or global variable.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/pointer/function.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer&#x2F;function.hpp</a> contains definition of a function pointer analysis.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/pointer/pointer.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer&#x2F;pointer.hpp</a> contains definition of a pointer analysis.</p>
</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-value"><a href="#include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-value" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value</h5><ul>
<li><p><a href="include/ikos/analyzer/analysis/value/abstract_domain.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value&#x2F;abstract_domain.hpp</a> contains definition the abstract domain used during the value analysis.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/value/interprocedural.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value&#x2F;interprocedural.hpp</a> contains definition the interprocedural value analysis.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/value/intraprocedural.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value&#x2F;intraprocedural.hpp</a> contains definition the intraprocedural value analysis.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/value/machine_int_domain.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value&#x2F;machine_int_domain.hpp</a> contains definition the machine integer abstract domain used during the value analysis.</p>
</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-checker"><a href="#include-x2F-ikos-x2F-analyzer-x2F-checker" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;checker"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;checker</h5><p>Contains definition of the different checks on the code (buffer overflow, division by zero, etc.), given the result of an analysis.</p>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-database-x2F-table"><a href="#include-x2F-ikos-x2F-analyzer-x2F-database-x2F-table" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;database&#x2F;table"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;database&#x2F;table</h5><p>Contains definition of the different output database tables.</p>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-json"><a href="#include-x2F-ikos-x2F-analyzer-x2F-json" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;json"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;json</h5><p>Contains definition of a JSON library.</p>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-support"><a href="#include-x2F-ikos-x2F-analyzer-x2F-support" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;support"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;support</h5><p>Contains various helpers, e.g, assertions.</p>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-util"><a href="#include-x2F-ikos-x2F-analyzer-x2F-util" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;util"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;util</h5><p>Contains definition of utilities for the analyzer, e.g, logging, colors, timers, etc.</p>
<h4 id="python-x2F"><a href="#python-x2F" class="headerlink" title="python&#x2F;"></a>python&#x2F;</h4><ul>
<li><p><a href="python/ikos/analyzer.py">python&#x2F;ikos&#x2F;analyzer.py</a> contains implementation of the <code>ikos</code> command line tool.</p>
</li>
<li><p><a href="python/ikos/report.py">python&#x2F;ikos&#x2F;report.py</a> contains implementation of the <code>ikos-report</code> command line tool.</p>
</li>
<li><p><a href="python/ikos/settings.py.in">python&#x2F;ikos&#x2F;settings.py.in</a> contains implementation of the <code>ikos-config</code> command line tool.</p>
</li>
<li><p><a href="python/ikos/view.py">python&#x2F;ikos&#x2F;view.py</a> contains implementation of the <code>ikos-view</code> command line tool.</p>
</li>
</ul>
<h5 id="python-x2F-ikos-x2F-analyzer-x2F-view"><a href="#python-x2F-ikos-x2F-analyzer-x2F-view" class="headerlink" title="python&#x2F;ikos&#x2F;analyzer&#x2F;view"></a>python&#x2F;ikos&#x2F;analyzer&#x2F;view</h5><p>Contains the web resources for ikos-view. It includes HTML, CSS and JS code.</p>
<h4 id="script-x2F"><a href="#script-x2F" class="headerlink" title="script&#x2F;"></a>script&#x2F;</h4><p>Contains python entry points for the command line tools.</p>
<h4 id="src-x2F"><a href="#src-x2F" class="headerlink" title="src&#x2F;"></a>src&#x2F;</h4><p>Contains implementation files, following the structure of <code>include/ikos/analyzer</code>.</p>
<ul>
<li><a href="src/ikos_analyzer.cpp">src&#x2F;ikos_analyzer.cpp</a> contains the implementation of <code>ikos-analyzer</code>. This is the entry point for all analyses.</li>
</ul>
]]></content>
      <categories>
        <category>ikos</category>
      </categories>
      <tags>
        <tag>ikos</tag>
      </tags>
  </entry>
  <entry>
    <title>读IKOS文档</title>
    <url>/2023/09/06/%E8%AF%BBIKOS%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="读IKOS文档"><a href="#读IKOS文档" class="headerlink" title="读IKOS文档"></a>读IKOS文档</h2><span id="more"></span>

<p>主要记录IKOS文档的信息，以备自己之后做更改时，可以更好地回忆。</p>
<h3 id="前端工作部分"><a href="#前端工作部分" class="headerlink" title="前端工作部分"></a>前端工作部分</h3><p><img src="/paper_source/%E8%AF%BBIKOS%E6%96%87%E6%A1%A3/%E5%89%8D%E7%AB%AF%E4%BF%AE%E6%94%B9LLVM2AR.jpg" alt="image-20230906195706369"></p>
<p>前端的工作主要是在两个地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include/ikos/frontend/llvm/import contains definition of the translation from LLVM to AR.</span><br><span class="line">src/import contains implementation of the translation from LLVM to AR.</span><br></pre></td></tr></table></figure>

<p>这是肯定要做修改的部分，后续可能需要修改下游的一些关联数据。但是目前设计的思路是先将原来进行的转换部分先读懂。如果按照原来的思路能进行便按照最简单的方法进行，否则全部重新设计工作量太大。</p>
]]></content>
      <categories>
        <category>ikos</category>
        <category>learn</category>
      </categories>
      <tags>
        <tag>project</tag>
        <tag>ikos</tag>
      </tags>
  </entry>
  <entry>
    <title>LLVMIR2AR</title>
    <url>/2023/09/06/LLVMIR2AR%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="IKOS-LLVM-Frontend"><a href="#IKOS-LLVM-Frontend" class="headerlink" title="IKOS LLVM Frontend"></a>IKOS LLVM Frontend</h1><span id="more"></span>

<p>This folder contains implementation of the LLVM frontend for IKOS.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The LLVM frontend implements:</p>
<ul>
<li><code>ikos-pp</code>, a LLVM bitcode pre-processor for static analysis</li>
<li><code>llvm-to-ar</code>, a library to translate LLVM bitcode to Abstract Representation (AR)</li>
<li><code>ikos-import</code>, a translator from LLVM bitcode to AR, used for debugging purpose.</li>
</ul>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>IKOS LLVM Frontend contains a C++ library and executables. It can be installed independently from the other components.</p>
<h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><p>To build IKOS LLVM Frontend, you will need the following dependencies:</p>
<ul>
<li>A C++ compiler that supports C++14 (gcc &gt;&#x3D; 4.9.2 or clang &gt;&#x3D; 3.4)</li>
<li>CMake &gt;&#x3D; 3.4.3</li>
<li>GMP &gt;&#x3D; 4.3.1</li>
<li>Boost &gt;&#x3D; 1.55</li>
<li>LLVM 14.0.x</li>
<li>IKOS Core</li>
<li>IKOS AR</li>
</ul>
<h3 id="Build-and-Install"><a href="#Build-and-Install" class="headerlink" title="Build and Install"></a>Build and Install</h3><p>To build and install IKOS LLVM Frontend, run the following commands in the <code>frontend/llvm</code> directory:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake \</span><br><span class="line">    -DCMAKE_INSTALL_PREFIX=/path/to/frontend-llvm-install-directory \</span><br><span class="line">    -DLLVM_CONFIG_EXECUTABLE=/path/to/llvm/bin/llvm-config \</span><br><span class="line">    -DCORE_ROOT=/path/to/core-install-directory \</span><br><span class="line">    -DAR_ROOT=/path/to/ar-install-directory \</span><br><span class="line">    ..</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>

<h3 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h3><p>To build and run the tests, simply type:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make check</span><br></pre></td></tr></table></figure>

<h2 id="Running-the-LLVM-Frontend-Tools"><a href="#Running-the-LLVM-Frontend-Tools" class="headerlink" title="Running the LLVM Frontend Tools"></a>Running the LLVM Frontend Tools</h2><h3 id="lib-x2F-libikos-llvm-to-ar-a"><a href="#lib-x2F-libikos-llvm-to-ar-a" class="headerlink" title="lib&#x2F;libikos-llvm-to-ar.a"></a>lib&#x2F;libikos-llvm-to-ar.a</h3><p><code>llvm-to-ar</code> is a library to translate LLVM bitcode to AR, used by the analyzer and <code>ikos-import</code>.</p>
<h3 id="ikos-pp"><a href="#ikos-pp" class="headerlink" title="ikos-pp"></a>ikos-pp</h3><p><code>ikos-pp</code> is a LLVM bitcode pre-processor for static analysis.</p>
<p>It is similar to the LLVM <code>opt</code> command, see <a href="https://llvm.org/docs/CommandGuide/opt.html">https://llvm.org/docs/CommandGuide/opt.html</a></p>
<p>See <code>ikos-pp -help</code> for more information.</p>
<h3 id="ikos-import"><a href="#ikos-import" class="headerlink" title="ikos-import"></a>ikos-import</h3><p><code>ikos-import</code> is a translator from LLVM bitcode to AR, used for debugging purpose.</p>
<p>See <code>ikos-import -help</code> for more information.</p>
<h2 id="Overview-of-the-source-code"><a href="#Overview-of-the-source-code" class="headerlink" title="Overview of the source code"></a>Overview of the source code</h2><p>The following illustrates the directory structure of this folder:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── ikos</span><br><span class="line">│       └── frontend</span><br><span class="line">│           └── llvm</span><br><span class="line">│               └── import</span><br><span class="line">├── src</span><br><span class="line">│   ├── import</span><br><span class="line">│   └── pass</span><br><span class="line">└── test</span><br><span class="line">    └── regression</span><br><span class="line">        ├── import</span><br><span class="line">        │   ├── aggressive_optimization</span><br><span class="line">        │   ├── basic_optimization</span><br><span class="line">        │   └── no_optimization</span><br><span class="line">        └── pass</span><br><span class="line">            ├── lower_cst_expr</span><br><span class="line">            ├── lower_select</span><br><span class="line">            ├── remove_printf_calls</span><br><span class="line">            └── remove_unreachable_blocks</span><br></pre></td></tr></table></figure>

<h4 id="include-x2F"><a href="#include-x2F" class="headerlink" title="include&#x2F;"></a>include&#x2F;</h4><ul>
<li><p><a href="include/ikos/frontend/llvm/import">include&#x2F;ikos&#x2F;frontend&#x2F;llvm&#x2F;import</a> contains definition of the translation from LLVM to AR.</p>
</li>
<li><p><a href="include/ikos/frontend/llvm/pass.hpp">include&#x2F;ikos&#x2F;frontend&#x2F;llvm&#x2F;pass.hpp</a> contains definition of LLVM passes for helping static analysis.</p>
</li>
</ul>
<h4 id="src-x2F"><a href="#src-x2F" class="headerlink" title="src&#x2F;"></a>src&#x2F;</h4><ul>
<li><p><a href="src/ikos_import.cpp">src&#x2F;ikos_import.cpp</a> contains implementation of <code>ikos-import</code>.</p>
</li>
<li><p><a href="src/ikos_pp.cpp">src&#x2F;ikos_pp.cpp</a> contains implementation of <code>ikos-pp</code>.</p>
</li>
<li><p><a href="src/import">src&#x2F;import</a> contains implementation of the translation from LLVM to AR.</p>
</li>
<li><p><a href="src/pass">src&#x2F;pass</a> contains implementation of LLVM passes for helping static analysis.</p>
</li>
</ul>
<h4 id="test-x2F"><a href="#test-x2F" class="headerlink" title="test&#x2F;"></a>test&#x2F;</h4><p>Contains regression tests.</p>
]]></content>
      <categories>
        <category>ikos</category>
      </categories>
      <tags>
        <tag>ikos</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年10月</title>
    <url>/2023/10/07/2023%E5%B9%B410%E6%9C%88/</url>
    <content><![CDATA[<h1 id="问题日志"><a href="#问题日志" class="headerlink" title="问题日志"></a>问题日志</h1><span id="more"></span>

<h2 id="IEEE754和binary32这种模式有什么区别"><a href="#IEEE754和binary32这种模式有什么区别" class="headerlink" title="IEEE754和binary32这种模式有什么区别"></a>IEEE754和binary32这种模式有什么区别</h2><p>IEEE 754和binary32都是浮点数表示的标准。IEEE 754是一种用于表示浮点数的标准，它定义了浮点数的表示方法、运算规则等。而binary32是IEEE 754标准中的一种具体实现，也称为单精度浮点数，用32位（或4个字节）来表示一个浮点数。</p>
<p>主要区别在于，IEEE 754是一个标准，定义了多种浮点数的表示方式，包括单精度（binary32）、双精度（binary64）等。而binary32是这个标准中的一种特定实现，它使用32位来表示一个浮点数，其中1位表示符号位，8位表示指数，23位表示尾数。这种表示方式允许在一定范围内表示很大或很小的数字，并保持相对较高的精度。</p>
<p>简而言之，IEEE 754是浮点数表示的标准，而binary32是这个标准中的一种具体实现，用32位表示一个浮点数。</p>
<h2 id="IEEE754标准中都有哪些模式"><a href="#IEEE754标准中都有哪些模式" class="headerlink" title="IEEE754标准中都有哪些模式"></a>IEEE754标准中都有哪些模式</h2><p>IEEE 754标准定义了几种不同精度的浮点数表示方式，包括：</p>
<ol>
<li><p><strong>单精度（binary32）：</strong> 使用32位（4字节）来表示一个浮点数，其中1位表示符号，8位表示指数，23位表示尾数。</p>
</li>
<li><p><strong>双精度（binary64）：</strong> 使用64位（8字节）来表示一个浮点数，其中1位表示符号，11位表示指数，52位表示尾数。</p>
</li>
<li><p><strong>拓展精度（extended precision）：</strong> 使用80位或128位来表示一个浮点数，具体的位数可能因硬件和软件平台而异。这种格式在一些计算中常用，因为它提供了比双精度更高的精度。</p>
</li>
</ol>
<p>此外，IEEE 754标准还定义了一些特殊值，包括正无穷大、负无穷大、NaN（Not a Number，表示非数值，用于表示无效的操作结果或未定义的数学运算）等。这些标准确保了在不同计算机系统之间的浮点数表示的一致性和可移植性。</p>
<h2 id="polynomial-iteration翻译并解释"><a href="#polynomial-iteration翻译并解释" class="headerlink" title="polynomial iteration翻译并解释"></a>polynomial iteration翻译并解释</h2><p>“Polynomial iteration” 可以翻译为 “多项式迭代”。</p>
<p>多项式迭代是一种数值计算方法，通常用于求解方程或寻找多项式的根。在多项式迭代中，你会从一个初始猜测值开始，然后使用多项式函数的迭代过程来逐步接近方程的解或多项式的根。这个过程会一次又一次地应用多项式函数，每次都使用上一次计算的结果作为下一次的输入，直到达到所需的精度或找到根为止。</p>
<p>多项式迭代在数学和工程领域中广泛应用，用于解决各种方程和问题，例如找到方程的实数或复数根，计算多项式的因子，以及进行数值优化等任务。它是数值分析和计算数学中的重要技术之一。</p>
<h2 id="conjugate-gradient-algorithm翻译并解释"><a href="#conjugate-gradient-algorithm翻译并解释" class="headerlink" title="conjugate gradient algorithm翻译并解释"></a>conjugate gradient algorithm翻译并解释</h2><p>“Conjugate Gradient Algorithm” 可以翻译为 “共轭梯度算法”。</p>
<p>共轭梯度算法是一种用于解决大规模线性方程组和优化问题的迭代数值算法。它通常用于解决对称正定矩阵的线性方程组，这类问题在科学和工程中经常出现，例如在计算机图形学、结构力学、机器学习等领域。</p>
<p>这个算法的核心思想是通过一系列迭代步骤来逼近线性方程组的解，每一步都通过利用共轭（conjugate）的方向来减小残差（residual）。共轭方向的选择保证了算法的高效性，因为它最大程度地减少了在解空间中寻找解的步骤。在每一步中，算法会更新当前解的位置，并计算一个共轭方向，然后朝着这个方向进行搜索，以最小化残差。</p>
<p>共轭梯度算法通常用于求解大规模稀疏矩阵的线性方程组，这些问题在许多科学和工程应用中都非常重要。它具有较好的收敛性和高效性，是解决这类问题的一种常用方法。</p>
<h2 id="解释C-类成员函数的声明"><a href="#解释C-类成员函数的声明" class="headerlink" title="解释C++类成员函数的声明"></a>解释C++类成员函数的声明</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// \brief Copy assignment operator</span></span><br><span class="line">  DotFormatter&amp; <span class="keyword">operator</span>=(<span class="type">const</span> DotFormatter&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<p>这是一个C++类成员函数的声明。我为你分步解释：</p>
<ol>
<li><p><code>/// \brief Copy assignment operator</code></p>
<ul>
<li>这是一个Doxygen风格的注释。Doxygen是一个文档生成工具，它可以从源代码注释中生成文档。此注释说明下面的函数是一个拷贝赋值运算符。</li>
</ul>
</li>
<li><p><code>DotFormatter&amp; operator=(const DotFormatter&amp;) noexcept = default;</code></p>
<ul>
<li><code>DotFormatter&amp; operator=(const DotFormatter&amp;)</code>：这是拷贝赋值运算符的声明。它接受一个常量引用<code>const DotFormatter&amp;</code>作为参数，并返回<code>DotFormatter&amp;</code>类型的引用，表示赋值后的对象的引用。</li>
<li><code>noexcept</code>：这是一个C++11特性，表明此函数不会抛出异常。</li>
<li><code>= default;</code>：这是一个C++11特性，表示使用编译器默认提供的拷贝赋值运算符的实现。也就是说，我们没有手动提供具体的实现，而是让编译器为我们生成默认的实现。</li>
</ul>
</li>
</ol>
<p>总体上，这行代码是在声明<code>DotFormatter</code>类的拷贝赋值运算符，并使用编译器默认的实现，并指明这个函数不会抛出异常。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// \brief Move assignment operator</span></span><br><span class="line">  DotFormatter&amp; <span class="keyword">operator</span>=(DotFormatter&amp;&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<p>这是一个C++类成员函数的声明，具体是声明了一个移动赋值运算符。我将为你逐步解释：</p>
<ol>
<li><p><code>/// \brief Move assignment operator</code></p>
<ul>
<li>同样是一个Doxygen风格的注释，说明这是一个移动赋值运算符。</li>
</ul>
</li>
<li><p><code>DotFormatter&amp; operator=(DotFormatter&amp;&amp;) noexcept = default;</code></p>
<ul>
<li><code>DotFormatter&amp; operator=(DotFormatter&amp;&amp;)</code>：这是移动赋值运算符的声明。它接受一个右值引用<code>DotFormatter&amp;&amp;</code>作为参数，并返回<code>DotFormatter&amp;</code>类型的引用，代表赋值后的对象的引用。</li>
<li><code>noexcept</code>：表示此函数不会抛出异常。</li>
<li><code>= default;</code>：表示使用编译器默认提供的移动赋值运算符的实现。也就是说，没有手动提供具体的实现，而是让编译器为我们生成默认的实现。</li>
</ul>
</li>
</ol>
<p>总结：这行代码是在声明<code>DotFormatter</code>类的移动赋值运算符，并使用编译器的默认实现，并且指定这个函数不会抛出异常。移动赋值运算符通常用于实现资源的高效转移，特别是在对象间进行赋值操作时。</p>
<h2 id="C-中的移动构造函数是什么"><a href="#C-中的移动构造函数是什么" class="headerlink" title="C++中的移动构造函数是什么"></a>C++中的移动构造函数是什么</h2><p>在C++中，移动构造函数是C++11及以后版本中引入的一个新特性，它允许对象”窃取”另一个对象的资源，而不是通过复制这些资源来构造新对象。这通常用于优化临时对象的资源管理，从而提高程序的性能。</p>
<p>移动构造函数的核心思想是：有些对象拥有动态分配的内存或其他重要资源，当这些对象被用作临时对象或即将被销毁时，它们的资源可以安全地被其他对象获取，而不需要进行昂贵的深复制操作。</p>
<p>考虑一个简单的<code>std::string</code>类似的例子。一个字符串对象内部可能有一个动态分配的字符数组。当我们要从一个临时字符串对象（或即将被销毁的字符串对象）创建一个新的字符串对象时，我们可以简单地将原对象的内存指针移动到新对象，而不是复制整个字符数组。</p>
<p>以下是一个简化版的字符串类，展示了移动构造函数的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">size_t</span> length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 其他构造函数和成员函数 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">SimpleString</span>(SimpleString&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">data</span>(other.data), <span class="built_in">length</span>(other.length) &#123;</span><br><span class="line">        <span class="comment">// 使原对象不再指向这块内存</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        other.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他成员函数 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，移动构造函数接受一个右值引用<code>SimpleString&amp;&amp;</code>，然后直接获取原字符串对象的内部指针，并将原对象的指针设置为<code>nullptr</code>，这样原对象在销毁时就不会释放这块内存。</p>
<p>值得注意的是，移动构造函数通常应该被标记为<code>noexcept</code>，因为它们经常用于容器的重新分配操作，而容器需要知道这些操作不会抛出异常。</p>
<p>总之，移动构造函数为C++提供了一个优化资源管理和对象创建的机制，特别是在涉及大量临时对象和资源转移的场景中。</p>
<h2 id="C-中的explicit关键字的作用"><a href="#C-中的explicit关键字的作用" class="headerlink" title="C++中的explicit关键字的作用"></a>C++中的explicit关键字的作用</h2><p>在C++中，<code>explicit</code>关键字是用来修饰构造函数的，确保该构造函数不会在不明确的情况下进行隐式类型转换。它的主要目的是防止意外的类型转换导致的错误。</p>
<p>为了更好地理解，让我们看一个例子。假设你有一个<code>Box</code>类，该类有一个接受整数参数的构造函数，表示盒子的大小：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        <span class="comment">// ... 实现 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayBox</span><span class="params">(<span class="type">const</span> Box&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 显示盒子 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你没有使用<code>explicit</code>关键字，你可能会意外地这样使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">displayBox</span>(<span class="number">42</span>);  <span class="comment">// 隐式地将int转换为Box</span></span><br></pre></td></tr></table></figure>

<p>在上述情况下，整数<code>42</code>被隐式地转换为一个<code>Box</code>对象，因为<code>Box</code>的构造函数允许这样的转换。</p>
<p>但是，这种隐式转换可能并不总是你期望的，尤其是在上述情境中，这种转换可能不够直观或容易引发错误。</p>
<p>为了防止这种隐式转换，你可以使用<code>explicit</code>关键字：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Box</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 实现 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，以下代码就会引发编译错误，因为不允许隐式类型转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">displayBox</span>(<span class="number">42</span>);  <span class="comment">// 编译错误：不能隐式地将int转换为Box</span></span><br></pre></td></tr></table></figure>

<p>要使用<code>Box</code>构造函数，你必须明确地进行转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">displayBox</span>(<span class="built_in">Box</span>(<span class="number">42</span>));  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>总之，<code>explicit</code>关键字用于防止可能导致误解或错误的隐式类型转换。使用这个关键字可以使你的代码更安全、更清晰。</p>
<h2 id="std-ostream-amp-是什么"><a href="#std-ostream-amp-是什么" class="headerlink" title="std::ostream&amp;是什么"></a><code>std::ostream&amp;</code>是什么</h2><p><code>std::ostream</code>是C++标准库中的一个重要类，它属于C++的输入&#x2F;输出流库。<code>std::ostream</code>主要用于数据的输出操作，例如将数据写入到屏幕（通过<code>std::cout</code>）或写入到文件（通过<code>std::ofstream</code>对象）。</p>
<p>在你给出的代码中，<code>std::ostream&amp;</code>是一个对<code>std::ostream</code>对象的引用。当一个函数接受一个<code>std::ostream&amp;</code>作为参数，这意味着你可以传递任何<code>std::ostream</code>对象（或其派生类的对象）到该函数，如<code>std::cout</code>（用于控制台输出）或<code>std::ofstream</code>对象（用于文件输出）。</p>
<p>使用引用参数允许函数直接在提供的流上操作，而不是复制它。这也意味着在函数内部对流所做的任何操作（例如写入数据）都会直接影响到传递给它的实际流对象。</p>
<p>在<code>TextFormatter</code>类的<code>format</code>方法中，<code>std::ostream&amp;</code>参数通常用于指定输出的目标，无论是屏幕、文件还是其他输出媒介。</p>
<h2 id="Graphviz是什么"><a href="#Graphviz是什么" class="headerlink" title="Graphviz是什么"></a>Graphviz是什么</h2><p>Graphviz（Graph Visualization Software）是一个开源的图形可视化软件包。它用于表示结构化信息为图形和网络图。其核心组件是<code>dot</code>语言，这是一种简单的描述图的文本语言，以及众多的工具，如<code>dot</code>、<code>neato</code>、<code>twopi</code>、<code>circo</code>等，这些工具可以根据<code>dot</code>语言描述的图生成各种格式的可视化输出。</p>
<p>以下是一个简单的DOT语言示例，描述了一个有向图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">digraph G &#123;</span><br><span class="line">    A -&gt; B;</span><br><span class="line">    B -&gt; C;</span><br><span class="line">    A -&gt; C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这描述了一个有三个节点（A、B和C）和三条边的图。</p>
<p>Graphviz的主要优点之一是其自动布局功能，它能够自动计算图中节点的位置，使得图看起来整洁，并突出显示图的结构，而不需要手动调整每个节点的位置。</p>
<p>在很多应用场景中，Graphviz都非常有用，例如编译器优化的数据流分析、网络结构可视化、软件的依赖关系分析等。</p>
<h2 id="ubuntu命令行打开图片"><a href="#ubuntu命令行打开图片" class="headerlink" title="ubuntu命令行打开图片"></a>ubuntu命令行打开图片</h2><p>打开图片：<br>解决办法：ubuntu系统中图片有对应的默认打开程序，所以鼠标双击就可以打开图片，命令行中如果想打开图片，只要使用图片默认的程序去打开它就可以了。ubuntu提供一个命令xdg-open，此命令后面接你想打开的文件、图片、视频、音乐等，都可以。此命令就会使用默认的程序去打开后面接的文件。比如图片名为xxx.jpg，那么在命令行中输入:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xdg-open xxx.jpg</span><br></pre></td></tr></table></figure>

<p>详情请见：<a href="https://blog.csdn.net/weixin_44493841/article/details/106093697">ubuntu中命令打开图片、文档、音乐、视频等_在ubuntu中输入命令显示图片-CSDN博客</a></p>
<h2 id="解释并举例C-中的复制构造函数、移动构造函数、复制赋值运算符、移动赋值运算符和析构函数。"><a href="#解释并举例C-中的复制构造函数、移动构造函数、复制赋值运算符、移动赋值运算符和析构函数。" class="headerlink" title="解释并举例C++中的复制构造函数、移动构造函数、复制赋值运算符、移动赋值运算符和析构函数。"></a>解释并举例C++中的复制构造函数、移动构造函数、复制赋值运算符、移动赋值运算符和析构函数。</h2><p>当然可以！</p>
<p><strong>1. 复制构造函数 (Copy Constructor)</strong><br>用于初始化一个对象为另一个对象的副本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="comment">// ... copy the contents from &#x27;other&#x27; to &#x27;this&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>举例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyClass a;</span><br><span class="line"><span class="function">MyClass <span class="title">b</span><span class="params">(a)</span></span>;  <span class="comment">// 使用复制构造函数</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 移动构造函数 (Move Constructor)</strong><br>用于“窃取”一个对象的资源，而非复制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="comment">// ... move the contents from &#x27;other&#x27; to &#x27;this&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>举例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyClass a;</span><br><span class="line"><span class="function">MyClass <span class="title">b</span><span class="params">(std::move(a))</span></span>;  <span class="comment">// 使用移动构造函数</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 复制赋值运算符 (Copy Assignment Operator)</strong><br>当为一个已存在的对象赋值时使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="comment">// ... copy the contents from &#x27;other&#x27; to &#x27;this&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>举例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyClass a, b;</span><br><span class="line">a = b;  <span class="comment">// 使用复制赋值运算符</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 移动赋值运算符 (Move Assignment Operator)</strong><br>当为一个已存在的对象赋予另一个对象的资源时使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="comment">// ... move the contents from &#x27;other&#x27; to &#x27;this&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>举例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyClass a, b;</span><br><span class="line">a = std::<span class="built_in">move</span>(b);  <span class="comment">// 使用移动赋值运算符</span></span><br></pre></td></tr></table></figure>

<p><strong>5. 析构函数 (Destructor)</strong><br>当一个对象不再被使用并需要被销毁时调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// ... release any resources or cleanup</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>举例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    MyClass a;  <span class="comment">// 当离开这个范围时，a的析构函数将被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，为了实现资源安全的管理，通常使用规则：五&#x2F;三&#x2F;零，即如果你定义了移动构造函数或移动赋值运算符，你应该考虑定义所有五个；如果不需要移动语义，定义复制构造函数和复制赋值运算符；如果一个类不需要自定义析构函数、复制&#x2F;move操作，那么最好全部都不定义，使用编译器自动生成的版本。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的function-cpp文件中的Function-create函数"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的function-cpp文件中的Function-create函数" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的function.cpp文件中的Function::create函数"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的function.cpp文件中的Function::create函数</h2><p>当然可以。<code>Function::create</code>是<code>ikos::ar::Function</code>类的一个静态工厂方法。这种方法通常用于创建对象，同时隐藏实例化对象的复杂性。我们来详细分析它。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Function* <span class="title">Function::create</span><span class="params">(Bundle* bundle,</span></span></span><br><span class="line"><span class="params"><span class="function">                           FunctionType* type,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::string name,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">bool</span> is_definition,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Intrinsic::ID intrinsic_id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> fun =</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Function</span>(bundle, type, std::<span class="built_in">move</span>(name), is_definition, intrinsic_id);</span><br><span class="line">  bundle-&gt;<span class="built_in">add_function</span>(std::<span class="built_in">unique_ptr</span>&lt; Function &gt;(fun));</span><br><span class="line">  <span class="keyword">return</span> fun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是对该方法的逐步分析：</p>
<ol>
<li><p><strong>方法定义</strong>：此方法定义表示我们希望创建并返回一个指向<code>Function</code>对象的指针。</p>
<ul>
<li><code>Bundle* bundle</code>: 表示该函数所属的”bundle”的指针。</li>
<li><code>FunctionType* type</code>: 函数的类型。</li>
<li><code>std::string name</code>: 函数的名称。</li>
<li><code>bool is_definition</code>: 这是一个布尔标志，用于表示该函数是否是一个定义（相对于只是一个声明）。</li>
<li><code>Intrinsic::ID intrinsic_id</code>: 表示内置函数ID的枚举值。</li>
</ul>
</li>
<li><p><strong>创建<code>Function</code>对象</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun = <span class="keyword">new</span> <span class="built_in">Function</span>(bundle, type, std::<span class="built_in">move</span>(name), is_definition, intrinsic_id);</span><br></pre></td></tr></table></figure>
<p>这里我们使用<code>new</code>关键字动态地分配一个新的<code>Function</code>对象。同时，我们通过<code>std::move(name)</code>移动语义来传递<code>name</code>字符串，这样可以优化性能，避免不必要的字符串拷贝。</p>
</li>
<li><p>**添加函数到<code>Bundle</code>**：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bundle-&gt;<span class="built_in">add_function</span>(std::<span class="built_in">unique_ptr</span>&lt; Function &gt;(fun));</span><br></pre></td></tr></table></figure>
<p>这里，我们将新创建的函数对象添加到给定的”bundle”中。为了管理这个动态创建的函数对象的生命周期，我们将它封装在<code>std::unique_ptr</code>中，这是一个智能指针，当其超出作用域时，它会自动删除所指向的对象。</p>
</li>
<li><p><strong>返回创建的<code>Function</code>对象的指针</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> fun;</span><br></pre></td></tr></table></figure>
<p>虽然我们已经把<code>Function</code>对象的所有权交给了<code>std::unique_ptr</code>，但我们仍然返回一个裸指针给调用者，以便他们可以与新创建的对象互动。需要注意的是，这种方式存在一定的风险，因为调用者可能误认为他们需要删除返回的指针。然而，由于所有权已经被<code>unique_ptr</code>管理，所以实际上调用者不应该删除这个指针。</p>
</li>
</ol>
<p>总的来说，<code>Function::create</code>方法提供了一个创建、初始化并添加<code>Function</code>对象到相应”bundle”的方式，同时确保其生命周期得到恰当的管理。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的Function-cpp中的Function-set-name函数"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的Function-cpp中的Function-set-name函数" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的Function.cpp中的Function::set_name函数"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的Function.cpp中的Function::set_name函数</h2><p>当然可以。让我们来详细分析和解释<code>Function::set_name</code>方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function::set_name</span><span class="params">(std::string new_name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// In this case, we need to notify the bundle,</span></span><br><span class="line">  <span class="comment">// because it keeps a map from name to functions</span></span><br><span class="line">  <span class="built_in">ikos_assert_msg</span>(!new_name.<span class="built_in">empty</span>(), <span class="string">&quot;name is empty&quot;</span>);</span><br><span class="line">  std::string prev_name = <span class="keyword">this</span>-&gt;<span class="built_in">name</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!new_name.<span class="built_in">empty</span>() &amp;&amp; <span class="keyword">this</span>-&gt;_parent-&gt;<span class="built_in">is_name_available</span>(new_name)) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_name = std::<span class="built_in">move</span>(new_name);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_name = <span class="keyword">this</span>-&gt;_parent-&gt;<span class="built_in">find_available_name</span>(new_name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;_parent-&gt;<span class="built_in">rename_function</span>(<span class="keyword">this</span>, prev_name, <span class="keyword">this</span>-&gt;_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是对该方法的逐步分析：</p>
<ol>
<li><p><strong>方法定义</strong>:<br><code>Function::set_name</code>方法接受一个<code>std::string</code>类型参数<code>new_name</code>，用于为<code>Function</code>对象设置一个新名称。</p>
</li>
<li><p><strong>断言检查</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ikos_assert_msg</span>(!new_name.<span class="built_in">empty</span>(), <span class="string">&quot;name is empty&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>使用<code>ikos_assert_msg</code>进行断言，确保传入的<code>new_name</code>不是空的。</p>
</li>
<li><p><strong>保存当前名称</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string prev_name = <span class="keyword">this</span>-&gt;<span class="built_in">name</span>();</span><br></pre></td></tr></table></figure>
<p>在修改名称之前，首先保存当前的函数名称，以便稍后在通知”_parent”（即”bundle”）时使用。</p>
</li>
<li><p><strong>检查新名称的可用性</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!new_name.<span class="built_in">empty</span>() &amp;&amp; <span class="keyword">this</span>-&gt;_parent-&gt;<span class="built_in">is_name_available</span>(new_name)) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_name = std::<span class="built_in">move</span>(new_name);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_name = <span class="keyword">this</span>-&gt;_parent-&gt;<span class="built_in">find_available_name</span>(new_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码首先检查<code>new_name</code>是否非空，并通过<code>is_name_available</code>方法询问”_parent”（即”bundle”）该名称是否可用。如果名称可用，它将使用移动语义将<code>new_name</code>赋值给<code>_name</code>，以优化性能并避免不必要的字符串拷贝。如果名称不可用，它会通过<code>find_available_name</code>方法获取一个可用的名称。</p>
</li>
<li><p><strong>通知”_parent”（即”bundle”）</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;_parent-&gt;<span class="built_in">rename_function</span>(<span class="keyword">this</span>, prev_name, <span class="keyword">this</span>-&gt;_name);</span><br></pre></td></tr></table></figure>
<p><code>_parent</code>（即”bundle”）似乎维护了一个从函数名称到函数的映射。因此，当函数的名称发生变化时，需要通知其”_parent”，以更新这个映射。<code>rename_function</code>方法可能会负责这个更新任务，它需要知道函数对象、之前的名称和新的名称。</p>
</li>
</ol>
<p>总的来说，<code>Function::set_name</code>方法允许你为<code>Function</code>对象重新命名，并确保与其关联的”_parent”（即”bundle”）更新其内部的映射，以保持一致性。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的bundle-cpp文件的Bundle类的作用"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的bundle-cpp文件的Bundle类的作用" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的bundle.cpp文件的Bundle类的作用"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的bundle.cpp文件的Bundle类的作用</h2><p><code>ikos::ar::Bundle</code>类在<code>ikos</code>中代表了一个程序或模块的顶级容器。在许多编译器框架和程序分析工具中，这种顶级容器的概念很常见，例如在LLVM中的<code>Module</code>。以下是<code>Bundle</code>类的主要功能和作用：</p>
<ol>
<li><p><strong>容纳函数和全局变量</strong>：<code>Bundle</code>充当了存放全局变量和函数定义的容器。从提供的源代码中可以看出，<code>Bundle</code>类提供了方法来添加、查找和重命名函数和全局变量。</p>
</li>
<li><p><strong>管理名称空间</strong>：<code>Bundle</code>提供了一些方法，如<code>is_name_available</code>和<code>find_available_name</code>，来确保函数和全局变量的名称在整个<code>Bundle</code>中是唯一的。</p>
</li>
<li><p><strong>管理内建函数（Intrinsics）</strong>：<code>Bundle</code>提供了<code>intrinsic_function</code>方法来获取或创建特定的内建函数。内建函数通常是编译器或分析工具中预定义的特殊函数，它们具有特定的行为或用途。</p>
</li>
<li><p><strong>持有数据布局和目标三元组信息</strong>：构造函数接受一个<code>DataLayout</code>和一个目标三元组<code>triple</code>。<code>DataLayout</code>可能描述了目标架构的数据布局信息，如字节顺序、整数大小等。目标三元组通常描述了目标平台的信息，例如其架构、供应商和操作系统。</p>
</li>
</ol>
<p>总的来说，<code>ikos::ar::Bundle</code>类是整个程序分析表示（Program Analysis Representation, AR）的根，存储了所有的全局变量、函数、以及与目标平台相关的信息。这使得分析工具可以在一个集中的位置访问和处理整个程序的信息。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的bundle-cpp文件提供的intrinsic-function函数"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的bundle-cpp文件提供的intrinsic-function函数" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的bundle.cpp文件提供的intrinsic_function函数"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的bundle.cpp文件提供的intrinsic_function函数</h2><p>当然可以。从您提供的<code>bundle.cpp</code>文件中，我们可以看到<code>Bundle</code>类提供了两个<code>intrinsic_function</code>方法。以下是这两个方法的分析：</p>
<h3 id="1-Function-Bundle-intrinsic-function-Intrinsic-ID-id"><a href="#1-Function-Bundle-intrinsic-function-Intrinsic-ID-id" class="headerlink" title="1. Function* Bundle::intrinsic_function(Intrinsic::ID id)"></a>1. <code>Function* Bundle::intrinsic_function(Intrinsic::ID id)</code></h3><p><strong>参数</strong>：</p>
<ul>
<li><code>Intrinsic::ID id</code>: 一个枚举类型，表示特定的内建函数。</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li>首先，该方法使用<code>Intrinsic::long_name(id)</code>来获取内建函数的名称。</li>
<li>然后，它尝试在当前的<code>Bundle</code>中查找这个名称的函数。</li>
<li>如果找到，它就直接返回这个函数。</li>
<li>如果没有找到，它会使用<code>Intrinsic::type(this, id)</code>来获取函数的类型，并使用<code>Function::create</code>方法来创建一个新的函数，并添加到<code>Bundle</code>中。</li>
</ul>
<h3 id="2-Function-Bundle-intrinsic-function-Intrinsic-ID-id-Type-template-ty"><a href="#2-Function-Bundle-intrinsic-function-Intrinsic-ID-id-Type-template-ty" class="headerlink" title="2. Function* Bundle::intrinsic_function(Intrinsic::ID id, Type* template_ty)"></a>2. <code>Function* Bundle::intrinsic_function(Intrinsic::ID id, Type* template_ty)</code></h3><p><strong>参数</strong>：</p>
<ul>
<li><code>Intrinsic::ID id</code>: 一个枚举类型，表示特定的内建函数。</li>
<li><code>Type* template_ty</code>: 一个额外的类型参数，某些内建函数可能会需要它。</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li>类似于上一个方法，但是这个版本考虑了额外的类型参数<code>template_ty</code>。</li>
<li>使用<code>Intrinsic::long_name(id, template_ty)</code>来获取带有类型参数的内建函数的名称。</li>
<li>然后进行相同的查找或创建函数的操作。</li>
</ul>
<p><strong>总结</strong>：<br><code>intrinsic_function</code>方法允许用户在<code>Bundle</code>中获取或创建特定的内建函数。这些内建函数在编译器和程序分析工具中通常是预定义的，并且它们具有特定的预期行为。例如，某些内建函数可能会表示特定的数学操作、内存操作或其他特殊的行为。</p>
<p>这两个版本的方法基本上执行相同的逻辑，只是其中一个版本额外处理了类型参数。这种模式在编译器和程序分析工具中很常见，因为一些内建函数可能会根据不同的类型参数有不同的行为或表示。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-ar-x2F-semantic-目录下的instrinc-hpp文件分析"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-ar-x2F-semantic-目录下的instrinc-hpp文件分析" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;ar&#x2F;semantic 目录下的instrinc.hpp文件分析"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;ar&#x2F;semantic 目录下的instrinc.hpp文件分析</h2><p><code>ikos::ar::Intrinsic</code>类在<code>ikos</code>中似乎是用来管理和访问内建函数的。这些内建函数为编译器或分析工具提供了特定的、预定义的功能。</p>
<p>以下是对该类定义的详细分析：</p>
<h3 id="1-枚举Intrinsic-ID"><a href="#1-枚举Intrinsic-ID" class="headerlink" title="1. 枚举Intrinsic::ID"></a>1. 枚举<code>Intrinsic::ID</code></h3><p>这是一个枚举类型，定义了所有可用的内建函数。从列表中我们可以看到，这些函数大致可以分为几个分类：</p>
<ul>
<li>IKOS特定的内建函数：如<code>IkosAssert</code>、<code>IkosAssume</code>等。</li>
<li>Libc函数：这些是C标准库函数的表示，如<code>LibcMalloc</code>、<code>LibcFree</code>、<code>LibcPrintf</code>等。</li>
<li>Libcpp函数：这些代表C++库函数，如<code>LibcppNew</code>和<code>LibcppDelete</code>。</li>
</ul>
<h3 id="2-常量Prefix"><a href="#2-常量Prefix" class="headerlink" title="2. 常量Prefix"></a>2. 常量<code>Prefix</code></h3><p>定义了内建函数名称的前缀，其值为<code>&quot;ar.&quot;</code>。</p>
<h3 id="3-类方法"><a href="#3-类方法" class="headerlink" title="3. 类方法"></a>3. 类方法</h3><ul>
<li><p><code>FunctionType* type(Bundle*, ID)</code>: 从内建函数的ID获取其类型。</p>
</li>
<li><p><code>FunctionType* type(Bundle*, ID, Type*)</code>: 对于需要类型参数的内建函数，获取其类型。</p>
</li>
<li><p><code>std::string short_name(ID)</code>: 根据内建函数的ID获取其简短名称。</p>
</li>
<li><p><code>std::string short_name(ID, Type*)</code>: 对于需要类型参数的内建函数，获取其简短名称。</p>
</li>
<li><p><code>std::string long_name(ID)</code>: 根据内建函数的ID获取其完整名称，这通常是简短名称与前缀的组合。</p>
</li>
<li><p><code>std::string long_name(ID, Type*)</code>: 对于需要类型参数的内建函数，获取其完整名称。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>ikos::ar::Intrinsic</code>类为<code>ikos</code>提供了一种方法来识别、访问和管理内建函数。这些函数是预定义的，并且在编译或分析期间具有特定的预期行为。通过这个类，工具可以轻松地查询和使用这些函数，无需每次都定义它们。</p>
<p>该类还提供了方法来获取内建函数的名称和类型，这使得工具可以在不知道特定内建函数的确切信息的情况下与其交互。</p>
<p>如果您有关于这个类或其他方面的任何其他问题，请告诉我。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的intrinsic-hpp文件中的Intrinsic类也包含分类"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的intrinsic-hpp文件中的Intrinsic类也包含分类" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的intrinsic.hpp文件中的Intrinsic类也包含分类"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的intrinsic.hpp文件中的Intrinsic类也包含分类</h2><p>是的，<code>Intrinsic</code>类中的<code>ID</code>枚举确实有分类，我们可以从枚举值的命名看到。以下是这些分类的简要说明：</p>
<ol>
<li><p><strong>IKOS特定的内建函数</strong>：</p>
<ul>
<li>由<code>_BeginIkosIntrinsic</code>和<code>_EndIkosIntrinsic</code>包围。</li>
<li>这些内建函数与IKOS的分析功能直接相关，例如<code>IkosAssert</code>、<code>IkosAssume</code>和<code>IkosNonDet</code>。</li>
</ul>
</li>
<li><p><strong>Libc函数</strong>：</p>
<ul>
<li>由<code>_BeginLibcIntrinsic</code>和<code>_EndLibcIntrinsic</code>包围。</li>
<li>这些函数代表C语言标准库中的函数。例如，<code>LibcMalloc</code>、<code>LibcFree</code>和<code>LibcPrintf</code>。</li>
<li>它们覆盖了各种标准C库功能，包括内存管理、文件I&#x2F;O、字符串处理等。</li>
</ul>
</li>
<li><p><strong>Libcpp函数</strong>：</p>
<ul>
<li>由<code>_BeginLibcppIntrinsic</code>和<code>_EndLibcppIntrinsic</code>包围。</li>
<li>这些函数代表C++标准库中的功能，如<code>LibcppNew</code>、<code>LibcppDelete</code>，以及异常处理函数如<code>LibcppThrow</code>和<code>LibcppBeginCatch</code>。</li>
</ul>
</li>
</ol>
<p>这种分类方式提供了一种结构化的方法来组织和理解这些内建函数，这对于开发者和用户来说都是有用的，因为它们可以根据功能或用途快速找到特定的内建函数。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的intrinsic-cpp文件中的template-ty是什么"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的intrinsic-cpp文件中的template-ty是什么" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的intrinsic.cpp文件中的template_ty是什么"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的intrinsic.cpp文件中的template_ty是什么</h2><p>在您给出的代码片段和函数签名<code>std::string Intrinsic::short_name(ID id, Type* template_ty)</code>中，<code>template_ty</code>是一个指向<code>Type</code>的指针。从名字和上下文来看，这个参数可能是用来表示某些内建函数短名称中的模板类型。</p>
<p>例如，前面的列表中有像<code>ikos.nondet.(type)</code>这样的短名称。在这里，<code>(type)</code>可能是一个占位符，它将根据<code>template_ty</code>的实际类型来替换。假设<code>Type</code>类可以代表例如<code>int</code>、<code>float</code>等类型，那么<code>ikos.nondet.(type)</code>可能会被替换为<code>ikos.nondet.int</code>、<code>ikos.nondet.float</code>等。</p>
<p>这样的设计可以让内建函数名字更具描述性，同时根据实际类型动态生成。在处理涉及模板或泛型的情况时，这样的设计是非常有用的。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的intrinsic-cpp文件中的case-IkosNonDet是什么"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的intrinsic-cpp文件中的case-IkosNonDet是什么" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的intrinsic.cpp文件中的case IkosNonDet是什么"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的intrinsic.cpp文件中的case IkosNonDet是什么</h2><p>这行代码是<code>Intrinsic::short_name</code>函数中的一部分，它是处理<code>IkosNonDet</code>情况的。</p>
<p><code>IkosNonDet</code>似乎代表某种不确定的或非确定性的内建函数。当需要为这种函数生成短名称时，这个代码片段会根据提供的<code>template_ty</code>（一个代表某种类型的<code>Type</code>指针）生成名称。</p>
<p>函数<code>template_type_name(template_ty)</code>会返回<code>template_ty</code>的短名称字符串。这个名称随后会被拼接到<code>&quot;ikos.nondet.&quot;</code>字符串后面。</p>
<p>例如，如果<code>template_ty</code>代表了整数类型（假设其名称为<code>int</code>），则上述代码会返回字符串<code>&quot;ikos.nondet.int&quot;</code>。这提供了一种动态生成描述性名称的方法，该名称基于内建函数的种类以及其操作的数据类型。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-ikos-x2F-core-x2F-include-x2F-ikos-x2F-core-x2F-support目录下的assert-hpp文件"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-ikos-x2F-core-x2F-include-x2F-ikos-x2F-core-x2F-support目录下的assert-hpp文件" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;ikos&#x2F;core&#x2F;include&#x2F;ikos&#x2F;core&#x2F;support目录下的assert.hpp文件"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;ikos&#x2F;core&#x2F;include&#x2F;ikos&#x2F;core&#x2F;support目录下的assert.hpp文件</h2><p>这个<code>assert.hpp</code>文件定义了三个宏：<code>ikos_assert</code>、<code>ikos_assert_msg</code> 和 <code>ikos_unreachable</code>。这些宏的主要目的是帮助开发者在调试模式下检测问题，并在发布模式下确保没有额外的运行时开销。</p>
<ol>
<li><p><strong>ikos_assert(expr)</strong>: 这个宏用于断言一个表达式为真。如果在调试模式下（即NDEBUG未定义）该表达式为假，程序将中断。在发布模式下，这个宏没有任何效果。</p>
</li>
<li><p><strong>ikos_assert_msg(expr, msg)</strong>: 这个宏与<code>ikos_assert</code>相似，但它还允许您提供一个错误消息。如果表达式为假，那么这个消息将与错误一起显示。同样，在发布模式下，这个宏没有任何效果。</p>
</li>
<li><p><strong>ikos_unreachable(msg)</strong>: 这个宏标记了不应该达到的代码位置。如果这个位置被达到了，那么在调试模式下，它会导致一个断言失败。在发布模式下，根据编译器的支持，它可能会提供一个优化器提示，表示当前位置不可达，或者调用abort()函数来中断程序。</p>
</li>
</ol>
<p>当NDEBUG宏被定义（通常在发布模式下），<code>ikos_assert</code>和<code>ikos_assert_msg</code>宏的实际效果就是不执行任何操作。而<code>ikos_unreachable</code>宏则可能提供一个给优化器的提示或调用abort()函数，具体取决于编译器的支持。</p>
<p>在调试模式下，这些宏使用了标准的<code>assert</code>函数来实现其断言功能。</p>
<h2 id="undef怎么用"><a href="#undef怎么用" class="headerlink" title="#undef怎么用"></a>#undef怎么用</h2><p><code>#undef</code> 是 C 和 C++ 预处理器的一个指令，用于取消之前定义的宏。这意味着，当你使用 <code>#undef</code> 指令后，该宏的定义将被移除，它将不再是一个已定义的宏，直到再次被 <code>#define</code> 定义。</p>
<p>这里是一个简单的 <code>#undef</code> 使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MACRO 100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; MY_MACRO &lt;&lt; std::endl; <span class="comment">// 输出 100</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> MY_MACRO</span></span><br><span class="line">    <span class="comment">// 此时，MY_MACRO 不再被定义</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的代码将会引发编译错误，因为 MY_MACRO 已经未定义</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; MY_MACRO &lt;&lt; std::endl;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> MY_MACRO 200</span></span><br><span class="line">    std::cout &lt;&lt; MY_MACRO &lt;&lt; std::endl; <span class="comment">// 输出 200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>#undef</code> 的常见用途：</p>
<ol>
<li><strong>移除宏定义</strong>：有时，为了确保某个宏不会与其他代码冲突，或者确保在某个特定的区域中，该宏没有定义，你可能希望取消它的定义。</li>
<li><strong>重新定义宏</strong>：如果你想给一个宏赋予一个新的值或定义，你首先需要取消它的原始定义，然后再重新定义它。</li>
</ol>
<p>请注意，经常使用 <code>#undef</code> 可能会使代码难以阅读和维护，因为它可能会导致预期之外的宏行为，所以应该谨慎使用。</p>
<h2 id="ifndef怎么用"><a href="#ifndef怎么用" class="headerlink" title="#ifndef怎么用"></a>#ifndef怎么用</h2><p><code>#ifndef</code> 是 C 和 C++ 预处理器的一个指令，它用于检查一个宏是否未被定义。如果该宏未被定义，则执行后续的预处理器指令，直到遇到对应的 <code>#endif</code>。</p>
<p><code>#ifndef</code> 常常与 <code>#define</code> 一起使用，来避免头文件的多重包含。这种方法被称为 “include guards” 或 “header guards”。</p>
<p>下面是如何使用 <code>#ifndef</code> 的一个简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件：example_header.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXAMPLE_HEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_HEADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件的内容</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">my_function</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// EXAMPLE_HEADER_H</span></span></span><br></pre></td></tr></table></figure>

<p>这里的工作原理是：</p>
<ol>
<li>当这个头文件第一次被包含时，<code>EXAMPLE_HEADER_H</code> 还没有定义，所以 <code>#ifndef EXAMPLE_HEADER_H</code> 为真，预处理器会继续处理直到 <code>#endif</code>。</li>
<li>在这个过程中，<code>#define EXAMPLE_HEADER_H</code> 将会执行，这样 <code>EXAMPLE_HEADER_H</code> 就被定义了。</li>
<li>如果在后面的代码中再次包含这个头文件，<code>EXAMPLE_HEADER_H</code> 已经被定义，因此 <code>#ifndef EXAMPLE_HEADER_H</code> 为假，预处理器就会跳过整个块，直到 <code>#endif</code>。</li>
</ol>
<p>这种方法有效地避免了由于多次包含相同的头文件而导致的重复定义。</p>
<h2 id="ifdef怎么用"><a href="#ifdef怎么用" class="headerlink" title="#ifdef怎么用"></a>#ifdef怎么用</h2><p><code>#ifdef</code> 是 C 和 C++ 预处理器的一个指令，用于检查一个宏是否已经被定义。如果该宏已定义，那么 <code>#ifdef</code> 和其后的代码（直到相应的 <code>#endif</code>）之间的代码将会被包含在编译中。否则，该段代码会被忽略。</p>
<p>以下是一个简单的使用 <code>#ifdef</code> 的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USE_HELLO</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> USE_HELLO</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hi, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，因为宏 <code>USE_HELLO</code> 已经被定义，所以程序将输出 “Hello, World!”。如果你注释掉 <code>#define USE_HELLO</code> 这一行，程序则会输出 “Hi, World!”。</p>
<p><code>#ifdef</code> 的常见用途：</p>
<ol>
<li><p><strong>平台或编译器特定的代码</strong>：可以根据不同的平台或编译器定义不同的宏，然后使用 <code>#ifdef</code> 来编写特定于该平台或编译器的代码。</p>
</li>
<li><p><strong>功能切换</strong>：在开发过程中，你可能想要在不同的版本或构建选项之间切换某些功能。通过定义或不定义某个宏，可以轻松地启用或禁用特定的代码段。</p>
</li>
<li><p><strong>头文件保护</strong>：为了防止一个头文件被多次包含，可以使用 <code>#ifdef</code>、<code>#define</code> 和 <code>#endif</code> 的组合来确保头文件的内容只被包含一次。</p>
</li>
</ol>
<p>除了 <code>#ifdef</code>，还有 <code>#ifndef</code> 指令，它的作用是检查一个宏是否<em>没有</em>被定义。如果该宏未定义，那么 <code>#ifndef</code> 和其后的代码（直到相应的 <code>#endif</code>）之间的代码将会被包含在编译中。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-ikos-x2F-ar-x2F-include-x2F-ikos-x2F-semantic-目录下的type-hpp文件"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-ikos-x2F-ar-x2F-include-x2F-ikos-x2F-semantic-目录下的type-hpp文件" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;ikos&#x2F;ar&#x2F;include&#x2F;ikos&#x2F;semantic 目录下的type.hpp文件"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;ikos&#x2F;ar&#x2F;include&#x2F;ikos&#x2F;semantic 目录下的type.hpp文件</h2><p>这是<code>type.hpp</code>文件的内容概要，它定义了IKOS (Interval-based Klee Open Solver) 中的各种类型。</p>
<ol>
<li><p><strong>头文件和前置声明</strong>:</p>
<ul>
<li>包含了标准库头文件、其他IKOS组件等。</li>
<li>定义了一些前置声明，比如<code>Bundle</code>和<code>Context</code>。</li>
</ul>
</li>
<li><p><strong>FloatSemantic枚举</strong>: 描述了不同的浮点数语义，如半精度、单精度、双精度等。</p>
</li>
<li><p><strong>Type类</strong>:</p>
<ul>
<li>基类，表示所有类型。</li>
<li>定义了类型的各种种类，如整型、浮点型、指针类型、结构体类型等。</li>
<li>提供了一系列的方法来查询特定类型的信息。</li>
</ul>
</li>
<li><p><strong>VoidType类</strong>: 表示C语言中的<code>void</code>类型。</p>
</li>
<li><p><strong>ScalarType类</strong>: 表示标量类型的基类，如整型、浮点型和指针。</p>
</li>
<li><p><strong>IntegerType类</strong>: </p>
<ul>
<li>表示整数类型。</li>
<li>除了基本的整数类型，还支持不同的位宽和符号性。</li>
</ul>
</li>
<li><p><strong>FloatType类</strong>: 表示浮点类型，支持不同的浮点语义。</p>
</li>
<li><p><strong>PointerType类</strong>: 表示指针类型，具有指向的类型属性。</p>
</li>
<li><p><strong>AggregateType类</strong>: 是StructType, ArrayType, VectorType和OpaqueType的基类。</p>
</li>
<li><p><strong>StructType类</strong>:</p>
</li>
</ol>
<ul>
<li>表示结构体类型。</li>
<li>可以包含多个字段，每个字段有一个偏移量和一个类型。</li>
</ul>
<ol start="11">
<li><p><strong>SequentialType类</strong>: 是数组和向量类型的基类。</p>
</li>
<li><p><strong>ArrayType类</strong>: 表示数组类型。</p>
</li>
<li><p><strong>VectorType类</strong>: 表示向量类型。</p>
</li>
<li><p><strong>OpaqueType类</strong>: 表示不透明类型，主要用于表示C中的前向声明结构。</p>
</li>
<li><p><strong>FunctionType类</strong>: 表示函数类型，具有返回类型和参数类型。</p>
</li>
</ol>
<p>这个文件为IKOS提供了一个类型系统，可以表示大多数在中间表示(IR)中常见的类型。这些类型包括标量类型、聚合类型(如结构体和数组)以及函数类型。</p>
<p>这是一个C++项目中的类型定义文件，其中包含了一些类和枚举用于表示不同类型的数据。</p>
<ol>
<li><p><strong>FloatSemantic 枚举</strong>:</p>
<ul>
<li>包括 Half, Float, Double, X86_FP80, FP128, PPC_FP128，表示浮点数的语义。</li>
</ul>
</li>
<li><p><strong>Type 类</strong>:</p>
<ul>
<li>是所有类型的基类，包括了各种类型的共同特性和方法。</li>
</ul>
</li>
<li><p><strong>TypeKind 枚举</strong>:</p>
<ul>
<li>定义了不同类型的种类，如IntegerKind, FloatKind, PointerKind等。</li>
</ul>
</li>
<li><p><strong>各种具体类型</strong>:</p>
<ul>
<li><p><code>VoidType</code>, <code>IntegerType</code>, <code>FloatType</code>, <code>PointerType</code>, <code>StructType</code>, <code>ArrayType</code>, <code>VectorType</code>, <code>OpaqueType</code>, <code>FunctionType</code>，它们分别表示了不同种类的类型。</p>
</li>
<li><p>每种类型都有相应的构造函数和静态方法用于获取实例。</p>
</li>
<li><p>每种类型都有相应的方法用于查询其特性，比如是否是整数类型，浮点类型，指针类型等。</p>
</li>
<li><p><code>ScalarType</code> 是所有标量类型的基类，包括 <code>IntegerType</code> 和 <code>FloatType</code>。</p>
</li>
<li><p><code>AggregateType</code> 是所有聚合类型的基类，包括 <code>StructType</code>, <code>ArrayType</code>, <code>VectorType</code> 和 <code>OpaqueType</code>。</p>
</li>
<li><p><code>SequentialType</code> 是所有顺序类型的基类，包括 <code>ArrayType</code> 和 <code>VectorType</code>。</p>
</li>
<li><p><code>FunctionType</code> 表示函数类型，包括返回类型和参数类型。</p>
</li>
</ul>
</li>
<li><p><strong>Context 类</strong>:</p>
<ul>
<li>类型的创建和管理都需要一个上下文环境，<code>Context</code> 提供了相应的功能。</li>
</ul>
</li>
<li><p><strong>各种构造函数和静态方法</strong>:</p>
<ul>
<li>这些方法用于创建各种类型的实例，比如 <code>IntegerType::get</code> 用于创建整数类型的实例。</li>
</ul>
</li>
<li><p><strong>其他方法</strong>:</p>
<ul>
<li>每种类型还有一些特定的方法，如 <code>dump</code> 方法用于调试目的。</li>
</ul>
</li>
</ol>
<p>这个文件主要定义了用于表示各种类型的类和枚举，并提供了相应的方法来操作这些类型。同时也包含了一些静态方法来获取特定类型的实例。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-ikos-x2F-ar-x2F-include-x2F-ikos-x2F-semantic-目录下的type-hpp文件中的FloatType类的分析"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-ikos-x2F-ar-x2F-include-x2F-ikos-x2F-semantic-目录下的type-hpp文件中的FloatType类的分析" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;ikos&#x2F;ar&#x2F;include&#x2F;ikos&#x2F;semantic 目录下的type.hpp文件中的FloatType类的分析"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;ikos&#x2F;ar&#x2F;include&#x2F;ikos&#x2F;semantic 目录下的type.hpp文件中的FloatType类的分析</h2><p>当然可以。下面是对<code>FloatType</code>类的详细分析：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// \brief Floating point type</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Represents any floating point type, with its bit-width and semantic.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// See `FloatSemantic`.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FloatType</span> <span class="keyword">final</span> : <span class="keyword">public</span> ScalarType &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Bit width</span></span><br><span class="line">  <span class="type">uint64_t</span> _bit_width;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Float semantic</span></span><br><span class="line">  FloatSemantic _float_sem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/// \brief Private constructor</span></span><br><span class="line">  <span class="built_in">FloatType</span>(<span class="type">uint64_t</span> bit_width, FloatSemantic float_sem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// \brief Static constructor</span></span><br><span class="line">  <span class="function"><span class="type">static</span> FloatType* <span class="title">get</span><span class="params">(Context&amp; ctx, FloatSemantic float_sem)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Get the bit width</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">bit_width</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_bit_width; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Get the float semantic</span></span><br><span class="line">  <span class="function">FloatSemantic <span class="title">float_semantic</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_float_sem; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Dump the type for debugging purpose</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dump</span><span class="params">(std::ostream&amp;)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \brief Method for type support (isa, cast, dyn_cast)</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">classof</span><span class="params">(<span class="type">const</span> Type* t)</span> </span>&#123; <span class="keyword">return</span> t-&gt;<span class="built_in">kind</span>() == FloatKind; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// friends</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ContextImpl</span>;</span><br><span class="line"></span><br><span class="line">&#125;; <span class="comment">// end class FloatType</span></span><br></pre></td></tr></table></figure>

<p><code>FloatType</code>类表示浮点数类型，并从<code>ScalarType</code>类继承。</p>
<ol>
<li><p><strong>私有成员变量</strong>:</p>
<ul>
<li><code>_bit_width</code>: 一个<code>uint64_t</code>类型，表示该浮点类型的位宽。</li>
<li><code>_float_sem</code>: 一个<code>FloatSemantic</code>枚举类型，表示浮点数的语义，如单精度、双精度等。</li>
</ul>
</li>
<li><p><strong>私有构造函数</strong>:</p>
<ul>
<li><code>FloatType(uint64_t bit_width, FloatSemantic float_sem)</code>: 它是一个私有构造函数，这意味着不能直接实例化<code>FloatType</code>对象。它需要两个参数：位宽和浮点数语义。</li>
</ul>
</li>
<li><p><strong>公共方法</strong>:</p>
<ul>
<li><code>static FloatType* get(Context&amp; ctx, FloatSemantic float_sem)</code>: 静态构造函数，使用给定的浮点数语义从上下文中获取或创建一个<code>FloatType</code>对象。</li>
<li><code>uint64_t bit_width() const</code>: 返回该浮点类型的位宽。</li>
<li><code>FloatSemantic float_semantic() const</code>: 返回浮点数的语义。</li>
<li><code>void dump(std::ostream&amp;) const override</code>: 用于调试目的，将类型信息转储到输出流中。</li>
<li><code>static bool classof(const Type* t)</code>: 用于类型支持，检查给定的类型<code>t</code>是否为<code>FloatType</code>。</li>
</ul>
</li>
<li><p><strong>友元类</strong>:</p>
<ul>
<li><code>friend class ContextImpl</code>: 这使得<code>ContextImpl</code>类可以访问<code>FloatType</code>的私有和受保护的成员。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>FloatType</code>类为IKOS提供了对不同浮点数语义的支持，如半精度、单精度、双精度等，每种浮点数语义都有相应的位宽。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-ikos-x2F-ar-x2F-include-x2F-ikos-x2F-semantic-目录下的type-hpp文件中的FloatSemantic类型"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-ikos-x2F-ar-x2F-include-x2F-ikos-x2F-semantic-目录下的type-hpp文件中的FloatSemantic类型" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;ikos&#x2F;ar&#x2F;include&#x2F;ikos&#x2F;semantic 目录下的type.hpp文件中的FloatSemantic类型"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;ikos&#x2F;ar&#x2F;include&#x2F;ikos&#x2F;semantic 目录下的type.hpp文件中的FloatSemantic类型</h2><p><code>FloatSemantic</code>是一个枚举类型，用于表示浮点数的不同语义。从你给出的代码中，我们可以看到以下定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// \brief Floating point semantic</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">FloatSemantic</span> &#123; Half, Float, Double, X86_FP80, FP128, PPC_FP128 &#125;;</span><br></pre></td></tr></table></figure>

<p>下面是各个枚举值的解释：</p>
<ol>
<li><p><strong>Half</strong>: 半精度浮点数。它通常使用16位表示，其中有1位符号位、5位指数和10位尾数。</p>
</li>
<li><p><strong>Float</strong>: 单精度浮点数。它通常使用32位表示，其中有1位符号位、8位指数和23位尾数。这是C&#x2F;C++中的<code>float</code>类型。</p>
</li>
<li><p><strong>Double</strong>: 双精度浮点数。它通常使用64位表示，其中有1位符号位、11位指数和52位尾数。这是C&#x2F;C++中的<code>double</code>类型。</p>
</li>
<li><p><strong>X86_FP80</strong>: 这是x86架构特有的80位扩展精度浮点数。通常有1位符号位、15位指数和64位尾数。</p>
</li>
<li><p><strong>FP128</strong>: 128位四倍精度浮点数。具体的位分配可能因实现而异。</p>
</li>
<li><p><strong>PPC_FP128</strong>: 这是PowerPC架构特有的128位双倍精度浮点数。</p>
</li>
</ol>
<p>该枚举用于区分不同的浮点数表示，尤其是当需要确切知道浮点数的位宽和语义时，例如在代码生成、优化或分析中。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-ikos-x2F-ar-x2F-include-x2F-ikos-x2F-semantic-目录下的type-cpp中的Type-is-unsigned-integer函数"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-ikos-x2F-ar-x2F-include-x2F-ikos-x2F-semantic-目录下的type-cpp中的Type-is-unsigned-integer函数" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;ikos&#x2F;ar&#x2F;include&#x2F;ikos&#x2F;semantic 目录下的type.cpp中的Type::is_unsigned_integer函数"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;ikos&#x2F;ar&#x2F;include&#x2F;ikos&#x2F;semantic 目录下的type.cpp中的Type::is_unsigned_integer函数</h2><p>这是<code>Type</code>类中的<code>is_unsigned_integer()</code>方法的实现。该方法的目的是检查一个<code>Type</code>对象是否代表一个无符号整数类型。</p>
<p>让我们一步步地分析这个方法：</p>
<ol>
<li><p><code>isa&lt; IntegerType &gt;(this)</code>:</p>
<ul>
<li>这是一个模板函数，检查<code>this</code>对象是否是<code>IntegerType</code>类的一个实例。换句话说，它检查这个<code>Type</code>对象是否代表一个整数类型。</li>
</ul>
</li>
<li><p><code>cast&lt; IntegerType &gt;(this)-&gt;is_unsigned()</code>:</p>
<ul>
<li>如果<code>this</code>对象是一个<code>IntegerType</code>的实例，<code>cast&lt; IntegerType &gt;(this)</code>会将<code>this</code>对象安全地转换为<code>IntegerType</code>的指针。</li>
<li><code>is_unsigned()</code>是<code>IntegerType</code>类的一个方法，它检查这个整数类型是否是无符号的。</li>
</ul>
</li>
<li><p>组合上面两个表达式，我们得到：</p>
<ul>
<li>如果这个<code>Type</code>对象是一个<code>IntegerType</code>的实例，并且它是无符号的，那么这个方法返回<code>true</code>，否则返回<code>false</code>。</li>
</ul>
</li>
</ol>
<p>总之，这个方法检查给定的<code>Type</code>对象是否代表一个无符号整数类型。如果是，返回<code>true</code>，否则返回<code>false</code>。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-ikos-x2F-ar-x2F-include-x2F-ikos-x2F-semantic-目录下的type-hpp中的Type类声明了什么"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-ikos-x2F-ar-x2F-include-x2F-ikos-x2F-semantic-目录下的type-hpp中的Type类声明了什么" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;ikos&#x2F;ar&#x2F;include&#x2F;ikos&#x2F;semantic 目录下的type.hpp中的Type类声明了什么"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;ikos&#x2F;ar&#x2F;include&#x2F;ikos&#x2F;semantic 目录下的type.hpp中的Type类声明了什么</h2><p><code>Type</code>类在这段代码中代表一个基本的抽象类型。所有的具体类型，如整数、浮点数、向量等，都继承自这个基类。在<code>type.cpp</code>中，我们可以看到<code>Type</code>类的一些实现细节：</p>
<ol>
<li><p><strong>构造函数</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type::<span class="built_in">Type</span>(TypeKind kind) : _kind(kind) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造函数只接受一个<code>TypeKind</code>枚举作为参数，这个枚举描述了这个类型的种类，例如整数、浮点数等。</p>
</li>
<li><p><strong>析构函数</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type::~<span class="built_in">Type</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p><code>Type</code>的析构函数被设为默认，意味着当<code>Type</code>对象被销毁时，不需要额外的清理工作。</p>
</li>
<li><p><strong>查询方法</strong>:<br>这些方法允许查询给定类型的某些属性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Type::is_unsigned_integer</span><span class="params">()</span> <span class="type">const</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Type::is_signed_integer</span><span class="params">()</span> <span class="type">const</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Type::is_primitive</span><span class="params">()</span> <span class="type">const</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Type::primitive_bit_width</span><span class="params">()</span> <span class="type">const</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ctx_impl</strong>:<br>这是一个辅助函数，返回给定上下文的实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ContextImpl&amp; <span class="title">Type::ctx_impl</span><span class="params">(Context&amp; ctx)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些就是<code>Type</code>类在<code>type.cpp</code>中的主要声明和实现。它主要是作为其他具体类型的基类，提供了一些基本的查询方法。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的bundle-cpp文件中的create函数"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的bundle-cpp文件中的create函数" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的bundle.cpp文件中的create函数"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的bundle.cpp文件中的create函数</h2><p><code>Bundle::create</code> 是一个静态成员函数，用于创建一个新的 <code>Bundle</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Bundle* <span class="title">Bundle::create</span><span class="params">(Context&amp; ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::unique_ptr&lt; DataLayout &gt; data_layout,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::string triple)</span> </span>&#123;</span><br><span class="line">  Bundle* bundle = <span class="keyword">new</span> <span class="built_in">Bundle</span>(ctx, std::<span class="built_in">move</span>(data_layout), std::<span class="built_in">move</span>(triple));</span><br><span class="line">  ctx._impl-&gt;<span class="built_in">add_bundle</span>(std::<span class="built_in">unique_ptr</span>&lt; Bundle &gt;(bundle));</span><br><span class="line">  <span class="keyword">return</span> bundle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我为你解释一下这个函数的具体步骤：</p>
<ol>
<li><p><code>Bundle* Bundle::create(Context&amp; ctx, std::unique_ptr&lt; DataLayout &gt; data_layout, std::string triple)</code> 是一个静态成员函数，因此可以通过 <code>Bundle::create(...)</code> 的方式调用，而不需要先实例化一个 <code>Bundle</code> 对象。</p>
</li>
<li><p>当调用 <code>Bundle::create</code> 时，它接受三个参数：</p>
<ul>
<li><code>ctx</code> 是一个 <code>Context</code> 的引用，表示上下文对象。</li>
<li><code>data_layout</code> 是一个指向 <code>DataLayout</code> 对象的独占指针（unique_ptr）。</li>
<li><code>triple</code> 是一个字符串，用于初始化 <code>Bundle</code> 对象的 <code>_target_triple</code> 成员。</li>
</ul>
</li>
<li><p>在函数内部，首先通过 <code>new</code> 运算符在堆上创建了一个新的 <code>Bundle</code> 对象，并使用传入的参数对其进行初始化。这个对象的指针被赋值给了 <code>bundle</code>。</p>
</li>
<li><p>接着，通过 <code>ctx._impl-&gt;add_bundle(...)</code> 将新创建的 <code>Bundle</code> 对象添加到了 <code>Context</code> 的内部实现中。</p>
</li>
<li><p>最后，函数返回了指向新创建的 <code>Bundle</code> 对象的指针。</p>
</li>
</ol>
<p>总的来说，<code>Bundle::create</code> 函数的目的是创建一个新的 <code>Bundle</code> 对象，并将其添加到相应的 <code>Context</code> 中，然后返回指向该新对象的指针。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的bundle-cpp文件中的std-unique-ptr-lt-DataLayout-gt-data-layout怎么用"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的bundle-cpp文件中的std-unique-ptr-lt-DataLayout-gt-data-layout怎么用" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的bundle.cpp文件中的std::unique_ptr&lt; DataLayout &gt; data_layout怎么用"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的bundle.cpp文件中的std::unique_ptr&lt; DataLayout &gt; data_layout怎么用</h2><p><code>std::unique_ptr&lt;DataLayout&gt;</code> 是一个智能指针，用于管理一个 <code>DataLayout</code> 对象的所有权。智能指针允许你自动管理对象的生命周期，当不再需要时，会自动释放资源，防止内存泄漏。以下是如何使用 <code>std::unique_ptr&lt;DataLayout&gt;</code> 的示例：</p>
<p>首先，创建一个 <code>DataLayout</code> 对象，并将其包装在 <code>std::unique_ptr</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;DataLayout&gt; dataLayoutPtr = std::<span class="built_in">make_unique</span>&lt;DataLayout&gt;(<span class="string">&quot;your_data_layout_string&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用 <code>std::make_unique</code> 函数创建了一个 <code>DataLayout</code> 对象，并将其所有权分配给了 <code>dataLayoutPtr</code>。</p>
<p>接下来，你可以通过 <code>dataLayoutPtr</code> 访问 <code>DataLayout</code> 对象的方法和成员变量，就像直接操作 <code>DataLayout</code> 对象一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问 DataLayout 对象的方法</span></span><br><span class="line">std::string alignment = dataLayoutPtr-&gt;<span class="built_in">getAlignmentInfo</span>();</span><br><span class="line"><span class="type">unsigned</span> pointerSize = dataLayoutPtr-&gt;<span class="built_in">getPointerSize</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 DataLayout 对象的成员变量</span></span><br><span class="line">dataLayoutPtr-&gt;<span class="built_in">setAlignmentInfo</span>(<span class="string">&quot;new_alignment_info&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当不再需要 <code>DataLayout</code> 对象时，不需要手动释放内存，因为 <code>std::unique_ptr</code> 会在其超出范围时自动销毁对象并释放内存。例如，当 <code>dataLayoutPtr</code> 超出其作用域时，关联的 <code>DataLayout</code> 对象将被销毁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dataLayoutPtr 超出作用域，关联的 DataLayout 对象会被销毁</span></span><br></pre></td></tr></table></figure>

<p>这种方式可以帮助你避免内存泄漏问题，因为 <code>std::unique_ptr</code> 会在适当的时候自动释放资源。</p>
<p>说白了就是一个指针，但是能够在不需要的时候自动释放内存。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的bundle-cpp文件中的SymbolTable怎么用"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的bundle-cpp文件中的SymbolTable怎么用" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的bundle.cpp文件中的SymbolTable怎么用"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的bundle.cpp文件中的SymbolTable怎么用</h2><p><code>SymbolTable&lt; GlobalVariable &gt; _globals;</code> 是 <code>Bundle</code> 类的一个私有成员变量，用于存储 <code>GlobalVariable</code> 对象的符号表。</p>
<p>让我为您解释一下：</p>
<ul>
<li><p><code>_globals</code> 是一个名为 <code>_globals</code> 的成员变量，它的类型是 <code>SymbolTable&lt; GlobalVariable &gt;</code>。它实际上是一个符号表，用于存储全局变量对象。</p>
</li>
<li><p><code>SymbolTable</code> 可能是一个模板类，接受一个模板参数，这里是 <code>GlobalVariable</code> 类型。它提供了一种将符号与对象关联起来的机制，使得可以通过符号来查找、插入、删除对应的对象。</p>
</li>
</ul>
<p>总的来说，<code>_globals</code> 成员变量是用于存储 <code>GlobalVariable</code> 对象的符号表，这样 <code>Bundle</code> 对象可以有效地管理全局变量。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的symbol-table-hpp文件"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的symbol-table-hpp文件" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic  目录下的symbol_table.hpp文件"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic  目录下的symbol_table.hpp文件</h2><p><code>SymbolTable</code> 类的主要作用是管理符号（symbols）的集合。在编译器或解释器的上下文中，符号通常指代程序中的变量、函数、类型等命名实体。</p>
<p>以下是 <code>SymbolTable</code> 的主要功能：</p>
<ol>
<li><p><strong>存储符号：</strong> <code>SymbolTable</code> 使用 <code>std::unordered_map</code> 存储符号的名称与其对应的指针。这样，通过符号的名称可以快速检索到相应的符号。</p>
</li>
<li><p><strong>添加符号：</strong> 提供了 <code>add</code> 函数，用于向符号表中添加新的符号。在添加之前，会检查符号的名称是否已经存在，以确保符号表中的每个符号都有唯一的名称。</p>
</li>
<li><p><strong>重命名符号：</strong> 提供了 <code>rename</code> 函数，用于将符号在符号表中的名称修改为新的名称。同样，会进行一些检查以确保新的名称是唯一的。</p>
</li>
<li><p><strong>迭代符号：</strong> 使用 <code>boost::transform_iterator</code> 提供了迭代器，允许用户遍历符号表中的符号，而无需直接处理底层的键值对。</p>
</li>
<li><p><strong>查询符号：</strong> 提供了 <code>find</code> 函数，通过符号的名称查找符号在符号表中的指针。同时，提供了 <code>contains</code> 函数，用于检查符号表中是否包含特定名称的符号。</p>
</li>
</ol>
<p>总体而言，<code>SymbolTable</code> 提供了一种组织和管理程序中命名实体的机制。这在编译器、解释器和其他静态或动态分析工具中是常见的需求。通过使用符号表，可以更方便地处理程序中的符号，并进行一些必要的操作，如重命名、检索、迭代等。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的bundle-cpp文件中有什么函数"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的bundle-cpp文件中有什么函数" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的bundle.cpp文件中有什么函数"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的bundle.cpp文件中有什么函数</h2><p><code>Bundle</code> 类中定义了一些函数，以下是这些函数的简要解释：</p>
<ol>
<li><p><code>create</code>（静态构造函数）：</p>
<ul>
<li>作用：创建一个新的 <code>Bundle</code> 实例。</li>
<li>参数：接受AR上下文、数据布局和目标三元组作为参数。</li>
<li>返回：新的 <code>Bundle</code> 实例。</li>
<li>解释：这个函数用于创建 <code>Bundle</code> 的新实例，它确保了 <code>Bundle</code> 的正确初始化。</li>
</ul>
</li>
<li><p><code>context</code>：</p>
<ul>
<li>作用：返回与 <code>Bundle</code> 相关联的AR上下文。</li>
<li>返回：AR上下文的引用。</li>
<li>解释：这个函数返回了 <code>Bundle</code> 中使用的AR上下文，这个上下文包含了关于程序的各种信息。</li>
</ul>
</li>
<li><p><code>data_layout</code>：</p>
<ul>
<li>作用：返回 <code>Bundle</code> 中定义的数据布局。</li>
<li>返回：数据布局的引用。</li>
<li>解释：这个函数返回了描述数据布局的对象，数据布局包括有关数据类型如何在内存中排列的信息。</li>
</ul>
</li>
<li><p><code>target_triple</code>：</p>
<ul>
<li>作用：返回 <code>Bundle</code> 中保存的目标三元组。</li>
<li>返回：目标三元组的字符串。</li>
<li>解释：这个函数返回了用于指定生成的目标代码的目标架构和操作系统的字符串。</li>
</ul>
</li>
<li><p><code>global_begin</code> 和 <code>global_end</code>：</p>
<ul>
<li>作用：用于遍历 <code>Bundle</code> 中全局变量的迭代器的起始和结束位置。</li>
<li>返回：全局变量迭代器的起始和结束位置。</li>
<li>解释：这对函数允许你遍历 <code>Bundle</code> 中的全局变量，以便查看或修改它们。</li>
</ul>
</li>
<li><p><code>num_globals</code>：</p>
<ul>
<li>作用：返回 <code>Bundle</code> 中全局变量的数量。</li>
<li>返回：全局变量的数量。</li>
<li>解释：这个函数返回 <code>Bundle</code> 中全局变量的数量。</li>
</ul>
</li>
<li><p><code>global_or_null</code>：</p>
<ul>
<li>作用：通过名称获取全局变量的指针，如果不存在则返回空指针。</li>
<li>参数：要查找的全局变量的名称。</li>
<li>返回：全局变量的指针或空指针。</li>
<li>解释：这个函数允许你根据名称查找 <code>Bundle</code> 中的全局变量。</li>
</ul>
</li>
<li><p><code>function_begin</code> 和 <code>function_end</code>：</p>
<ul>
<li>作用：用于遍历 <code>Bundle</code> 中函数的迭代器的起始和结束位置。</li>
<li>返回：函数迭代器的起始和结束位置。</li>
<li>解释：这对函数允许你遍历 <code>Bundle</code> 中的函数，以便查看或修改它们。</li>
</ul>
</li>
<li><p><code>num_functions</code>：</p>
<ul>
<li>作用：返回 <code>Bundle</code> 中函数的数量。</li>
<li>返回：函数的数量。</li>
<li>解释：这个函数返回 <code>Bundle</code> 中函数的数量。</li>
</ul>
</li>
<li><p><code>intrinsic_function</code>：</p>
<ul>
<li>作用：获取或创建具有给定ID和（可选）类型参数的内部函数。</li>
<li>参数：内部函数的ID和可选的类型模板。</li>
<li>返回：内部函数的指针。</li>
<li>解释：这个函数用于获取或创建具有特定内部ID的内部函数，用于内部操作和编译器优化。</li>
</ul>
</li>
<li><p><code>function_or_null</code>：</p>
<ul>
<li>作用：通过名称获取函数的指针，如果不存在则返回空指针。</li>
<li>参数：要查找的函数的名称。</li>
<li>返回：函数的指针或空指针。</li>
<li>解释：这个函数允许你根据名称查找 <code>Bundle</code> 中的函数。</li>
</ul>
</li>
<li><p><code>is_name_available</code> 和 <code>find_available_name</code>：</p>
<ul>
<li>作用：用于检查名称是否可用以及查找可用的名称。</li>
<li>参数：要检查的名称或查找的名称前缀。</li>
<li>返回：<code>is_name_available</code> 返回布尔值，<code>find_available_name</code> 返回新的可用名称。</li>
<li>解释：这些函数用于处理名称冲突，确保全局变量和函数的名称唯一性。</li>
</ul>
</li>
</ol>
<p>这些函数为 <code>Bundle</code> 类提供了管理全局变量、函数和与程序分析相关的信息的方法。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的value-cpp文件"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-ar-x2F-src-x2F-semantic-目录下的value-cpp文件" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的value.cpp文件"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;ar&#x2F;src&#x2F;semantic 目录下的value.cpp文件</h2><p>这是一个C++文件，涉及了一些与程序分析和编译相关的类，主要包括 <code>Value</code> 类和与值相关的各种常量、变量类。以下是该文件中的一些重要内容：</p>
<ol>
<li><p><code>Value</code> 类：这是表示各种值的基类，包括常量和变量。它包括一个值的种类（<code>ValueKind</code>）和类型（<code>Type</code>）信息。<code>Value</code> 类有一些派生类，如 <code>Constant</code>、<code>Variable</code> 等。</p>
</li>
<li><p>常量类：包括 <code>UndefinedConstant</code>（未定义常量）、<code>IntegerConstant</code>（整数常量）、<code>FloatConstant</code>（浮点数常量）等。每个常量类都有相应的构造函数和 <code>dump</code> 方法，用于创建和打印常量。</p>
</li>
<li><p>变量类：包括 <code>GlobalVariable</code>（全局变量）、<code>LocalVariable</code>（局部变量）和 <code>InternalVariable</code>（内部变量）。这些变量类表示程序中的各种变量。<code>GlobalVariable</code> 和 <code>LocalVariable</code> 具有名称、类型和其他信息，而 <code>InternalVariable</code> 通常是编译器内部使用的。</p>
</li>
<li><p>全局变量类（<code>GlobalVariable</code>）：表示程序中的全局变量，包括名称、类型、是否定义等信息。它还包括一些与全局变量相关的方法，如 <code>create</code> 用于创建全局变量，<code>set_name</code> 用于设置名称，以及 <code>dump</code> 用于打印信息。</p>
</li>
<li><p>局部变量类（<code>LocalVariable</code>）：表示程序中的局部变量，类似于全局变量，但通常在函数内部定义。也包括与局部变量相关的方法和打印信息的函数。</p>
</li>
<li><p>内部变量类（<code>InternalVariable</code>）：表示程序中的内部变量，通常由编译器生成。它也包括与内部变量相关的方法和打印信息的函数。</p>
</li>
</ol>
<p>这个文件主要定义了这些类，以及它们之间的关系和方法。这些类在程序分析和编译过程中用于表示和处理各种值和变量。如果你有特定的问题或需要深入了解其中的某个方面，请告诉我，我会尽力提供更多信息。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-ar-x2F-ikos-x2F-include-x2F-semantic-目录下的number-hpp文件"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-ar-x2F-ikos-x2F-include-x2F-semantic-目录下的number-hpp文件" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;ar&#x2F;ikos&#x2F;include&#x2F;semantic 目录下的number.hpp文件"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;ar&#x2F;ikos&#x2F;include&#x2F;semantic 目录下的number.hpp文件</h2><p>这是一个标题为“Number definitions”的C++头文件，它定义了一些与数字和整数操作相关的类和类型。以下是文件的主要内容：</p>
<ol>
<li><p>头文件包含：该文件包含了一些与整数操作相关的其他头文件，如 <code>supported_integral.hpp</code>、<code>z_number.hpp</code> 和 <code>machine_int.hpp</code>。这些头文件可能定义了一些整数和数字操作的具体实现。</p>
</li>
<li><p>类型定义：文件定义了以下类型和类别：</p>
<ul>
<li><code>Signedness</code>：表示整数的符号（有符号或无符号）的枚举类型。</li>
<li><code>Signed</code>：符号为有符号的整数值。</li>
<li><code>Unsigned</code>：符号为无符号的整数值。</li>
<li><code>ZNumber</code>：用于表示无限精度整数的类，这是一个支持任意精度的整数类。</li>
<li><code>MachineInt</code>：用于表示任意精度机器整数的类，支持不同精度和符号。</li>
</ul>
</li>
</ol>
<p>这些定义用于处理各种整数和数字操作，包括整数运算、符号处理以及其他与整数相关的计算。这些类和类型可能在程序分析、编译器和其他需要数值处理的应用中起到关键作用。</p>
<h2 id="用IKOS分析C程序的流程如下"><a href="#用IKOS分析C程序的流程如下" class="headerlink" title="用IKOS分析C程序的流程如下"></a>用IKOS分析C程序的流程如下</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zou@zou-VirtualBox:~/Documents/FIKOS/test/mytest$ ikos hello.c</span><br><span class="line">[*] Compiling hello.c</span><br><span class="line">[*] Running ikos preprocessor</span><br><span class="line">[*] Running ikos analyzer</span><br><span class="line">[*] Translating LLVM bitcode to AR</span><br><span class="line">[*] Running liveness analysis</span><br><span class="line">[*] Running widening hint analysis</span><br><span class="line">[*] Running interprocedural value analysis</span><br><span class="line">[*] Analyzing entry point <span class="string">&#x27;main&#x27;</span></span><br><span class="line">[*] Checking properties <span class="keyword">for</span> entry point <span class="string">&#x27;main&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Time stats:</span></span><br><span class="line">clang        : 0.032 sec</span><br><span class="line">ikos-analyzer: 0.007 sec</span><br><span class="line">ikos-pp      : 0.007 sec</span><br><span class="line"></span><br><span class="line"><span class="comment"># Summary:</span></span><br><span class="line">Total number of checks                : 3</span><br><span class="line">Total number of unreachable checks    : 0</span><br><span class="line">Total number of safe checks           : 3</span><br><span class="line">Total number of definite unsafe checks: 0</span><br><span class="line">Total number of warnings              : 0</span><br><span class="line"></span><br><span class="line">The program is SAFE</span><br><span class="line"></span><br><span class="line"><span class="comment"># Results</span></span><br><span class="line">No entries.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="解读Python脚本"><a href="#解读Python脚本" class="headerlink" title="解读Python脚本"></a>解读Python脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-v&#x27;</span>,</span><br><span class="line">                    dest=<span class="string">&#x27;verbosity&#x27;</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;Increase verbosity&#x27;</span>,</span><br><span class="line">                    action=<span class="string">&#x27;count&#x27;</span>,</span><br><span class="line">                    default=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码是使用 Python 的 argparse 模块创建命令行参数解析器。它定义了一个名为 <code>-v</code> 或 <code>--verbosity</code> 的参数，用于控制输出的详细程度。参数的具体解释如下：</p>
<ul>
<li><code>dest=&#39;verbosity&#39;</code>：将解析后的值存储在名为 <code>verbosity</code> 的变量中。</li>
<li><code>help=&#39;Increase verbosity&#39;</code>：当用户运行脚本时，如果使用了 <code>-h</code> 或 <code>--help</code> 参数，将显示的帮助信息，说明这个参数的作用是增加详细程度。</li>
<li><code>action=&#39;count&#39;</code>：指定了当这个参数出现时的行为。在这种情况下，<code>action=&#39;count&#39;</code> 表示每次出现 <code>-v</code> 就增加 <code>verbosity</code> 变量的值。例如，<code>-v</code> 会使 <code>verbosity</code> 变为2，<code>-vv</code> 会使其变为3，以此类推。</li>
<li><code>default=1</code>：如果用户没有提供 <code>-v</code> 参数，将使用默认值1。</li>
</ul>
<p>这段代码的作用是允许用户通过命令行控制脚本的输出详细程度，通过多次使用 <code>-v</code> 参数来增加详细级别。</p>
<h2 id="上述的代码怎么调用函数实现功能"><a href="#上述的代码怎么调用函数实现功能" class="headerlink" title="上述的代码怎么调用函数实现功能"></a>上述的代码怎么调用函数实现功能</h2><p>在使用这个参数解析器的脚本中，你可以通过以下方式来调用相关函数：</p>
<ol>
<li><p><strong>导入 argparse 模块：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建 ArgumentParser 对象：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser = argparse.ArgumentParser()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>添加参数：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-v&#x27;</span>, dest=<span class="string">&#x27;verbosity&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Increase verbosity&#x27;</span>, action=<span class="string">&#x27;count&#x27;</span>, default=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解析命令行参数：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用解析后的参数：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> args.verbosity == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Low verbosity output&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> args.verbosity == <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Medium verbosity output&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> args.verbosity &gt;= <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;High verbosity output&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这样，当用户在命令行中使用 <code>-v</code> 参数时，<code>args.verbosity</code> 将包含相应的值，你可以根据这个值来实现不同的功能。例如，你可以根据 <code>verbosity</code> 的不同级别输出不同详细程度的信息。</p>
<h2 id="Python脚本中的metavar和help关键词"><a href="#Python脚本中的metavar和help关键词" class="headerlink" title="Python脚本中的metavar和help关键词"></a>Python脚本中的metavar和help关键词</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;-o&#x27;</span>, <span class="string">&#x27;--output-db&#x27;</span>,</span><br><span class="line">                    dest=<span class="string">&#x27;output_db&#x27;</span>,</span><br><span class="line">                    metavar=<span class="string">&#x27;&lt;file&gt;&#x27;</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;Output database file (default: output.db)&#x27;</span>,</span><br><span class="line">                    default=<span class="string">&#x27;output.db&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码是用于解析命令行参数的 argparse 代码，针对输出数据库文件的设置。下面是对这段代码的解释：</p>
<ul>
<li><code>-o</code> 和 <code>--output-db</code> 是两种不同的方式来指定输出数据库文件的参数，用户可以选择其中一种来使用。</li>
<li><code>dest=&#39;output_db&#39;</code> 表示解析后的值将存储在名为 <code>output_db</code> 的变量中。</li>
<li><code>metavar=&#39;&lt;file&gt;&#39;</code> 用于指定在帮助消息中显示的参数值的名称，这里是 <code>&lt;file&gt;</code>。</li>
<li><code>help=&#39;Output database file (default: output.db)&#39;</code> 提供了在用户请求帮助时显示的信息，指明了这个参数的作用以及默认值。</li>
<li><code>default=&#39;output.db&#39;</code> 指定了参数的默认值，如果用户未提供输出数据库文件的参数，则将使用这个默认值。</li>
</ul>
<p>用户可以通过命令行指定输出数据库文件的名称，例如 <code>-o custom_db.db</code> 或 <code>--output-db custom_db.db</code>。如果用户未指定，将使用默认的输出数据库文件名 <code>output.db</code>。在脚本中，你可以通过 <code>args.output_db</code> 访问解析后的输出数据库文件的值。</p>
<p>上面的metavar是怎么用的?</p>
<p><code>metavar</code> 是 argparse 模块中的一个参数，用于指定在帮助消息中显示的参数值的名称。它通常用于提供用户在命令行中应该提供什么样的值。</p>
<p>在你提供的代码中，<code>metavar=&#39;&lt;file&gt;&#39;</code> 表示用户在命令行中指定输出数据库文件参数时，应该提供一个文件名。这个文件名在帮助消息中被称为 <code>&lt;file&gt;</code>，用于说明用户应该提供一个文件的路径作为参数值。</p>
<p>例如，当用户运行脚本时使用 <code>-o custom_db.db</code> 或 <code>--output-db custom_db.db</code>，帮助消息可能会包含类似以下的信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-o &lt;file&gt;, --output-db &lt;file&gt;		Output database file (default: output.db)</span><br></pre></td></tr></table></figure>

<p>这样的帮助消息有助于用户理解该参数的期望值。</p>
<h2 id="argparse库中的action字段的多个选项"><a href="#argparse库中的action字段的多个选项" class="headerlink" title="argparse库中的action字段的多个选项"></a>argparse库中的action字段的多个选项</h2><p><code>argparse</code>库中的<code>action</code>字段有多种可选项，用于定义当命令行选项出现时应该执行的操作。以下是一些常见的<code>action</code>选项：</p>
<ol>
<li><p><code>store</code>（默认值）：将命令行参数的值存储在一个变量中。</p>
</li>
<li><p><code>store_const</code>：存储一个常数值在一个变量中，通常与<code>const</code>参数一起使用。</p>
</li>
<li><p><code>store_true</code>：存储<code>True</code>值在一个变量中，通常用于标志选项。</p>
</li>
<li><p><code>store_false</code>：存储<code>False</code>值在一个变量中，也通常用于标志选项。</p>
</li>
<li><p><code>append</code>：将多个参数值存储在一个列表中，用于多次出现的选项。</p>
</li>
<li><p><code>append_const</code>：将一个常数值附加到一个列表中，通常与<code>const</code>参数一起使用。</p>
</li>
<li><p><code>count</code>：计算选项出现的次数，存储在一个整数变量中，用于计数操作。</p>
</li>
<li><p><code>version</code>：用于显示版本信息并退出。</p>
</li>
</ol>
<p>这些<code>action</code>选项允许您自定义如何处理不同类型的命令行参数，以满足您的应用程序的需求。</p>
<h2 id="命令行中可选参数值"><a href="#命令行中可选参数值" class="headerlink" title="命令行中可选参数值"></a>命令行中可选参数值</h2><p><code>choices=args.choices(args.log_levels)</code></p>
<p>这行代码涉及到 <code>args.choices</code> 函数，它似乎用于从命令行参数的可选值列表中获取选项的可选值。在这个特定上下文中，<code>args.log_levels</code> 应该是一个包含可选日志级别的列表。这行代码的目的是使用 <code>args.choices</code> 函数将这些可选日志级别作为合法的选择，以便在命令行参数中指定日志级别时进行验证。</p>
<p>例如，如果 <code>args.log_levels</code> 包含以下日志级别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args.log_levels = [<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>, <span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;debug&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>然后，使用 <code>choices=args.choices(args.log_levels)</code> 将会确保在命令行中选择日志级别时，只能从这些选项中进行选择，而不会输入无效的日志级别。这是一种在命令行工具中限制和验证用户输入的常见方式。</p>
<h2 id="指定分析函数入口的脚本在第514行"><a href="#指定分析函数入口的脚本在第514行" class="headerlink" title="指定分析函数入口的脚本在第514行"></a>指定分析函数入口的脚本在第514行</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># by default, the entry point is main</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> opt.entry_points:</span><br><span class="line">    opt.entry_points = (<span class="string">&#x27;main&#x27;</span>,)</span><br></pre></td></tr></table></figure>

<h2 id="保存临时文件"><a href="#保存临时文件" class="headerlink" title="保存临时文件"></a>保存临时文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ikos hello.c --save-temps --temp-dir=/home/zou/Documents/FIKOS/test/mytest</span><br></pre></td></tr></table></figure>

<p>临时文件包括<code>.bc, .pp.bc</code>，我现在想将所有的文件保存下来，需要额外组合指令，并且更改脚本代码。</p>
<h2 id="现在想保存尽可能多的文件，如ar文件"><a href="#现在想保存尽可能多的文件，如ar文件" class="headerlink" title="现在想保存尽可能多的文件，如ar文件"></a>现在想保存尽可能多的文件，如ar文件</h2><p>则需修改脚本文件将其保存到文件中。展示AR的代码在&#x2F;FIKOS&#x2F;analyzer&#x2F;src 目录下的ikos_analyzer.cpp文件中的1009行。</p>
<h2 id="x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-analyzer-x2F-src-目录下的ikos-analyzer-cpp文件中display-ar操作的源代码及解析"><a href="#x2F-home-x2F-zou-x2F-Documents-x2F-FIKOS-x2F-analyzer-x2F-src-目录下的ikos-analyzer-cpp文件中display-ar操作的源代码及解析" class="headerlink" title="&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;analyzer&#x2F;src 目录下的ikos-analyzer.cpp文件中display-ar操作的源代码及解析"></a>&#x2F;home&#x2F;zou&#x2F;Documents&#x2F;FIKOS&#x2F;analyzer&#x2F;src 目录下的ikos-analyzer.cpp文件中display-ar操作的源代码及解析</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Display the abstract representation</span></span><br><span class="line"><span class="keyword">if</span> (DisplayAR) &#123;</span><br><span class="line">  analyzer::log::<span class="built_in">info</span>(<span class="string">&quot;Printing Abstract Representation&quot;</span>);</span><br><span class="line">  <span class="function">analyzer::ScopeTimerDatabase <span class="title">t</span><span class="params">(output_db.times,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="string">&quot;ikos-analyzer.display-ar&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function">ar::TextFormatter <span class="title">formatter</span><span class="params">(make_format_options())</span></span>;</span><br><span class="line">  formatter.format(analyzer::log::<span class="built_in">msg</span>().<span class="built_in">stream</span>(), bundle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是在满足条件时，展示程序的抽象表示（Abstract Representation）。</p>
<p>它包含以下步骤：</p>
<ol>
<li><p>首先，它检查条件 <code>DisplayAR</code> 是否为真（即，是否应该显示抽象表示）。<code>DisplayAR</code> 是一个控制是否显示抽象表示的开关。</p>
</li>
<li><p>如果条件 <code>DisplayAR</code> 为真，那么它执行以下操作。</p>
</li>
<li><p>它使用 <code>analyzer::log::info</code> 函数打印一条信息，说明要开始打印抽象表示。</p>
</li>
<li><p>接着，它创建一个名为 <code>t</code> 的计时器（<code>analyzer::ScopeTimerDatabase</code>），用于测量打印抽象表示所需的时间。这个计时器将记录在 <code>output_db.times</code> 数据结构中，用于后续的时间报告。</p>
</li>
<li><p>使用 <code>ar::TextFormatter</code> 类创建一个文本格式化器（formatter）。这个格式化器用于将抽象表示以文本形式呈现。</p>
</li>
<li><p>使用 <code>make_format_options()</code> 函数创建格式选项，这些选项用于配置格式化器的行为。</p>
</li>
<li><p>最后，使用格式化器 <code>formatter</code> 将抽象表示打印到日志中（使用 <code>analyzer::log::msg().stream()</code>）。这将在日志中显示程序的抽象表示。</p>
</li>
</ol>
<p>总之，这段代码用于在满足条件时，以文本形式打印程序的抽象表示，以便开发人员和分析人员可以查看和理解程序的抽象结构。这有助于调试和分析程序的行为。</p>
<h2 id="SCADE-model是什么"><a href="#SCADE-model是什么" class="headerlink" title="SCADE model是什么"></a>SCADE model是什么</h2><p>Scade（Safety Critical Application Development Environment）是一种用于开发安全关键应用程序的工具和环境。Scade模型是一种用于设计和开发安全关键系统的模型，通常用于航空航天、汽车、医疗设备等领域。Scade模型通常采用形式化建模方法，以确保系统的可靠性、安全性和高可用性。这些模型通常基于数据流和状态转换的概念，用于描述系统的行为和功能。 Scade模型通常与自动代码生成工具一起使用，以生成可执行代码，从而减少人为错误的可能性。这些模型在开发需要极高可靠性和安全性的系统时非常有用。</p>
<h2 id="超越函数是什么"><a href="#超越函数是什么" class="headerlink" title="超越函数是什么"></a>超越函数是什么</h2><p>超越函数（Transcendental Function）是一种在数学中描述的函数，它不满足任何有限次代数方程（多项式方程）的解。这意味着超越函数不能用一个有限次的代数运算来表示。相反，它们通常涉及到无限级数、无穷集合或者特殊函数，如指数函数、三角函数、对数函数等。</p>
<p>一些著名的超越函数包括：</p>
<ol>
<li><p>指数函数（Exponential Function）：例如，y &#x3D; e^x 是一个常见的超越函数，其中 e 是自然对数的底数。</p>
</li>
<li><p>正弦函数和余弦函数（Sine and Cosine Functions）：例如，y &#x3D; sin(x) 和 y &#x3D; cos(x) 也是超越函数。</p>
</li>
<li><p>对数函数（Logarithmic Function）：例如，y &#x3D; ln(x) 表示自然对数。</p>
</li>
<li><p>阶乘函数（Factorial Function）：n! 表示整数 n 的阶乘，也可以看作一个特殊的超越函数。</p>
</li>
</ol>
<p>这些函数在数学、物理学、工程学和其他领域中广泛应用，因为它们能够描述许多自然现象和复杂的数学关系。超越函数通常在解微分方程、数值分析、和科学建模等领域中发挥重要作用。</p>
<h2 id="open-convex-domain是什么"><a href="#open-convex-domain是什么" class="headerlink" title="open convex domain是什么"></a>open convex domain是什么</h2><p>“Open convex domain” 意味着一个凸域（区域）的子集，这个子集在域内具有开放性质，也就是不包括边界上的点。凸域是一个在任意两点之间的线段完全位于域内的区域，而 “open” 表示这个区域不包括域的边界。</p>
<p>例如，考虑二维平面上的一个圆，其中所有圆内的点都构成一个凸域，但如果我们从这个圆中排除圆周上的点，那么我们得到的是一个开放的凸域。</p>
<p>在数学、优化、和凸几何学等领域中，开放凸域是一个重要的概念，因为它们通常用于定义约束条件或分析问题的可行域。例如，线性规划中的可行域通常定义为一个开放凸域，因为这些问题通常要求变量取值的范围不能包括边界上的点。</p>
<h2 id="ubuntu查看目录结构"><a href="#ubuntu查看目录结构" class="headerlink" title="ubuntu查看目录结构"></a>ubuntu查看目录结构</h2><p>在Ubuntu中查看目录结构可以使用命令行工具<code>ls</code>和<code>tree</code>。以下是这两个工具的简介和使用方法：</p>
<ol>
<li>ls命令：该命令用于列出当前目录下的文件和子目录。</li>
</ol>
<p>用法：<code>ls [选项] [文件或目录]</code></p>
<p>常用选项：</p>
<ul>
<li><code>-l</code>：以长格式显示文件和目录信息。</li>
<li><code>-a</code>：显示所有文件和目录，包括隐藏的。</li>
<li><code>-h</code>：以易读的方式显示文件大小。</li>
<li><code>-R</code>：递归地列出目录下的所有文件和子目录。</li>
</ul>
<p>示例：</p>
<ul>
<li>列出当前目录下的所有文件和子目录：<code>ls</code></li>
<li>列出当前目录下的所有文件和子目录（包括隐藏文件和目录）：<code>ls -a</code></li>
<li>列出当前目录下的所有文件和子目录，并以长格式显示：<code>ls -l</code></li>
<li>列出当前目录及其子目录下的所有文件和子目录：<code>ls -R</code></li>
</ul>
<ol>
<li>tree命令：该命令用于以树形结构显示目录结构。</li>
</ol>
<p>用法：<code>tree [选项] [目录]</code></p>
<p>常用选项：</p>
<ul>
<li><code>-a</code>：显示所有文件和目录，包括隐藏的。</li>
<li><code>-d</code>：仅显示目录，不显示文件。</li>
<li><code>-L</code>：限制显示的深度。</li>
</ul>
<p>示例：</p>
<ul>
<li>显示当前目录下的所有文件和子目录的树形结构：<code>tree</code></li>
<li>显示当前目录下的所有文件和子目录的树形结构，并包括隐藏文件和目录：<code>tree -a</code></li>
<li>显示当前目录下的所有目录的树形结构：<code>tree -d</code></li>
<li>显示当前目录下的所有文件和子目录的树形结构，但限制显示深度为2级：<code>tree -L 2</code></li>
</ul>
<h2 id="IKOS的结构"><a href="#IKOS的结构" class="headerlink" title="IKOS的结构"></a>IKOS的结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zou@zou-VirtualBox:~/Documents/IKOS$ tree -d</span><br><span class="line">.</span><br><span class="line">├── analyzer</span><br><span class="line">│   ├── doc</span><br><span class="line">│   │   └── doxygen</span><br><span class="line">│   │       └── latex</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── ikos</span><br><span class="line">│   │       └── analyzer</span><br><span class="line">│   │           ├── analysis</span><br><span class="line">│   │           │   ├── execution_engine</span><br><span class="line">│   │           │   ├── pointer</span><br><span class="line">│   │           │   └── value</span><br><span class="line">│   │           │       ├── interprocedural</span><br><span class="line">│   │           │       │   ├── concurrent</span><br><span class="line">│   │           │       │   └── sequential</span><br><span class="line">│   │           │       └── intraprocedural</span><br><span class="line">│   │           │           ├── concurrent</span><br><span class="line">│   │           │           └── sequential</span><br><span class="line">│   │           ├── checker</span><br><span class="line">│   │           ├── database</span><br><span class="line">│   │           │   └── table</span><br><span class="line">│   │           ├── json</span><br><span class="line">│   │           ├── support</span><br><span class="line">│   │           └── util</span><br><span class="line">│   ├── python</span><br><span class="line">│   │   └── ikos</span><br><span class="line">│   │       └── view</span><br><span class="line">│   │           ├── static</span><br><span class="line">│   │           │   ├── css</span><br><span class="line">│   │           │   └── js</span><br><span class="line">│   │           └── template</span><br><span class="line">│   ├── script</span><br><span class="line">│   ├── src</span><br><span class="line">│   │   ├── analysis</span><br><span class="line">│   │   │   ├── pointer</span><br><span class="line">│   │   │   └── value</span><br><span class="line">│   │   │       ├── interprocedural</span><br><span class="line">│   │   │       │   ├── concurrent</span><br><span class="line">│   │   │       │   └── sequential</span><br><span class="line">│   │   │       ├── intraprocedural</span><br><span class="line">│   │   │       │   ├── concurrent</span><br><span class="line">│   │   │       │   └── sequential</span><br><span class="line">│   │   │       └── machine_int_domain</span><br><span class="line">│   │   ├── checker</span><br><span class="line">│   │   ├── database</span><br><span class="line">│   │   │   └── table</span><br><span class="line">│   │   ├── json</span><br><span class="line">│   │   └── util</span><br><span class="line">│   └── test</span><br><span class="line">│       └── regression</span><br><span class="line">│           ├── boa</span><br><span class="line">│           ├── dbz</span><br><span class="line">│           ├── dfa</span><br><span class="line">│           ├── fca</span><br><span class="line">│           ├── mem</span><br><span class="line">│           ├── null</span><br><span class="line">│           ├── pcmp</span><br><span class="line">│           ├── poa</span><br><span class="line">│           ├── prover</span><br><span class="line">│           ├── shc</span><br><span class="line">│           ├── sio</span><br><span class="line">│           ├── sound</span><br><span class="line">│           ├── uio</span><br><span class="line">│           ├── uma</span><br><span class="line">│           ├── upa</span><br><span class="line">│           └── uva</span><br><span class="line">├── ar</span><br><span class="line">│   ├── doc</span><br><span class="line">│   │   └── doxygen</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── ikos</span><br><span class="line">│   │       └── ar</span><br><span class="line">│   │           ├── format</span><br><span class="line">│   │           ├── pass</span><br><span class="line">│   │           ├── semantic</span><br><span class="line">│   │           ├── support</span><br><span class="line">│   │           └── verify</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── format</span><br><span class="line">│       ├── pass</span><br><span class="line">│       ├── semantic</span><br><span class="line">│       └── verify</span><br><span class="line">├── build</span><br><span class="line">│   ├── analyzer</span><br><span class="line">│   │   ├── CMakeFiles</span><br><span class="line">│   │   │   ├── build-analyzer-tests.dir</span><br><span class="line">│   │   │   ├── CMakeTmp</span><br><span class="line">│   │   │   ├── doxygen-analyzer.dir</span><br><span class="line">│   │   │   ├── ikos-analyzer.dir</span><br><span class="line">│   │   │   │   └── src</span><br><span class="line">│   │   │   │       ├── analysis</span><br><span class="line">│   │   │   │       │   ├── pointer</span><br><span class="line">│   │   │   │       │   └── value</span><br><span class="line">│   │   │   │       │       ├── interprocedural</span><br><span class="line">│   │   │   │       │       │   ├── concurrent</span><br><span class="line">│   │   │   │       │       │   └── sequential</span><br><span class="line">│   │   │   │       │       ├── intraprocedural</span><br><span class="line">│   │   │   │       │       │   ├── concurrent</span><br><span class="line">│   │   │   │       │       │   └── sequential</span><br><span class="line">│   │   │   │       │       └── machine_int_domain</span><br><span class="line">│   │   │   │       ├── checker</span><br><span class="line">│   │   │   │       ├── database</span><br><span class="line">│   │   │   │       │   └── table</span><br><span class="line">│   │   │   │       ├── json</span><br><span class="line">│   │   │   │       └── util</span><br><span class="line">│   │   │   └── ikos-python.dir</span><br><span class="line">│   │   ├── doc</span><br><span class="line">│   │   ├── python</span><br><span class="line">│   │   │   ├── build</span><br><span class="line">│   │   │   │   ├── lib</span><br><span class="line">│   │   │   │   │   └── ikos</span><br><span class="line">│   │   │   │   │       └── settings</span><br><span class="line">│   │   │   │   └── lib.linux-x86_64-2.7</span><br><span class="line">│   │   │   │       └── ikos</span><br><span class="line">│   │   │   │           └── settings</span><br><span class="line">│   │   │   └── ikos</span><br><span class="line">│   │   │       └── settings</span><br><span class="line">│   │   ├── script</span><br><span class="line">│   │   └── test</span><br><span class="line">│   │       └── regression</span><br><span class="line">│   │           └── CMakeFiles</span><br><span class="line">│   ├── ar</span><br><span class="line">│   │   ├── CMakeFiles</span><br><span class="line">│   │   │   ├── CMakeTmp</span><br><span class="line">│   │   │   ├── doxygen-ar.dir</span><br><span class="line">│   │   │   └── ikos-ar.dir</span><br><span class="line">│   │   │       └── src</span><br><span class="line">│   │   │           ├── format</span><br><span class="line">│   │   │           ├── pass</span><br><span class="line">│   │   │           ├── semantic</span><br><span class="line">│   │   │           └── verify</span><br><span class="line">│   │   └── doc</span><br><span class="line">│   ├── bin</span><br><span class="line">│   ├── CMakeFiles</span><br><span class="line">│   │   ├── 3.16.3</span><br><span class="line">│   │   │   ├── CompilerIdC</span><br><span class="line">│   │   │   │   └── tmp</span><br><span class="line">│   │   │   └── CompilerIdCXX</span><br><span class="line">│   │   │       └── tmp</span><br><span class="line">│   │   ├── check.dir</span><br><span class="line">│   │   ├── CMakeTmp</span><br><span class="line">│   │   └── doc.dir</span><br><span class="line">│   ├── core</span><br><span class="line">│   │   ├── CMakeFiles</span><br><span class="line">│   │   │   ├── build-core-tests.dir</span><br><span class="line">│   │   │   ├── CMakeTmp</span><br><span class="line">│   │   │   └── doxygen-core.dir</span><br><span class="line">│   │   ├── doc</span><br><span class="line">│   │   └── test</span><br><span class="line">│   │       └── unit</span><br><span class="line">│   │           └── CMakeFiles</span><br><span class="line">│   │               ├── test-core-adt-patricia_tree-map.dir</span><br><span class="line">│   │               │   └── adt</span><br><span class="line">│   │               │       └── patricia_tree</span><br><span class="line">│   │               ├── test-core-adt-patricia_tree-set.dir</span><br><span class="line">│   │               │   └── adt</span><br><span class="line">│   │               │       └── patricia_tree</span><br><span class="line">│   │               ├── test-core-domain-discrete_domain.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               ├── test-core-domain-machine_int-congruence.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── machine_int</span><br><span class="line">│   │               ├── test-core-domain-machine_int-interval_congruence.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── machine_int</span><br><span class="line">│   │               ├── test-core-domain-machine_int-interval.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── machine_int</span><br><span class="line">│   │               ├── test-core-domain-machine_int-numeric_domain_adapter.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── machine_int</span><br><span class="line">│   │               ├── test-core-domain-machine_int-polymorphic_domain.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── machine_int</span><br><span class="line">│   │               ├── test-core-domain-memory-partitioning.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── memory</span><br><span class="line">│   │               ├── test-core-domain-nullity-separate_domain.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── nullity</span><br><span class="line">│   │               ├── test-core-domain-numeric-apron-interval.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               │           └── apron</span><br><span class="line">│   │               ├── test-core-domain-numeric-apron-pkgrid_polyhedra_lin_congruences.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               │           └── apron</span><br><span class="line">│   │               ├── test-core-domain-numeric-apron-polka_polyhedra.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               │           └── apron</span><br><span class="line">│   │               ├── test-core-domain-numeric-apron-ppl_linear_congruences.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               │           └── apron</span><br><span class="line">│   │               ├── test-core-domain-numeric-congruence.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               ├── test-core-domain-numeric-constant.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               ├── test-core-domain-numeric-dbm.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               ├── test-core-domain-numeric-gauge.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               ├── test-core-domain-numeric-gauge_interval_congruence.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               ├── test-core-domain-numeric-interval_congruence.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               ├── test-core-domain-numeric-interval.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               ├── test-core-domain-numeric-octagon.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               ├── test-core-domain-numeric-union.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               ├── test-core-domain-numeric-var_packing_dbm_congruence.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               ├── test-core-domain-numeric-var_packing_dbm.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               ├── test-core-domain-numeric-var_packing_domain.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               ├── test-core-domain-pointer-solver.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── pointer</span><br><span class="line">│   │               ├── test-core-domain-uninitialized-separate_domain.dir</span><br><span class="line">│   │               │   └── domain</span><br><span class="line">│   │               │       └── uninitialized</span><br><span class="line">│   │               ├── test-core-example-muzq.dir</span><br><span class="line">│   │               │   └── example</span><br><span class="line">│   │               ├── test-core-fixpoint-wpo.dir</span><br><span class="line">│   │               │   └── fixpoint</span><br><span class="line">│   │               ├── test-core-number-machine_int.dir</span><br><span class="line">│   │               │   └── number</span><br><span class="line">│   │               ├── test-core-number-q_number.dir</span><br><span class="line">│   │               │   └── number</span><br><span class="line">│   │               ├── test-core-number-z_number.dir</span><br><span class="line">│   │               │   └── number</span><br><span class="line">│   │               ├── test-core-value-machine_int-congruence.dir</span><br><span class="line">│   │               │   └── value</span><br><span class="line">│   │               │       └── machine_int</span><br><span class="line">│   │               ├── test-core-value-machine_int-constant.dir</span><br><span class="line">│   │               │   └── value</span><br><span class="line">│   │               │       └── machine_int</span><br><span class="line">│   │               ├── test-core-value-machine_int-interval_congruence.dir</span><br><span class="line">│   │               │   └── value</span><br><span class="line">│   │               │       └── machine_int</span><br><span class="line">│   │               ├── test-core-value-machine_int-interval.dir</span><br><span class="line">│   │               │   └── value</span><br><span class="line">│   │               │       └── machine_int</span><br><span class="line">│   │               ├── test-core-value-numeric-congruence.dir</span><br><span class="line">│   │               │   └── value</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               ├── test-core-value-numeric-constant.dir</span><br><span class="line">│   │               │   └── value</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               ├── test-core-value-numeric-gauge.dir</span><br><span class="line">│   │               │   └── value</span><br><span class="line">│   │               │       └── numeric</span><br><span class="line">│   │               └── test-core-value-numeric-interval.dir</span><br><span class="line">│   │                   └── value</span><br><span class="line">│   │                       └── numeric</span><br><span class="line">│   ├── frontend</span><br><span class="line">│   │   └── llvm</span><br><span class="line">│   │       ├── CMakeFiles</span><br><span class="line">│   │       │   ├── acc_gen.dir</span><br><span class="line">│   │       │   ├── build-frontend-llvm-tests.dir</span><br><span class="line">│   │       │   ├── CMakeTmp</span><br><span class="line">│   │       │   ├── ikos-import.dir</span><br><span class="line">│   │       │   │   └── src</span><br><span class="line">│   │       │   ├── ikos-llvm-to-ar.dir</span><br><span class="line">│   │       │   │   └── src</span><br><span class="line">│   │       │   │       └── import</span><br><span class="line">│   │       │   ├── ikos-pp.dir</span><br><span class="line">│   │       │   │   └── src</span><br><span class="line">│   │       │   ├── ikos-pp-lib.dir</span><br><span class="line">│   │       │   │   └── src</span><br><span class="line">│   │       │   │       └── pass</span><br><span class="line">│   │       │   ├── intrinsics_gen.dir</span><br><span class="line">│   │       │   └── omp_gen.dir</span><br><span class="line">│   │       └── test</span><br><span class="line">│   │           └── regression</span><br><span class="line">│   │               ├── import</span><br><span class="line">│   │               │   └── CMakeFiles</span><br><span class="line">│   │               └── pass</span><br><span class="line">│   │                   └── CMakeFiles</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── ikos</span><br><span class="line">│   │       ├── analyzer</span><br><span class="line">│   │       ├── ar</span><br><span class="line">│   │       │   ├── format</span><br><span class="line">│   │       │   ├── pass</span><br><span class="line">│   │       │   ├── semantic</span><br><span class="line">│   │       │   ├── support</span><br><span class="line">│   │       │   └── verify</span><br><span class="line">│   │       ├── core</span><br><span class="line">│   │       │   ├── adt</span><br><span class="line">│   │       │   │   └── patricia_tree</span><br><span class="line">│   │       │   ├── domain</span><br><span class="line">│   │       │   │   ├── exception</span><br><span class="line">│   │       │   │   ├── lifetime</span><br><span class="line">│   │       │   │   ├── machine_int</span><br><span class="line">│   │       │   │   ├── memory</span><br><span class="line">│   │       │   │   │   └── value</span><br><span class="line">│   │       │   │   ├── nullity</span><br><span class="line">│   │       │   │   ├── numeric</span><br><span class="line">│   │       │   │   ├── pointer</span><br><span class="line">│   │       │   │   ├── scalar</span><br><span class="line">│   │       │   │   └── uninitialized</span><br><span class="line">│   │       │   ├── example</span><br><span class="line">│   │       │   │   ├── machine_int</span><br><span class="line">│   │       │   │   └── scalar</span><br><span class="line">│   │       │   ├── fixpoint</span><br><span class="line">│   │       │   ├── number</span><br><span class="line">│   │       │   ├── semantic</span><br><span class="line">│   │       │   │   ├── machine_int</span><br><span class="line">│   │       │   │   ├── memory</span><br><span class="line">│   │       │   │   │   └── value</span><br><span class="line">│   │       │   │   └── scalar</span><br><span class="line">│   │       │   ├── support</span><br><span class="line">│   │       │   └── value</span><br><span class="line">│   │       │       ├── machine_int</span><br><span class="line">│   │       │       ├── numeric</span><br><span class="line">│   │       │       └── pointer</span><br><span class="line">│   │       └── frontend</span><br><span class="line">│   │           └── llvm</span><br><span class="line">│   │               └── import</span><br><span class="line">│   ├── lib</span><br><span class="line">│   │   └── python2.7</span><br><span class="line">│   │       └── site-packages</span><br><span class="line">│   │           └── ikos</span><br><span class="line">│   │               └── settings</span><br><span class="line">│   └── share</span><br><span class="line">│       └── ikos</span><br><span class="line">│           └── view</span><br><span class="line">│               ├── static</span><br><span class="line">│               │   ├── css</span><br><span class="line">│               │   └── js</span><br><span class="line">│               └── template</span><br><span class="line">├── cmake</span><br><span class="line">├── cmake-build-debug</span><br><span class="line">│   ├── CMakeFiles</span><br><span class="line">│   │   ├── 3.26.4</span><br><span class="line">│   │   │   ├── CompilerIdC</span><br><span class="line">│   │   │   │   └── tmp</span><br><span class="line">│   │   │   └── CompilerIdCXX</span><br><span class="line">│   │   │       └── tmp</span><br><span class="line">│   │   ├── CMakeScratch</span><br><span class="line">│   │   └── pkgRedirects</span><br><span class="line">│   └── core</span><br><span class="line">│       └── CMakeFiles</span><br><span class="line">│           └── CMakeTmp</span><br><span class="line">├── core</span><br><span class="line">│   ├── doc</span><br><span class="line">│   │   └── doxygen</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── ikos</span><br><span class="line">│   │       └── core</span><br><span class="line">│   │           ├── adt</span><br><span class="line">│   │           │   └── patricia_tree</span><br><span class="line">│   │           ├── domain</span><br><span class="line">│   │           │   ├── exception</span><br><span class="line">│   │           │   ├── lifetime</span><br><span class="line">│   │           │   ├── machine_int</span><br><span class="line">│   │           │   ├── memory</span><br><span class="line">│   │           │   │   └── value</span><br><span class="line">│   │           │   ├── nullity</span><br><span class="line">│   │           │   ├── numeric</span><br><span class="line">│   │           │   ├── pointer</span><br><span class="line">│   │           │   ├── scalar</span><br><span class="line">│   │           │   └── uninitialized</span><br><span class="line">│   │           ├── example</span><br><span class="line">│   │           │   ├── machine_int</span><br><span class="line">│   │           │   └── scalar</span><br><span class="line">│   │           ├── fixpoint</span><br><span class="line">│   │           ├── number</span><br><span class="line">│   │           ├── semantic</span><br><span class="line">│   │           │   ├── machine_int</span><br><span class="line">│   │           │   ├── memory</span><br><span class="line">│   │           │   │   └── value</span><br><span class="line">│   │           │   └── scalar</span><br><span class="line">│   │           ├── support</span><br><span class="line">│   │           └── value</span><br><span class="line">│   │               ├── machine_int</span><br><span class="line">│   │               ├── numeric</span><br><span class="line">│   │               └── pointer</span><br><span class="line">│   └── test</span><br><span class="line">│       └── unit</span><br><span class="line">│           ├── adt</span><br><span class="line">│           │   └── patricia_tree</span><br><span class="line">│           ├── domain</span><br><span class="line">│           │   ├── machine_int</span><br><span class="line">│           │   ├── memory</span><br><span class="line">│           │   ├── nullity</span><br><span class="line">│           │   ├── numeric</span><br><span class="line">│           │   │   └── apron</span><br><span class="line">│           │   ├── pointer</span><br><span class="line">│           │   └── uninitialized</span><br><span class="line">│           ├── example</span><br><span class="line">│           ├── fixpoint</span><br><span class="line">│           ├── number</span><br><span class="line">│           └── value</span><br><span class="line">│               ├── machine_int</span><br><span class="line">│               └── numeric</span><br><span class="line">├── doc</span><br><span class="line">│   ├── contribute</span><br><span class="line">│   └── install</span><br><span class="line">│       └── 3.0</span><br><span class="line">├── frontend</span><br><span class="line">│   └── llvm</span><br><span class="line">│       ├── include</span><br><span class="line">│       │   └── ikos</span><br><span class="line">│       │       └── frontend</span><br><span class="line">│       │           └── llvm</span><br><span class="line">│       │               └── import</span><br><span class="line">│       ├── src</span><br><span class="line">│       │   ├── import</span><br><span class="line">│       │   └── pass</span><br><span class="line">│       └── test</span><br><span class="line">│           └── regression</span><br><span class="line">│               ├── import</span><br><span class="line">│               │   ├── aggressive_optimization</span><br><span class="line">│               │   ├── basic_optimization</span><br><span class="line">│               │   └── no_optimization</span><br><span class="line">│               └── pass</span><br><span class="line">│                   ├── lower_cst_expr</span><br><span class="line">│                   ├── lower_select</span><br><span class="line">│                   ├── remove_printf_calls</span><br><span class="line">│                   └── remove_unreachable_blocks</span><br><span class="line">├── script</span><br><span class="line">└── test</span><br><span class="line">    └── install</span><br><span class="line">        ├── archlinux</span><br><span class="line">        ├── centos-6</span><br><span class="line">        ├── centos-7</span><br><span class="line">        ├── debian-10</span><br><span class="line">        ├── debian-9</span><br><span class="line">        ├── fedora-29</span><br><span class="line">        ├── fedora-30</span><br><span class="line">        ├── logs</span><br><span class="line">        ├── rhel-6</span><br><span class="line">        ├── rhel-7</span><br><span class="line">        ├── ubuntu-16.04</span><br><span class="line">        ├── ubuntu-18.04</span><br><span class="line">        └── ubuntu-19.04</span><br></pre></td></tr></table></figure>

<h2 id="ubuntu中使用命令行将应用程序默认居中"><a href="#ubuntu中使用命令行将应用程序默认居中" class="headerlink" title="ubuntu中使用命令行将应用程序默认居中"></a>ubuntu中使用命令行将应用程序默认居中</h2><p>如果您更喜欢终端，可以使用以下命令执行相同操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">gsettings <span class="keyword">set</span> org.gnome.mutter center<span class="operator">-</span><span class="keyword">new</span><span class="operator">-</span>windows <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>要获得在左上角打开应用程序的默认行为，您可以将其设置回来，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">gsettings <span class="keyword">set</span> org.gnome.mutter center<span class="operator">-</span><span class="keyword">new</span><span class="operator">-</span>windows <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="抽象解释中的活跃变量分析的作用"><a href="#抽象解释中的活跃变量分析的作用" class="headerlink" title="抽象解释中的活跃变量分析的作用"></a>抽象解释中的活跃变量分析的作用</h2><p>在抽象解释中，活跃变量分析（Live Variable Analysis）的主要作用是确定程序的哪些变量在某个点上是“活跃的”。一个变量被认为是活跃的，如果在该点之后的程序执行中，该变量的当前值可能会被读取。反之，如果一个变量在某个点之后不再被读取，那么它在该点上就不是活跃的。</p>
<p>活跃变量分析在编译器优化中非常重要，特别是在寄存器分配和死代码消除中。以下是这两个应用的简要说明：</p>
<ol>
<li><p><strong>寄存器分配</strong>：编译器需要决定将哪些变量放在有限的寄存器中，而不是内存中，以提高程序的运行速度。活跃变量分析可以帮助编译器做出这个决定，因为活跃的变量更有可能在接下来的计算中被使用。</p>
</li>
<li><p><strong>死代码消除</strong>：如果一个变量在某个点之后不再被读取，那么在该点之后对该变量的任何写入都可以被认为是“死代码”，可以被安全地删除。活跃变量分析可以帮助编译器识别这些情况，从而优化代码。</p>
</li>
</ol>
<p>总的来说，活跃变量分析是一种静态分析技术，它可以帮助编译器理解程序的行为，从而生成更有效的代码。</p>
<h2 id="IKOS不能分析浮点程序"><a href="#IKOS不能分析浮点程序" class="headerlink" title="IKOS不能分析浮点程序"></a>IKOS不能分析浮点程序</h2><p>现在先要做的是分析一下工作量的事，然后再开始做事情。</p>
<h2 id="分析举例"><a href="#分析举例" class="headerlink" title="分析举例"></a>分析举例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zou@zou-VirtualBox:~/Documents/IKOS/Fort-test/SMACKBENCHMARK/c-cp$ ikos new-compute-i.c -vvvv</span><br><span class="line">[*] Compiling new-compute-i.c</span><br><span class="line">[.] Running /usr/lib/llvm-14/bin/clang -c -emit-llvm -Wall -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0 -D__IKOS__ -g -O0 -Xclang -disable-O0-optnone new-compute-i.c -o /tmp/ikos-O5Ntiw/new-compute-i.bc -isystem /home/zou/Documents/IKOS/build/include -fcolor-diagnostics</span><br><span class="line">[*] Running ikos preprocessor</span><br><span class="line">[.] Running /home/zou/Documents/IKOS/build/bin/ikos-pp -opt=basic -entry-points=main /tmp/ikos-O5Ntiw/new-compute-i.bc -o /tmp/ikos-O5Ntiw/new-compute-i.pp.bc</span><br><span class="line">[*] Running ikos analyzer</span><br><span class="line">[.] Running /home/zou/Documents/IKOS/build/bin/ikos-analyzer -a=sound,shc,nullity,pcmp,dfa,dbg,dca,fca,prover,dbz,boa,uva,sio -d=interval -entry-points=main -globals-init=skip-big-arrays -proc=inter -j=1 -widening-strategy=widen -widening-delay=1 -widening-period=1 -narrowing-strategy=narrow -allow-dbg-mismatch -display-checks=no -display-inv=no -log=all -progress=auto /tmp/ikos-O5Ntiw/new-compute-i.pp.bc -o output.db</span><br><span class="line">[.] Creating output database &#x27;output.db&#x27;</span><br><span class="line">[.] Loading LLVM bitcode</span><br><span class="line">[.] Verifying integrity of LLVM bitcode</span><br><span class="line">[.] Checking for debug information</span><br><span class="line">[*] Translating LLVM bitcode to AR</span><br><span class="line">[.] Running type verifier on AR</span><br><span class="line">[.] Running simplify-cfg pass on AR</span><br><span class="line">[.] Running simplify-upcast-comparison pass on AR</span><br><span class="line">[*] Running liveness analysis</span><br><span class="line">[*] Running widening hint analysis</span><br><span class="line">[*] Running interprocedural value analysis</span><br><span class="line">[.] Computing global variable static initialization</span><br><span class="line">[*] Analyzing entry point &#x27;main&#x27;</span><br><span class="line">[*] Checking properties for entry point &#x27;main&#x27;</span><br><span class="line"></span><br><span class="line"># Time stats:</span><br><span class="line">clang        : 0.027 sec</span><br><span class="line">ikos-analyzer: 0.008 sec</span><br><span class="line">ikos-pp      : 0.007 sec</span><br><span class="line"></span><br><span class="line"># Summary:</span><br><span class="line">Total number of checks                : 2</span><br><span class="line">Total number of unreachable checks    : 0</span><br><span class="line">Total number of safe checks           : 1</span><br><span class="line">Total number of definite unsafe checks: 1</span><br><span class="line">Total number of warnings              : 0</span><br><span class="line"></span><br><span class="line">The program is definitely UNSAFE</span><br><span class="line"></span><br><span class="line"># Results</span><br><span class="line">new-compute-i.c: In function &#x27;main&#x27;:</span><br><span class="line">new-compute-i.c:9:12: error: division by zero</span><br><span class="line">    z  = x / (y - 1);</span><br><span class="line">           ^</span><br><span class="line">new-compute-i.c:9:12: note: called from entry point &#x27;main&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="llvm-cl-cat-AnalysisCategory-帮我解释这个用法"><a href="#llvm-cl-cat-AnalysisCategory-帮我解释这个用法" class="headerlink" title="llvm::cl::cat(AnalysisCategory)帮我解释这个用法"></a><code>llvm::cl::cat(AnalysisCategory)</code>帮我解释这个用法</h2><p>这个用法是在LLVM中的命令行选项解析库（<code>llvm::cl</code>）中使用的。<code>llvm::cl</code>库用于解析和管理命令行选项。</p>
<p><code>llvm::cl::cat()</code>函数用于将命令行选项分组到不同的类别中，以便更好地组织和显示这些选项。在函数中，<code>AnalysisCategory</code>是一个字符串参数，用于指定类别的名称。</p>
<p>示例用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/CommandLine.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="function">cl::OptionCategory <span class="title">AnalysisCategory</span><span class="params">(<span class="string">&quot;Analysis Options&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">cl::opt&lt;<span class="type">int</span>&gt; <span class="title">Opt1</span><span class="params">(<span class="string">&quot;opt1&quot;</span>, cl::desc(<span class="string">&quot;Option 1&quot;</span>), cl::cat(AnalysisCategory))</span></span>;</span><br><span class="line"><span class="function">cl::opt&lt;<span class="type">bool</span>&gt; <span class="title">Opt2</span><span class="params">(<span class="string">&quot;opt2&quot;</span>, cl::desc(<span class="string">&quot;Option 2&quot;</span>), cl::cat(AnalysisCategory))</span></span>;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了两个命令行选项<code>Opt1</code>和<code>Opt2</code>，它们都属于<code>AnalysisCategory</code>类别。这样，当我们使用命令行工具时，这些选项将被自动分组到<code>Analysis Options</code>类别中，以便更好地组织和显示这些选项。</p>
<h2 id="analyzer-src-analysis目录下的variable-cpp文件阅读"><a href="#analyzer-src-analysis目录下的variable-cpp文件阅读" class="headerlink" title="/analyzer/src/analysis目录下的variable.cpp文件阅读"></a><code>/analyzer/src/analysis</code>目录下的variable.cpp文件阅读</h2><p>在 <code>variable.cpp</code> 文件中，定义了一系列从 <code>Variable</code> 类派生的具体变量类，包括 <code>LocalVariable</code>、<code>GlobalVariable</code>、<code>InternalVariable</code> 等。以下是这些类的成员函数及其功能的简要介绍：</p>
<ol>
<li><p><strong>LocalVariable</strong>:</p>
<ul>
<li><code>LocalVariable(ar::LocalVariable* var)</code>: 构造函数，初始化本地变量对象。</li>
<li><code>void dump(std::ostream&amp; o) const</code>: 将本地变量信息输出到给定的输出流中，用于调试和可视化。</li>
</ul>
</li>
<li><p><strong>GlobalVariable</strong>:</p>
<ul>
<li><code>GlobalVariable(ar::GlobalVariable* var)</code>: 构造函数，初始化全局变量对象。</li>
<li><code>void dump(std::ostream&amp; o) const</code>: 将全局变量信息输出到给定的输出流中，用于调试和可视化。</li>
</ul>
</li>
<li><p><strong>InternalVariable</strong>:</p>
<ul>
<li><code>InternalVariable(ar::InternalVariable* var)</code>: 构造函数，初始化内部变量对象。</li>
<li><code>void dump(std::ostream&amp; o) const</code>: 将内部变量信息输出到给定的输出流中，用于调试和可视化。</li>
</ul>
</li>
<li><p><strong>InlineAssemblyPointerVariable</strong>:</p>
<ul>
<li><code>InlineAssemblyPointerVariable(ar::InlineAssemblyConstant* inline_asm)</code>: 构造函数，初始化内联汇编指针变量。</li>
<li><code>void dump(std::ostream&amp; o) const</code>: 将内联汇编指针变量信息输出到给定的输出流中，用于调试和可视化。</li>
</ul>
</li>
<li><p><strong>FunctionPointerVariable</strong>:</p>
<ul>
<li><code>FunctionPointerVariable(ar::Function* fun)</code>: 构造函数，初始化函数指针变量。</li>
<li><code>void dump(std::ostream&amp; o) const</code>: 将函数指针变量信息输出到给定的输出流中，用于调试和可视化。</li>
</ul>
</li>
<li><p><strong>CellVariable</strong>:</p>
<ul>
<li><code>CellVariable(ar::Type* type, MemoryLocation* address, MachineInt offset, MachineInt size)</code>: 构造函数，初始化内存单元变量。</li>
<li><code>void dump(std::ostream&amp; o) const</code>: 将内存单元变量信息输出到给定的输出流中，用于调试和可视化。</li>
</ul>
</li>
<li><p><strong>OffsetVariable</strong>:</p>
<ul>
<li><code>OffsetVariable(ar::Type* type, Variable* pointer)</code>: 构造函数，初始化偏移变量。</li>
<li><code>void dump(std::ostream&amp; o) const</code>: 将偏移变量信息输出到给定的输出流中，用于调试和可视化。</li>
</ul>
</li>
<li><p><strong>AllocSizeVariable</strong>:</p>
<ul>
<li><code>AllocSizeVariable(ar::Type* type, MemoryLocation* address)</code>: 构造函数，初始化分配大小变量。</li>
<li><code>void dump(std::ostream&amp; o) const</code>: 将分配大小变量信息输出到给定的输出流中，用于调试和可视化。</li>
</ul>
</li>
<li><p><strong>ReturnVariable</strong>:</p>
<ul>
<li><code>ReturnVariable(ar::Function* fun)</code>: 构造函数，初始化返回值变量。</li>
<li><code>void dump(std::ostream&amp; o) const</code>: 将返回值变量信息输出到给定的输出流中，用于调试和可视化。</li>
</ul>
</li>
<li><p><strong>NamedShadowVariable</strong>:</p>
<ul>
<li><code>NamedShadowVariable(ar::Type* type, std::string name)</code>: 构造函数，初始化具名影子变量。</li>
<li><code>void dump(std::ostream&amp; o) const</code>: 将具名影子变量信息输出到给定的输出流中，用于调试和可视化。</li>
</ul>
</li>
<li><p><strong>UnnamedShadowVariable</strong>:</p>
<ul>
<li><code>UnnamedShadowVariable(ar::Type* type, std::size_t id)</code>: 构造函数，初始化匿名影子变量。</li>
<li><code>void dump(std::ostream&amp; o) const</code>: 将匿名影子变量信息输出到给定的输出流中，用于调试和可视化。</li>
</ul>
</li>
</ol>
<p>这些具体变量类是 IKOS 静态分析工具中用于表示程序变量的关键组件，每个类都提供了适用于其特定类型的方法。通过这些方法，IKOS 能够有效地处理各种不同类型的程序变量，支持静态分析的实施。这些方法中的 <code>dump</code> 方法用于将变量信息输出到标准输出或文件中，以帮助开发人员进行调试和分析。</p>
<p>这是 <code>VariableFactory</code> 类的实现，它用于创建不同类型的变量对象。以下是 <code>VariableFactory</code> 的主要成员函数及其功能：</p>
<ol>
<li><p><code>VariableFactory::VariableFactory(ar::Bundle* bundle)</code>：构造函数，接受一个 ar::Bundle 对象，并初始化 <code>_ar_context</code> 和 <code>_size_type</code> 成员。</p>
</li>
<li><p><code>VariableFactory::~VariableFactory()</code>：析构函数，通常不执行任何操作，因为智能指针会自动释放内存。</p>
</li>
<li><p><code>VariableFactory::get_local(ar::LocalVariable* var)</code>：创建并返回一个 <code>LocalVariable</code> 对象，如果已经存在具有相同参数的对象，则返回现有对象。这个函数用于获取局部变量。</p>
</li>
<li><p><code>VariableFactory::get_global(ar::GlobalVariable* var)</code>：创建并返回一个 <code>GlobalVariable</code> 对象，如果已经存在具有相同参数的对象，则返回现有对象。这个函数用于获取全局变量。</p>
</li>
<li><p><code>VariableFactory::get_internal(ar::InternalVariable* var)</code>：创建并返回一个 <code>InternalVariable</code> 对象，如果已经存在具有相同参数的对象，则返回现有对象。这个函数用于获取内部变量。</p>
</li>
<li><p><code>VariableFactory::get_asm_ptr(ar::InlineAssemblyConstant* cst)</code>：创建并返回一个 <code>InlineAssemblyPointerVariable</code> 对象，如果已经存在具有相同参数的对象，则返回现有对象。这个函数用于获取内联汇编指令的指针。</p>
</li>
<li><p><code>VariableFactory::get_function_ptr(ar::Function* fun)</code>：创建并返回一个 <code>FunctionPointerVariable</code> 对象，如果已经存在具有相同参数的对象，则返回现有对象。这个函数用于获取函数指针。</p>
</li>
<li><p><code>VariableFactory::get_function_ptr(ar::FunctionPointerConstant* cst)</code>：基于函数指针常量创建并返回一个 <code>FunctionPointerVariable</code> 对象。这个函数用于获取函数指针。</p>
</li>
<li><p><code>VariableFactory::get_cell(MemoryLocation* address, const MachineInt&amp; offset, const MachineInt&amp; size, Signedness sign)</code>：创建并返回一个 <code>CellVariable</code> 对象，如果已经存在具有相同参数的对象，则返回现有对象。这个函数用于获取内存单元变量，通常表示整数、浮点数或指针。</p>
</li>
<li><p><code>VariableFactory::get_alloc_size(MemoryLocation* address)</code>：创建并返回一个 <code>AllocSizeVariable</code> 对象，如果已经存在具有相同参数的对象，则返回现有对象。这个函数用于获取分配大小变量。</p>
</li>
<li><p><code>VariableFactory::get_return(ar::Function* fun)</code>：创建并返回一个 <code>ReturnVariable</code> 对象，如果已经存在具有相同参数的对象，则返回现有对象。这个函数用于获取函数返回变量。</p>
</li>
<li><p><code>VariableFactory::get_named_shadow(ar::Type* type, llvm::StringRef name)</code>：创建并返回一个 <code>NamedShadowVariable</code> 对象，如果已经存在具有相同参数的对象，则返回现有对象。这个函数用于获取具有命名的阴影变量。</p>
</li>
<li><p><code>VariableFactory::create_unnamed_shadow(ar::Type* type)</code>：创建并返回一个 <code>UnnamedShadowVariable</code> 对象，具有未命名的阴影变量。这个函数用于创建未命名的阴影变量。</p>
</li>
</ol>
<p>这些函数允许您创建不同类型的变量对象，每个对象都表示不同的程序元素，例如局部变量、全局变量、内部变量、函数指针、内存单元、分配大小等。通过创建这些变量对象，您可以在静态分析工具中表示和跟踪程序的状态和数据流，以支持静态代码分析。此外，它们还可以帮助记录和可视化分析工具的内部状态以进行调试和分析。</p>
<h2 id="analyzer-include-ikos-analyzer-analysis目录下的fixpoint-parameters-hpp文件解读"><a href="#analyzer-include-ikos-analyzer-analysis目录下的fixpoint-parameters-hpp文件解读" class="headerlink" title="/analyzer/include/ikos/analyzer/analysis目录下的fixpoint_parameters.hpp文件解读"></a><code>/analyzer/include/ikos/analyzer/analysis</code>目录下的fixpoint_parameters.hpp文件解读</h2><p><code>WideningHints</code> 类用于表示控制流图（CFG）中循环的加宽提示（Widening Hints）。在静态分析中，加宽是指在计算不动点（Fixpoint）时，为了加快收敛速度，选择放宽约束条件的过程。加宽提示是一种机制，用于为分析器提供循环迭代时何时加宽的建议或提示。</p>
<p>以下是 <code>WideningHints</code> 类的主要成员和作用：</p>
<ul>
<li><p><code>Map _map</code>：一个私有的成员变量，它是一个映射（Map），将循环的头部（Cycle Head，通常是循环的入口基本块）与加宽提示（<code>MachineInt</code> 类型的整数值）相关联。这个映射表示不同循环头部的加宽提示。</p>
</li>
<li><p><code>get(ar::BasicBlock* head) const</code> 函数：用于获取与给定循环头部相关联的加宽提示。如果存在与给定循头部相关联的加宽提示，则返回一个 <code>MachineInt</code> 类型的不可选引用；否则，返回一个空的 <code>boost::optional</code>。</p>
</li>
<li><p><code>add(ar::BasicBlock* head, const MachineInt&amp; hint)</code> 函数：用于为给定的循环头部添加加宽提示。这个函数将循环头部和相应的加宽提示加入映射 <code>_map</code> 中，以备后续使用。</p>
</li>
<li><p><code>begin()</code> 和 <code>end()</code> 函数：用于返回迭代器，可以用于遍历所有循环头部及其加宽提示。<code>begin()</code> 函数返回映射的起始迭代器，<code>end()</code> 函数返回映射的结束迭代器，这样可以轻松地遍历所有加宽提示。</p>
</li>
</ul>
<p><code>WideningHints</code> 类的主要目的是在静态分析中协助控制收敛速度，特别是在涉及循环的情况下。通过为不同的循环头部提供加宽提示，分析器可以更好地选择何时进行加宽操作，以加快不动点的计算速度，同时保持分析的精度。这有助于处理复杂的程序结构，如循环，而不会导致分析无限循环。</p>
<p><code>CodeFixpointParameters</code> 类用于表示控制流图（CFG）中的不动点分析参数，这些参数用于配置不动点分析的行为。在静态分析中，不动点分析用于逐步近似程序的状态，以查找可能的程序状态空间，以检测错误或属性。这些参数控制分析中的加宽和缩窄策略、循环处理以及其他关键方面。</p>
<p>以下是 <code>CodeFixpointParameters</code> 类的主要成员和作用：</p>
<ul>
<li><p><code>WideningStrategy widening_strategy</code>：表示不动点分析中的加宽策略。加宽策略是在每次迭代时决定何时进行加宽的策略，以加速不动点的收敛。这可以是一种启发式方法，例如按照循环迭代的次数来决定是否进行加宽。</p>
</li>
<li><p><code>NarrowingStrategy narrowing_strategy</code>：表示不动点分析中的缩窄策略。缩窄策略是在已经达到一个近似的不动点后，决定如何缩窄精度以提高精确度的策略。</p>
</li>
<li><p><code>unsigned widening_delay</code>：表示不动点分析中的加宽延迟。它指定了在开始执行加宽操作之前的循环迭代次数。通常，在初始迭代中，分析器可能需要保持较高的精度，然后逐渐放宽以提高分析的速度。</p>
</li>
<li><p><code>unsigned widening_period</code>：表示循环迭代之间执行加宽的间隔。这决定了在循环中何时执行加宽操作。例如，如果设置为5，那么在第5个迭代之后，将执行一次加宽操作。</p>
</li>
<li><p><code>boost::optional&lt;unsigned&gt; narrowing_iterations</code>：表示缩窄操作的固定次数。如果设置为 <code>boost::none</code>，则表示分析器将执行缩窄操作，直到达到收敛状态为止。</p>
</li>
<li><p><code>WideningHints widening_hints</code>：表示循环的加宽提示。它是 <code>WideningHints</code> 类型的对象，用于为循环提供加宽提示，以帮助分析器更好地控制何时进行加宽操作。</p>
</li>
</ul>
<p><code>CodeFixpointParameters</code> 类的目的是配置不动点分析的行为，以在控制流图中对程序状态进行逐步近似。这些参数允许分析器根据特定的分析需求和性能要求来调整不动点分析的方式，以实现准确性和效率的平衡。这些参数通常在不同的程序部分和函数之间可能会有所不同，以满足不同部分的分析需求。</p>
<p><code>FixpointParameters</code> 类用于表示整个程序的不动点分析参数。在静态分析中，不动点分析是一种常见的技术，用于逐步逼近程序状态以查找可能的程序状态空间，以检测错误或属性。这些参数配置了程序中不同函数的不动点分析行为，以便在每个函数中进行适当的配置。</p>
<p>以下是 <code>FixpointParameters</code> 类的主要成员和作用：</p>
<ul>
<li><p><code>_default_params</code>：表示默认的不动点分析参数，用于所有函数，除非为特定函数配置了不同的参数。这允许用户为整个程序的大多数函数设置默认的分析策略。</p>
</li>
<li><p><code>_map</code>：是一个映射，将函数（<code>ar::Function*</code>）映射到其特定的不动点分析参数。这允许用户为特定的函数配置不同的不动点分析参数，以满足其特定的分析需求。</p>
</li>
</ul>
<p><code>FixpointParameters</code> 类的目的是提供一种机制，通过该机制可以为整个程序以及程序中的每个函数配置不同的不动点分析策略。这允许开发人员根据不同函数的特定需求来调整不动点分析的方式，以平衡准确性和性能。</p>
<p>这种分层配置的方式使得可以为整个程序定义一组默认参数，然后根据需要为特定函数或部分函数提供不同的配置。这有助于适应不同函数的分析需求，以满足各种不同类型的代码的要求。</p>
<h2 id="using的用法"><a href="#using的用法" class="headerlink" title="using的用法"></a><code>using</code>的用法</h2><p><code>using</code> 语法用于引入命名空间中的成员或其他作用域中的成员，以使其在当前作用域内可用，从而简化代码编写和提高可读性。下面是使用 <code>using</code> 的示例：</p>
<ol>
<li><strong>引入命名空间成员</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 std 命名空间中的 cout</span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，使用 <code>using</code> 引入了 <code>std::cout</code> 和 <code>std::endl</code>，使它们可以在 <code>main</code> 函数中直接使用，而无需在前面加上 <code>std::</code> 前缀。</p>
<ol start="2">
<li><strong>引入类型别名</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个类型别名</span></span><br><span class="line"><span class="keyword">using</span> MyInt = <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyInt x = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，使用 <code>using</code> 创建了一个类型别名 <code>MyInt</code>，将 <code>MyInt</code> 视为 <code>int</code> 的同义词，因此可以在代码中使用 <code>MyInt</code> 来声明整数变量。</p>
<ol start="3">
<li><strong>引入类的成员</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="comment">// 使用 using 引入类的成员函数</span></span><br><span class="line">    <span class="keyword">using</span> obj.memberFunction;</span><br><span class="line">    <span class="built_in">memberFunction</span>(); <span class="comment">// 等效于 obj.memberFunction()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，使用 <code>using</code> 引入了 <code>obj</code> 对象的 <code>memberFunction</code>，从而可以直接调用 <code>memberFunction</code> 而不需要使用 <code>obj</code> 对象。</p>
<p><code>using</code> 的使用有助于简化代码，但也需要小心，以避免引入过多的符号或可能导致歧义的符号。通常应谨慎使用 <code>using</code>，以确保代码的可读性和维护性。</p>
<h2 id="core-include-ikos-core-number目录下的z-number-hpp文件解读"><a href="#core-include-ikos-core-number目录下的z-number-hpp文件解读" class="headerlink" title="/core/include/ikos/core/number目录下的z_number.hpp文件解读"></a><code>/core/include/ikos/core/number</code>目录下的z_number.hpp文件解读</h2><p><code>ZNumber</code>类的运算符重载函数怎么使用的？</p>
<p><code>ZNumber</code> 类中的运算符重载函数允许你像使用内置整数类型一样对 <code>ZNumber</code> 对象执行各种算术和比较运算。以下是 <code>ZNumber</code> 类中一些重要的运算符重载函数，以及它们是如何定义和使用的：</p>
<ol>
<li><p><strong>加法运算符重载</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ZNumber <span class="keyword">operator</span>+(<span class="type">const</span> ZNumber&amp; lhs, <span class="type">const</span> ZNumber&amp; rhs);</span><br></pre></td></tr></table></figure>

<p>这个运算符重载允许你对两个 <code>ZNumber</code> 对象执行加法操作。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ZNumber a = <span class="number">10</span>;</span><br><span class="line">ZNumber b = <span class="number">20</span>;</span><br><span class="line">ZNumber result = a + b; <span class="comment">// result 现在包含 30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>减法运算符重载</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ZNumber <span class="keyword">operator</span>-(<span class="type">const</span> ZNumber&amp; lhs, <span class="type">const</span> ZNumber&amp; rhs);</span><br></pre></td></tr></table></figure>

<p>这个运算符重载允许你对两个 <code>ZNumber</code> 对象执行减法操作。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ZNumber a = <span class="number">30</span>;</span><br><span class="line">ZNumber b = <span class="number">20</span>;</span><br><span class="line">ZNumber result = a - b; <span class="comment">// result 现在包含 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>乘法运算符重载</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ZNumber <span class="keyword">operator</span>*(<span class="type">const</span> ZNumber&amp; lhs, <span class="type">const</span> ZNumber&amp; rhs);</span><br></pre></td></tr></table></figure>

<p>这个运算符重载允许你对两个 <code>ZNumber</code> 对象执行乘法操作。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ZNumber a = <span class="number">5</span>;</span><br><span class="line">ZNumber b = <span class="number">6</span>;</span><br><span class="line">ZNumber result = a * b; <span class="comment">// result 现在包含 30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>除法运算符重载</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ZNumber <span class="keyword">operator</span>/(<span class="type">const</span> ZNumber&amp; lhs, <span class="type">const</span> ZNumber&amp; rhs);</span><br></pre></td></tr></table></figure>

<p>这个运算符重载允许你对两个 <code>ZNumber</code> 对象执行除法操作。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ZNumber a = <span class="number">30</span>;</span><br><span class="line">ZNumber b = <span class="number">5</span>;</span><br><span class="line">ZNumber result = a / b; <span class="comment">// result 现在包含 6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>比较运算符重载</strong>：</p>
<p>以下比较运算符允许你比较两个 <code>ZNumber</code> 对象的大小关系：</p>
<ul>
<li><code>operator==</code>：相等比较</li>
<li><code>operator!=</code>：不等比较</li>
<li><code>operator&lt;</code>：小于比较</li>
<li><code>operator&lt;=</code>：小于或等于比较</li>
<li><code>operator&gt;</code>：大于比较</li>
<li><code>operator&gt;=</code>：大于或等于比较</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ZNumber a = <span class="number">10</span>;</span><br><span class="line">ZNumber b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">    <span class="comment">// 这个条件为真</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些运算符重载函数让你可以像操作内置整数类型一样操作 <code>ZNumber</code> 对象，使代码更加直观和易读。通过运算符重载，你可以利用 <code>ZNumber</code> 类的功能，执行各种整数运算，包括加法、减法、乘法、除法，以及比较操作。</p>
<h2 id="log类中的打印信息使用方法"><a href="#log类中的打印信息使用方法" class="headerlink" title="log类中的打印信息使用方法"></a><code>log</code>类中的打印信息使用方法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// \brief Write a log message</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> LogMessage&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> LogMessage&amp; msg, T&amp;&amp; v) &#123;</span><br><span class="line">  msg.<span class="built_in">stream</span>() &lt;&lt; std::forward&lt; T &gt;(v);</span><br><span class="line">  <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个重载的输出操作符 <code>&lt;&lt;</code>，它允许您将各种类型的数据附加到 <code>LogMessage</code> 对象上，以便将它们记录到日志中。这个函数模板可以接受任何类型 <code>T</code> 的参数，并将该参数的内容附加到 <code>LogMessage</code> 对象的输出流中。</p>
<p>这是一个非常常见的日志记录方法，它允许您以可读的方式将各种数据（例如字符串、数字、对象等）记录到日志中。在C++中，<code>&lt;&lt;</code> 操作符被广泛用于将数据附加到输出流中，这里的代码片段扩展了这一概念，以便将日志消息与各种数据结合起来。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ikos::<span class="function">analyzer::TerminalLogger <span class="title">logger</span><span class="params">(std::cout)</span></span>;</span><br><span class="line">  ikos::analyzer::log::<span class="built_in">set_logger</span>(logger);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">  std::string message = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个日志消息</span></span><br><span class="line">  ikos::analyzer::LogMessage logMessage = ikos::analyzer::log::<span class="built_in">msg</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用输出操作符将数据添加到日志消息中</span></span><br><span class="line">  logMessage &lt;&lt; <span class="string">&quot;The answer is: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;. &quot;</span> &lt;&lt; message;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，我们首先创建一个 <code>LogMessage</code> 对象，然后使用 <code>&lt;&lt;</code> 操作符将整数 <code>x</code> 和字符串 <code>message</code> 附加到该日志消息中。最终，该日志消息将被记录，并输出到终端上。</p>
<h2 id="log输出信息"><a href="#log输出信息" class="headerlink" title="log输出信息"></a><code>log</code>输出信息</h2><p>这段代码片段检查一个名为 <code>DisplayPointer</code> 的条件，如果条件为真，则调用 <code>pointer.dump(analyzer::log::msg().stream())</code> 函数。这段代码的作用可以分为以下几个部分：</p>
<ol>
<li><code>DisplayPointer</code> 是一个条件，它用于检查是否应该执行后续的操作。</li>
<li><code>analyzer::log::msg().stream()</code> 创建一个日志消息对象，并返回该消息对象的输出流。</li>
<li><code>pointer.dump(analyzer::log::msg().stream())</code> 调用了一个名为 <code>dump</code> 的成员函数，该函数将 <code>pointer</code> 对象的内容输出到日志消息对象的输出流中。</li>
</ol>
<p>在这个代码片段中，如果 <code>DisplayPointer</code> 为真，将会执行 <code>pointer.dump</code> 操作，将 <code>pointer</code> 对象的内容记录到日志消息中。这通常用于调试和跟踪程序中的特定变量或对象的状态。如果 <code>DisplayPointer</code> 为假，<code>pointer.dump</code> 操作将不会执行。</p>
<p>这种方式可以方便地将特定对象的信息记录到日志中，以便进行排查和调试。在调试期间，开发人员可以将 <code>DisplayPointer</code> 设置为真，以查看 <code>pointer</code> 对象的信息，而在正式发布或不需要这些信息时，可以将 <code>DisplayPointer</code> 设置为假，以避免记录不必要的信息。</p>
<h2 id="QNumber类的构造函数及其用法"><a href="#QNumber类的构造函数及其用法" class="headerlink" title="QNumber类的构造函数及其用法"></a><code>QNumber</code>类的构造函数及其用法</h2><p><code>QNumber</code> 类具有多个构造函数，用于不同的方式来初始化 <code>QNumber</code> 对象。以下是这些构造函数的解释和示例：</p>
<ol>
<li><p><strong>默认构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">QNumber</span>()</span><br></pre></td></tr></table></figure>

<p>默认构造函数创建一个值为0的 <code>QNumber</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QNumber q1; <span class="comment">// 创建一个值为0的QNumber对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从整数构造</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">QNumber</span>(<span class="type">int</span> value)</span><br></pre></td></tr></table></figure>

<p>这个构造函数允许您使用整数来初始化 <code>QNumber</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QNumber <span class="title">q2</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 创建一个值为5的QNumber对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从<code>mpq_class</code>构造</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">QNumber</span>(<span class="type">const</span> mpq_class&amp; q)</span><br></pre></td></tr></table></figure>

<p>这个构造函数允许您使用 GMP 库的 <code>mpq_class</code> 类型的对象来初始化 <code>QNumber</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">mpq_class <span class="title">rational</span><span class="params">(<span class="number">3</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">QNumber <span class="title">q3</span><span class="params">(rational)</span></span>; <span class="comment">// 使用mpq_class对象初始化QNumber</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从<code>ZNumber</code>构造</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">QNumber</span>(<span class="type">const</span> ZNumber&amp; z)</span><br></pre></td></tr></table></figure>

<p>这个构造函数允许您使用自定义的 <code>ZNumber</code> 类型的对象来初始化 <code>QNumber</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ZNumber <span class="title">customInt</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="function">QNumber <span class="title">q4</span><span class="params">(customInt)</span></span>; <span class="comment">// 使用ZNumber对象初始化QNumber</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从字符串构造</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">QNumber</span>(<span class="type">const</span> std::string&amp; str, <span class="type">int</span> base = <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>这个构造函数允许您使用字符串来初始化 <code>QNumber</code> 对象。<code>base</code> 参数指定字符串的进制，如果未指定，默认为10。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string numStr = <span class="string">&quot;2/3&quot;</span>;</span><br><span class="line"><span class="function">QNumber <span class="title">q5</span><span class="params">(numStr)</span></span>; <span class="comment">// 使用字符串&quot;2/3&quot;初始化QNumber</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从分子和分母构造</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">QNumber</span>(<span class="type">const</span> ZNumber&amp; numerator, <span class="type">const</span> ZNumber&amp; denominator)</span><br></pre></td></tr></table></figure>

<p>这个构造函数允许您使用分子和分母的 <code>ZNumber</code> 对象来初始化 <code>QNumber</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ZNumber <span class="title">num</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">ZNumber <span class="title">den</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="function">QNumber <span class="title">q6</span><span class="params">(num, den)</span></span>; <span class="comment">// 使用分子4和分母7初始化QNumber</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用<code>NormalizedTag</code>构造</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">QNumber</span>(<span class="type">const</span> ZNumber&amp; numerator, <span class="type">const</span> ZNumber&amp; denominator, NormalizedTag)</span><br></pre></td></tr></table></figure>

<p>这个构造函数与上一个构造函数相同，但它创建一个已经规范化（normalized）的 <code>QNumber</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ZNumber <span class="title">num</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">ZNumber <span class="title">den</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">QNumber <span class="title">q7</span><span class="params">(num, den, NormalizedTag())</span></span>; <span class="comment">// 创建一个已规范化的QNumber</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些构造函数允许您以不同的方式初始化 <code>QNumber</code> 对象，根据需要选择合适的构造函数来创建 <code>QNumber</code> 对象。</p>
<h2 id="移动构造和复制构造的区别是什么"><a href="#移动构造和复制构造的区别是什么" class="headerlink" title="移动构造和复制构造的区别是什么"></a>移动构造和复制构造的区别是什么</h2><p>移动构造和复制构造是 C++ 中用于创建新对象的两种不同方式，它们有以下主要区别：</p>
<ol>
<li><p>目的：</p>
<ul>
<li><p>复制构造：用于创建一个新对象，新对象的内容与现有对象相同。复制构造函数通常接收常量引用（const reference）作为参数，以表示将现有对象的内容复制到新对象。</p>
</li>
<li><p>移动构造：用于创建一个新对象，并在创建新对象的同时将现有对象的资源（通常是动态分配的内存）移交给新对象。移动构造函数接收一个非常量右值引用（non-const rvalue reference）作为参数。</p>
</li>
</ul>
</li>
<li><p>参数类型：</p>
<ul>
<li><p>复制构造：接收常量引用（const reference）作为参数，因为它通常不修改传递的对象。</p>
</li>
<li><p>移动构造：接收非常量右值引用（non-const rvalue reference）作为参数，因为它需要移动资源，通常是通过窃取（move）的方式。</p>
</li>
</ul>
</li>
<li><p>行为：</p>
<ul>
<li><p>复制构造：复制对象的内容，新对象与原对象相互独立，对新对象的修改不会影响原对象。</p>
</li>
<li><p>移动构造：将现有对象的资源移交给新对象，通常通过转移指针或其他资源控制机制来实现。原对象通常会进入有效但不再可用的状态。</p>
</li>
</ul>
</li>
<li><p>使用场景：</p>
<ul>
<li><p>复制构造通常用于创建对象的副本，保留原对象的内容，适用于不想改变原对象的情况。</p>
</li>
<li><p>移动构造通常用于提高性能，避免昂贵的资源复制操作，适用于已经不再需要使用的对象的资源移交情况。</p>
</li>
</ul>
</li>
<li><p>标识符：</p>
<ul>
<li><p>复制构造的函数标识符是类名，例如 <code>MyClass(const MyClass&amp; other)</code>。</p>
</li>
<li><p>移动构造的函数标识符是类名，后面跟着 &amp;&amp;，例如 <code>MyClass(MyClass&amp;&amp; other)</code>。</p>
</li>
</ul>
</li>
</ol>
<p>总之，复制构造和移动构造在参数类型、行为和使用场景上有显著不同。复制构造用于创建对象的副本，而移动构造用于将资源从一个对象移交到另一个对象以提高性能。根据不同的情况，可以选择使用适当的构造函数。</p>
<h2 id="Bound类中的各个函数的使用方式"><a href="#Bound类中的各个函数的使用方式" class="headerlink" title="Bound类中的各个函数的使用方式"></a><code>Bound</code>类中的各个函数的使用方式</h2><p>Bound类中定义了多个函数，用于操作和查询Bound对象的属性。以下是这些函数的解释和示例用法：</p>
<p><strong>Bound构造函数</strong></p>
<p>Bound类的构造函数用于创建Bound对象。有两个重载版本，一个接受整数参数，另一个接受Number类型的参数（通常是mpq_class或mpz_class类型的有理数或整数）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Bound</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Bound</span><span class="params">(Number n)</span></span>;</span><br></pre></td></tr></table></figure>

<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Bound&lt;ZNumber&gt; <span class="title">bound1</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">// 创建一个有限数值的Bound对象</span></span><br><span class="line"><span class="function">Bound&lt;ZNumber&gt; <span class="title">bound2</span><span class="params">(ZNumber(<span class="number">10</span>))</span></span>;  <span class="comment">// 使用Number类型参数创建Bound对象</span></span><br></pre></td></tr></table></figure>

<p><strong>is_infinite函数</strong></p>
<p>is_infinite函数用于检查Bound对象是否为无穷，返回布尔值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_infinite</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Bound&lt;ZNumber&gt; <span class="title">bound1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">Bound&lt;ZNumber&gt; bound2 = Bound&lt;ZNumber&gt;::<span class="built_in">plus_infinity</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bound1.<span class="built_in">is_infinite</span>()) &#123;</span><br><span class="line">    <span class="comment">// 此Bound对象为无穷</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bound2.<span class="built_in">is_infinite</span>()) &#123;</span><br><span class="line">    <span class="comment">// 此Bound对象不是无穷</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>is_finite函数</strong></p>
<p>is_finite函数用于检查Bound对象是否为有限数值，返回布尔值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_finite</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Bound&lt;ZNumber&gt; <span class="title">bound1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">Bound&lt;ZNumber&gt; bound2 = Bound&lt;ZNumber&gt;::<span class="built_in">minus_infinity</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bound1.<span class="built_in">is_finite</span>()) &#123;</span><br><span class="line">    <span class="comment">// 此Bound对象为有限数值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bound2.<span class="built_in">is_finite</span>()) &#123;</span><br><span class="line">    <span class="comment">// 此Bound对象不是有限数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>is_plus_infinity函数</strong></p>
<p>is_plus_infinity函数用于检查Bound对象是否为正无穷，返回布尔值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_plus_infinity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Bound&lt;ZNumber&gt; <span class="title">bound1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">Bound&lt;ZNumber&gt; bound2 = Bound&lt;ZNumber&gt;::<span class="built_in">plus_infinity</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bound1.<span class="built_in">is_plus_infinity</span>()) &#123;</span><br><span class="line">    <span class="comment">// 此Bound对象为正无穷</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bound2.<span class="built_in">is_plus_infinity</span>()) &#123;</span><br><span class="line">    <span class="comment">// 此Bound对象为正无穷</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>is_minus_infinity函数</strong></p>
<p>is_minus_infinity函数用于检查Bound对象是否为负无穷，返回布尔值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_minus_infinity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Bound&lt;ZNumber&gt; <span class="title">bound1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">Bound&lt;ZNumber&gt; bound2 = Bound&lt;ZNumber&gt;::<span class="built_in">minus_infinity</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bound1.<span class="built_in">is_minus_infinity</span>()) &#123;</span><br><span class="line">    <span class="comment">// 此Bound对象为负无穷</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bound2.<span class="built_in">is_minus_infinity</span>()) &#123;</span><br><span class="line">    <span class="comment">// 此Bound对象为负无穷</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>is_zero函数</strong></p>
<p>is_zero函数用于检查Bound对象是否为零，返回布尔值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_zero</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Bound&lt;ZNumber&gt; <span class="title">bound1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Bound&lt;ZNumber&gt; <span class="title">bound2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bound1.<span class="built_in">is_zero</span>()) &#123;</span><br><span class="line">    <span class="comment">// 此Bound对象不是零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bound2.<span class="built_in">is_zero</span>()) &#123;</span><br><span class="line">    <span class="comment">// 此Bound对象为零</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>operator-函数</strong></p>
<p>operator-函数用于返回Bound对象的相反数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Bound <span class="keyword">operator</span>-() <span class="type">const</span>;</span><br></pre></td></tr></table></figure>

<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Bound&lt;ZNumber&gt; <span class="title">bound1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">Bound&lt;ZNumber&gt; neg_bound1 = -bound1; <span class="comment">// neg_bound1表示-5</span></span><br><span class="line"></span><br><span class="line">Bound&lt;ZNumber&gt; bound2 = Bound&lt;ZNumber&gt;::<span class="built_in">plus_infinity</span>();</span><br><span class="line">Bound&lt;ZNumber&gt; neg_bound2 = -bound2; <span class="comment">// neg_bound2表示负无穷</span></span><br></pre></td></tr></table></figure>

<p><strong>operator+&#x3D;函数</strong></p>
<p>operator+&#x3D;函数用于将另一个Bound对象添加到当前Bound对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">operator</span>+=(<span class="type">const</span> Bound&amp; other);</span><br></pre></td></tr></table></figure>

<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Bound&lt;ZNumber&gt; <span class="title">bound1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">Bound&lt;ZNumber&gt; <span class="title">bound2</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">bound1 += bound2; <span class="comment">// bound1现在表示8</span></span><br><span class="line"></span><br><span class="line">Bound&lt;ZNumber&gt; bound3 = Bound&lt;ZNumber&gt;::<span class="built_in">plus_infinity</span>();</span><br><span class="line">bound3 += bound2; <span class="comment">// bound3仍然表示正无穷</span></span><br></pre></td></tr></table></figure>

<p>这些函数使Bound类更容易操作和查询Bound对象的属性，可以用于数学运算、比较和其他操作。</p>
<h2 id="子类型检查模板"><a href="#子类型检查模板" class="headerlink" title="子类型检查模板"></a>子类型检查模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// \brief Equality operator with integral types</span></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T,</span><br><span class="line">           <span class="keyword">class</span> = std::<span class="type">enable_if_t</span>&lt; IsSupportedIntegral&lt; T &gt;::value &gt; &gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(T lhs, <span class="type">const</span> MachineInt&amp; rhs) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">MachineInt</span>(lhs, rhs.<span class="built_in">bit_width</span>(), rhs.<span class="built_in">sign</span>()) == rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这是一个用于比较整数类型 <code>T</code> 和 <code>MachineInt</code> 对象是否相等的相等性运算符重载函数。让我来解释其中的各个部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> = std::<span class="type">enable_if_t</span>&lt;IsSupportedIntegral&lt;T&gt;::value&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>这是一个函数模板，接受两个参数：<code>T lhs</code> 和 <code>const MachineInt&amp; rhs</code>。同时，它使用了一个额外的模板参数 <code>class</code>，用于启用 SFINAE（替代子类型无法匹配错误）。<code>std::enable_if_t</code> 是 C++ 标准库的类型特性工具，用于根据给定条件启用或禁用模板函数。</p>
<ul>
<li><code>typename T</code> 表示函数的第一个参数 <code>lhs</code> 可以是任何类型的参数。</li>
<li><code>class = std::enable_if_t&lt;IsSupportedIntegral&lt;T&gt;::value&gt;</code> 表示函数有一个额外的模板参数，通过 <code>std::enable_if_t</code> 来检查 <code>T</code> 是否为支持的整数类型。如果 <code>T</code> 是支持的整数类型，那么这个条件为真，该函数就会被启用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(T lhs, <span class="type">const</span> MachineInt&amp; rhs) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">MachineInt</span>(lhs, rhs.<span class="built_in">bit_width</span>(), rhs.<span class="built_in">sign</span>()) == rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是实际的相等性运算符的实现。</p>
<ul>
<li><code>T lhs</code> 是第一个操作数，可以是任何支持的整数类型。</li>
<li><code>const MachineInt&amp; rhs</code> 是第二个操作数，是一个 <code>MachineInt</code> 类型的常量引用。</li>
</ul>
<p>函数内部的操作是将第一个操作数 <code>lhs</code> 转换为 <code>MachineInt</code> 类型，以保证操作数具有相同的类型。然后，它使用 <code>==</code> 运算符比较转换后的 <code>lhs</code> 和 <code>rhs</code> 是否相等。</p>
<p>这个运算符的目的是允许你比较一个支持的整数类型 <code>T</code> 和一个 <code>MachineInt</code> 对象是否相等。如果相等，它将返回 <code>true</code>，否则返回 <code>false</code>。这是在将不同整数类型和 <code>MachineInt</code> 对象进行比较时非常有用的运算符重载函数。</p>
<h2 id="为什么有的地方使用struct而不是class"><a href="#为什么有的地方使用struct而不是class" class="headerlink" title="为什么有的地方使用struct而不是class"></a>为什么有的地方使用<code>struct</code>而不是<code>class</code></h2><p>在C++中，<code>struct</code> 和 <code>class</code> 都用于定义类（class）和结构体（struct），它们非常相似，但有一些细微的区别，主要是在成员访问权限和默认访问权限上有所不同。</p>
<p>关于为什么在这里使用 <code>struct</code>，主要有以下几个原因：</p>
<ol>
<li><p>默认成员访问权限：在 <code>struct</code> 中，类的成员默认是公有的（<code>public</code>），而在 <code>class</code> 中，默认是私有的（<code>private</code>）。由于这里的 <code>ZNumberAdapter</code> 结构不包含私有成员，所以它们的成员默认都是公有的，因此使用 <code>struct</code> 更符合默认的成员访问权限。</p>
</li>
<li><p>可读性：在某些情况下，使用 <code>struct</code> 可以使代码更具可读性。人们通常将 <code>struct</code> 用于表示较为简单的数据结构，而将 <code>class</code> 用于表示有更多成员函数和复杂行为的类。这有助于其他开发者更容易理解代码的意图，即使没有查看类的详细实现。</p>
</li>
<li><p>惯例：在某些代码风格规范或项目中，可能会规定在某些特定情况下使用 <code>struct</code>，例如用于表示简单数据结构或只包含公有成员的类。这是一种约定俗成的做法，有助于提高代码的一致性。</p>
</li>
</ol>
<p>在这种情况下，<code>struct</code> 的使用可能是出于上述原因中的一个或多个。它并不是绝对的规则，而是根据项目和团队的编码风格和约定来选择的。最重要的是，在这段代码中，使用 <code>struct</code> 是完全合法的，而且与代码的设计和用途相符。</p>
<h2 id="LinearExpression类的构造方法且举例说明"><a href="#LinearExpression类的构造方法且举例说明" class="headerlink" title="LinearExpression类的构造方法且举例说明"></a><code>LinearExpression</code>类的构造方法且举例说明</h2><p><code>LinearExpression</code> 类具有多种构建方法，可以创建表示线性表达式的对象。以下是这些构建方法的简要说明以及示例：</p>
<ol>
<li><p><code>LinearExpression()</code>: 默认构造函数，创建一个空的线性表达式。此构造函数将生成一个不包含任何项的表达式。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinearExpression&lt;<span class="type">int</span>, std::string&gt; empty_expr;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LinearExpression(const LinearExpression&amp;)</code>: 复制构造函数，用于从另一个线性表达式创建一个新的线性表达式。新表达式将是原表达式的副本。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinearExpression&lt;<span class="type">int</span>, std::string&gt; expr1;</span><br><span class="line"><span class="comment">// 添加一些项到 expr1</span></span><br><span class="line"><span class="function">LinearExpression&lt;<span class="type">int</span>, std::string&gt; <span class="title">expr2</span><span class="params">(expr1)</span></span>; <span class="comment">// 创建 expr2 作为 expr1 的副本</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LinearExpression(LinearExpression&amp;&amp;)</code>: 移动构造函数，用于从另一个线性表达式创建一个新的线性表达式，并将原线性表达式清空。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinearExpression&lt;<span class="type">int</span>, std::string&gt; expr1;</span><br><span class="line"><span class="comment">// 添加一些项到 expr1</span></span><br><span class="line"><span class="function">LinearExpression&lt;<span class="type">int</span>, std::string&gt; <span class="title">expr2</span><span class="params">(std::move(expr1))</span></span>; <span class="comment">// 创建 expr2 并清空 expr1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LinearExpression(const VariableExpressionT&amp;)</code>: 从变量表达式创建线性表达式。此构造函数创建一个包含单个项的线性表达式，项由给定的变量表达式表示。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VariableExpression&lt;<span class="type">int</span>, std::string&gt; <span class="title">var_expr</span><span class="params">(<span class="string">&quot;x&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">LinearExpression&lt;<span class="type">int</span>, std::string&gt; <span class="title">expr</span><span class="params">(var_expr)</span></span>; <span class="comment">// 创建一个包含单个项 x 的表达式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LinearExpression(const Number&amp;)</code>: 从常数创建线性表达式。此构造函数创建一个仅包含常数项的线性表达式。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LinearExpression&lt;<span class="type">int</span>, std::string&gt; <span class="title">expr</span><span class="params">(<span class="number">42</span>)</span></span>; <span class="comment">// 创建一个包含常数项 42 的表达式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LinearExpression(const VariableTermT&amp;)</code>: 从变量项创建线性表达式。此构造函数创建一个包含单个项的线性表达式，项由给定的变量项表示。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VariableTerm&lt;<span class="type">int</span>, std::string&gt; <span class="title">var_term</span><span class="params">(<span class="string">&quot;x&quot;</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">LinearExpression&lt;<span class="type">int</span>, std::string&gt; <span class="title">expr</span><span class="params">(var_term)</span></span>; <span class="comment">// 创建一个包含单个项 3*x 的表达式</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些构建方法允许您根据需要创建不同的线性表达式，可以包含变量、常数或它们的组合。根据具体的应用场景，您可以选择最适合的构建方法。</p>
<h2 id="介绍并举例LinearConstraintSystem类的构造函数"><a href="#介绍并举例LinearConstraintSystem类的构造函数" class="headerlink" title="介绍并举例LinearConstraintSystem类的构造函数"></a>介绍并举例<code>LinearConstraintSystem</code>类的构造函数</h2><p><code>LinearConstraintSystem</code> 类有以下构造函数，用于创建线性约束系统：</p>
<ol>
<li><p>默认构造函数：<code>LinearConstraintSystem()</code></p>
<ul>
<li>该构造函数创建一个空的线性约束系统，不包含任何约束。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinearConstraintSystem&lt;<span class="type">int</span>, Variable&gt; emptySystem;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数接受一个约束：<code>explicit LinearConstraintSystem(LinearConstraintT cst)</code></p>
<ul>
<li>通过提供一个 <code>LinearConstraint</code> 对象，创建一个包含单个约束的线性约束系统。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinearExpression&lt;<span class="type">int</span>, Variable&gt; expr = <span class="built_in">Variable</span>(<span class="string">&quot;x&quot;</span>) + <span class="number">2</span>;</span><br><span class="line"><span class="function">LinearConstraint&lt;<span class="type">int</span>, Variable&gt; <span class="title">constraint</span><span class="params">(expr, LinearConstraint&lt;<span class="type">int</span>, Variable&gt;::Equality)</span></span>;</span><br><span class="line"><span class="function">LinearConstraintSystem&lt;<span class="type">int</span>, Variable&gt; <span class="title">singleConstraintSystem</span><span class="params">(constraint)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数使用初始化列表：<code>LinearConstraintSystem(std::initializer_list&lt;LinearConstraintT&gt; csts)</code></p>
<ul>
<li>通过提供一个初始化列表，创建一个包含多个约束的线性约束系统。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinearExpression&lt;<span class="type">int</span>, Variable&gt; expr1 = <span class="built_in">Variable</span>(<span class="string">&quot;x&quot;</span>) + <span class="number">2</span>;</span><br><span class="line">LinearExpression&lt;<span class="type">int</span>, Variable&gt; expr2 = <span class="built_in">Variable</span>(<span class="string">&quot;y&quot;</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="function">LinearConstraint&lt;<span class="type">int</span>, Variable&gt; <span class="title">constraint1</span><span class="params">(expr1, LinearConstraint&lt;<span class="type">int</span>, Variable&gt;::Equality)</span></span>;</span><br><span class="line"><span class="function">LinearConstraint&lt;<span class="type">int</span>, Variable&gt; <span class="title">constraint2</span><span class="params">(expr2, LinearConstraint&lt;<span class="type">int</span>, Variable&gt;::Inequality)</span></span>;</span><br><span class="line"></span><br><span class="line">LinearConstraintSystem&lt;<span class="type">int</span>, Variable&gt; multiConstraintSystem = &#123;constraint1, constraint2&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些构造函数允许您创建不同数量和类型的线性约束系统，以满足您的需求。您可以根据具体的应用场景选择适合的构造函数。</p>
<h2 id="LinearConstraintSystem类的成员函数分析及解释"><a href="#LinearConstraintSystem类的成员函数分析及解释" class="headerlink" title="LinearConstraintSystem类的成员函数分析及解释"></a><code>LinearConstraintSystem</code>类的成员函数分析及解释</h2><p><code>LinearConstraintSystem</code> 类的成员函数提供了对线性约束系统的操作和查询功能。以下是一些主要成员函数及其用途的分析：</p>
<ol>
<li><p><code>bool empty() const</code>：</p>
<ul>
<li>用于检查线性约束系统是否为空。</li>
<li>返回 <code>true</code> 表示线性约束系统为空，没有任何约束；否则返回 <code>false</code>。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinearConstraintSystem&lt;<span class="type">int</span>, Variable&gt; emptySystem;</span><br><span class="line"><span class="type">bool</span> isEmpty = emptySystem.<span class="built_in">empty</span>(); <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>std::size_t size() const</code>：</p>
<ul>
<li>用于获取线性约束系统中包含的约束数量。</li>
<li>返回约束的数量。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinearExpression&lt;<span class="type">int</span>, Variable&gt; expr1 = <span class="built_in">Variable</span>(<span class="string">&quot;x&quot;</span>) + <span class="number">2</span>;</span><br><span class="line">LinearExpression&lt;<span class="type">int</span>, Variable&gt; expr2 = <span class="built_in">Variable</span>(<span class="string">&quot;y&quot;</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="function">LinearConstraint&lt;<span class="type">int</span>, Variable&gt; <span class="title">constraint1</span><span class="params">(expr1, LinearConstraint&lt;<span class="type">int</span>, Variable&gt;::Equality)</span></span>;</span><br><span class="line"><span class="function">LinearConstraint&lt;<span class="type">int</span>, Variable&gt; <span class="title">constraint2</span><span class="params">(expr2, LinearConstraint&lt;<span class="type">int</span>, Variable&gt;::Inequality)</span></span>;</span><br><span class="line"></span><br><span class="line">LinearConstraintSystem&lt;<span class="type">int</span>, Variable&gt; multiConstraintSystem = &#123;constraint1, constraint2&#125;;</span><br><span class="line">std::<span class="type">size_t</span> numConstraints = multiConstraintSystem.<span class="built_in">size</span>(); <span class="comment">// 返回 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>void add(LinearConstraintT cst)</code>：</p>
<ul>
<li>用于向线性约束系统中添加一个约束。</li>
<li>参数 <code>cst</code> 是要添加的约束对象。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinearExpression&lt;<span class="type">int</span>, Variable&gt; expr = <span class="built_in">Variable</span>(<span class="string">&quot;x&quot;</span>) + <span class="number">2</span>;</span><br><span class="line"><span class="function">LinearConstraint&lt;<span class="type">int</span>, Variable&gt; <span class="title">constraint</span><span class="params">(expr, LinearConstraint&lt;<span class="type">int</span>, Variable&gt;::Equality)</span></span>;</span><br><span class="line"></span><br><span class="line">LinearConstraintSystem&lt;<span class="type">int</span>, Variable&gt; constraintSystem;</span><br><span class="line">constraintSystem.<span class="built_in">add</span>(constraint); <span class="comment">// 向约束系统添加一个约束</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>void add(const LinearConstraintSystem&amp; csts)</code>：</p>
<ul>
<li>用于将另一个线性约束系统中的所有约束添加到当前线性约束系统中。</li>
<li>参数 <code>csts</code> 是包含约束的另一个线性约束系统。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinearExpression&lt;<span class="type">int</span>, Variable&gt; expr1 = <span class="built_in">Variable</span>(<span class="string">&quot;x&quot;</span>) + <span class="number">2</span>;</span><br><span class="line"><span class="function">LinearConstraint&lt;<span class="type">int</span>, Variable&gt; <span class="title">constraint1</span><span class="params">(expr1, LinearConstraint&lt;<span class="type">int</span>, Variable&gt;::Equality)</span></span>;</span><br><span class="line"></span><br><span class="line">LinearConstraintSystem&lt;<span class="type">int</span>, Variable&gt; constraintSystem1;</span><br><span class="line">constraintSystem1.<span class="built_in">add</span>(constraint1);</span><br><span class="line"></span><br><span class="line">LinearExpression&lt;<span class="type">int</span>, Variable&gt; expr2 = <span class="built_in">Variable</span>(<span class="string">&quot;y&quot;</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="function">LinearConstraint&lt;<span class="type">int</span>, Variable&gt; <span class="title">constraint2</span><span class="params">(expr2, LinearConstraint&lt;<span class="type">int</span>, Variable&gt;::Inequality)</span></span>;</span><br><span class="line"></span><br><span class="line">LinearConstraintSystem&lt;<span class="type">int</span>, Variable&gt; constraintSystem2;</span><br><span class="line">constraintSystem2.<span class="built_in">add</span>(constraint2);</span><br><span class="line"></span><br><span class="line">constraintSystem1.<span class="built_in">add</span>(constraintSystem2); <span class="comment">// 向第一个约束系统添加第二个约束系统中的约束</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>PatriciaTreeSet&lt;VariableRef&gt; variables() const</code>：</p>
<ul>
<li>用于获取线性约束系统中包含的所有变量。</li>
<li>返回一个包含所有变量的 PatriciaTreeSet 对象。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinearExpression&lt;<span class="type">int</span>, Variable&gt; expr1 = <span class="built_in">Variable</span>(<span class="string">&quot;x&quot;</span>) + <span class="number">2</span>;</span><br><span class="line">LinearExpression&lt;<span class="type">int</span>, Variable&gt; expr2 = <span class="built_in">Variable</span>(<span class="string">&quot;y&quot;</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="function">LinearConstraint&lt;<span class="type">int</span>, Variable&gt; <span class="title">constraint1</span><span class="params">(expr1, LinearConstraint&lt;<span class="type">int</span>, Variable&gt;::Equality)</span></span>;</span><br><span class="line"><span class="function">LinearConstraint&lt;<span class="type">int</span>, Variable&gt; <span class="title">constraint2</span><span class="params">(expr2, LinearConstraint&lt;<span class="type">int</span>, Variable&gt;::Inequality)</span></span>;</span><br><span class="line"></span><br><span class="line">LinearConstraintSystem&lt;<span class="type">int</span>, Variable&gt; multiConstraintSystem = &#123;constraint1, constraint2&#125;;</span><br><span class="line">PatriciaTreeSet&lt;Variable&gt; variables = multiConstraintSystem.<span class="built_in">variables</span>(); <span class="comment">// 包含变量 &quot;x&quot; 和 &quot;y&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>void dump(std::ostream&amp; o) const</code>：</p>
<ul>
<li>用于将线性约束系统的内容输出到给定的输出流，用于调试目的。</li>
<li>参数 <code>o</code> 是输出流对象。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LinearExpression&lt;<span class="type">int</span>, Variable&gt; expr1 = <span class="built_in">Variable</span>(<span class="string">&quot;x&quot;</span>) + <span class="number">2</span>;</span><br><span class="line">LinearExpression&lt;<span class="type">int</span>, Variable&gt; expr2 = <span class="built_in">Variable</span>(<span class="string">&quot;y&quot;</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="function">LinearConstraint&lt;<span class="type">int</span>, Variable&gt; <span class="title">constraint1</span><span class="params">(expr1, LinearConstraint&lt;<span class="type">int</span>, Variable&gt;::Equality)</span></span>;</span><br><span class="line"><span class="function">LinearConstraint&lt;<span class="type">int</span>, Variable&gt; <span class="title">constraint2</span><span class="params">(expr2, LinearConstraint&lt;<span class="type">int</span>, Variable&gt;::Inequality)</span></span>;</span><br><span class="line"></span><br><span class="line">LinearConstraintSystem&lt;<span class="type">int</span>, Variable&gt; multiConstraintSystem = &#123;constraint1, constraint2&#125;;</span><br><span class="line">std::ostringstream oss;</span><br><span class="line">multiConstraintSystem.<span class="built_in">dump</span>(oss); <span class="comment">// 输出约束系统内容到字符串流</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些成员函数使您能够创建、操作和查询线性约束系统，从中提取变量，检查系统是否为空以及输出约束系统的内容。这些功能对于静态分析等应用非常有用。</p>
<h2 id="分析VariableExpression类的构造函数"><a href="#分析VariableExpression类的构造函数" class="headerlink" title="分析VariableExpression类的构造函数"></a>分析VariableExpression类的构造函数</h2><p>VariableExpression 类的构造函数用于初始化 VariableExpression 对象，它接受一个 VariableRef 类型的参数作为输入。以下是 VariableExpression 类的构造函数的分析：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">VariableExpression</span><span class="params">(VariableRef var)</span> : _var(std::move(var)) &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>构造函数是显式的（explicit），这意味着它不支持隐式类型转换。只有当传入的参数类型确实是 VariableRef 时，才能使用此构造函数。</li>
<li>构造函数接受一个类型为 VariableRef 的参数 <code>var</code>，该参数表示要与 VariableExpression 对象关联的变量引用。</li>
<li><code>std::move(var)</code> 用于将传入的变量引用 <code>var</code> 移动到私有成员变量 <code>_var</code> 中，这是一种有效的资源管理方式，可以提高性能并避免不必要的拷贝。</li>
</ul>
<p>构造函数的目的是创建一个 VariableExpression 对象，使其与特定的变量引用相关联。这将允许用户在后续的操作中使用 VariableExpression 对象来表示和操作该变量。这在线性表达式和数学关系的上下文中非常有用，因为它提供了一种方便的方式来处理和操作变量。</p>
<h2 id="LinearExpression类创造带系数的线性表达式"><a href="#LinearExpression类创造带系数的线性表达式" class="headerlink" title="LinearExpression类创造带系数的线性表达式"></a><code>LinearExpression</code>类创造带系数的线性表达式</h2><p>这是 <code>LinearExpression</code> 类的构造函数，用于创建一个线性表达式，其形式为 <code>cst * var</code>，其中 <code>cst</code> 是一个整数（常数），<code>var</code> 是一个变量。这个构造函数的作用是创建一个表示线性表达式的对象，其中包含一个变量 <code>var</code> 和一个常数 <code>cst</code> 。</p>
<p>构造函数的工作原理如下：</p>
<ul>
<li>如果 <code>cst</code> 不等于0，那么将在内部 <code>_map</code> 中添加一个键值对，其中键是变量 <code>var</code>，值是 <code>cst</code>。</li>
<li>如果 <code>cst</code> 等于0，构造函数将不会添加任何内容到 <code>_map</code> 中。</li>
</ul>
<p>这个构造函数的目的是创建一个表示线性表达式的对象，以便后续可以执行各种数学运算，如加法、减法和乘法。</p>
<p>以下是一个示例，演示如何使用这个构造函数来创建一个线性表达式对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设有一个整数变量 x 和一个整数常数 cst</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> cst = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用构造函数创建线性表达式对象，表示 cst * x</span></span><br><span class="line"><span class="function">LinearExpression&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">expr</span><span class="params">(cst, x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>expr</code> 将表示线性表达式 <code>5 * x</code>，其中 <code>x</code> 是变量，<code>5</code> 是常数。您可以随后使用这个对象来进行线性表达式的各种数学运算。</p>
<h2 id="解读LinearExpression类的重载加法运算符"><a href="#解读LinearExpression类的重载加法运算符" class="headerlink" title="解读LinearExpression类的重载加法运算符"></a>解读<code>LinearExpression</code>类的重载加法运算符</h2><p>这是 <code>LinearExpression</code> 类中的一个重载的加法运算符函数，用于将一个线性表达式对象 <code>x</code> 与一个变量表达式对象 <code>y</code> 相加，并返回一个新的线性表达式对象。</p>
<p>函数的实现如下：</p>
<ol>
<li><code>x += y.var();</code> 将 <code>x</code> 与 <code>y</code> 的变量相加，也就是将 <code>y</code> 中的变量与 <code>x</code> 中的变量相加。</li>
<li>最后，返回新的线性表达式对象 <code>x</code>。</li>
</ol>
<p>这个操作允许将一个变量表达式添加到一个线性表达式中，从而扩展或更新线性表达式的内容。</p>
<p>以下是一个示例，演示如何使用这个操作符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设有一个整数变量 x 和一个整数变量表达式 y</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="function">VariableExpression&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">y</span><span class="params">(x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线性表达式对象表示 5 * x</span></span><br><span class="line">    <span class="function">LinearExpression&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">expr</span><span class="params">(<span class="number">5</span>, x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用操作符将变量表达式 y 添加到线性表达式 expr 中</span></span><br><span class="line">    expr = expr + y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; expr &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>expr</code> 最初表示线性表达式 <code>5 * x</code>，然后使用操作符 <code>+</code> 将变量表达式 <code>y</code> 添加到 <code>expr</code> 中，最终 <code>expr</code> 表示线性表达式 <code>6 * x</code>。</p>
<h2 id="literal-hpp文件中的literal类的解读"><a href="#literal-hpp文件中的literal类的解读" class="headerlink" title="literal.hpp文件中的literal类的解读"></a><code>literal.hpp</code>文件中的<code>literal</code>类的解读</h2><p><code>Literal</code>类是用于表示文字（literals）的C++类。文字可以包括机器整数、浮点数、内存位置、null、undefined以及变量。这个类使用Boost库的<code>boost::variant</code>来支持不同类型的文字，使其能够表示和操作各种不同类型的文字。</p>
<p>下面是<code>Literal</code>类的主要特点和用法：</p>
<ol>
<li><p><code>Literal</code>类的数据成员是一个<code>boost::variant</code>，这个<code>variant</code>可以容纳多种不同类型的文字。具体来说，它支持以下类型：</p>
<ul>
<li><code>MachineIntLit</code>：表示机器整数常量。</li>
<li><code>FloatingPointLit</code>：表示浮点数常量（此实现中使用<code>DummyNumber</code>表示）。</li>
<li><code>MemoryLocationLit</code>：表示内存位置常量。</li>
<li><code>NullLit</code>：表示null常量。</li>
<li><code>UndefinedLit</code>：表示undefined常量。</li>
<li><code>MachineIntVarLit</code>：表示机器整数变量。</li>
<li><code>FloatingPointVarLit</code>：表示浮点数变量。</li>
<li><code>PointerVarLit</code>：表示指针变量。</li>
</ul>
</li>
<li><p><code>Literal</code>类提供了多个构造函数，用于创建不同类型的文字，如常量机器整数、常量浮点数、常量内存位置、null、undefined以及变量。</p>
</li>
<li><p><code>Literal</code>类还提供了一组成员函数，用于检查文字的类型，例如<code>is_machine_int()</code>、<code>is_floating_point()</code>、<code>is_memory_location()</code>等，以及获取文字的值，例如<code>machine_int()</code>、<code>floating_point()</code>、<code>memory_location()</code>等。</p>
</li>
<li><p><code>Literal</code>类还支持访问者模式，允许用户定义自定义的访问者类来执行特定操作。用户可以通过创建访问者类并使用<code>apply_visitor</code>方法来访问<code>Literal</code>对象并执行自定义操作。</p>
</li>
</ol>
<p>以下是一些<code>Literal</code>类的示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个常量机器整数文字</span></span><br><span class="line">Literal&lt;VariableRef, MemoryLocationRef&gt; int_literal = Literal&lt;VariableRef, MemoryLocationRef&gt;::<span class="built_in">machine_int</span>(<span class="built_in">MachineInt</span>(<span class="number">42</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个常量浮点数文字</span></span><br><span class="line">Literal&lt;VariableRef, MemoryLocationRef&gt; float_literal = Literal&lt;VariableRef, MemoryLocationRef&gt;::<span class="built_in">floating_point</span>(<span class="built_in">DummyNumber</span>(<span class="number">3.14</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个常量内存位置文字</span></span><br><span class="line">MemoryLocationRef mem_location = <span class="comment">/* 获取内存位置的方式 */</span>;</span><br><span class="line">Literal&lt;VariableRef, MemoryLocationRef&gt; mem_literal = Literal&lt;VariableRef, MemoryLocationRef&gt;::<span class="built_in">memory_location</span>(mem_location);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个null文字</span></span><br><span class="line">Literal&lt;VariableRef, MemoryLocationRef&gt; null_literal = Literal&lt;VariableRef, MemoryLocationRef&gt;::<span class="built_in">null</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个undefined文字</span></span><br><span class="line">Literal&lt;VariableRef, MemoryLocationRef&gt; undefined_literal = Literal&lt;VariableRef, MemoryLocationRef&gt;::<span class="built_in">undefined</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个机器整数变量文字</span></span><br><span class="line">VariableRef int_variable = <span class="comment">/* 获取机器整数变量的方式 */</span>;</span><br><span class="line">Literal&lt;VariableRef, MemoryLocationRef&gt; int_var_literal = Literal&lt;VariableRef, MemoryLocationRef&gt;::<span class="built_in">machine_int_var</span>(int_variable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个浮点数变量文字</span></span><br><span class="line">VariableRef float_variable = <span class="comment">/* 获取浮点数变量的方式 */</span>;</span><br><span class="line">Literal&lt;VariableRef, MemoryLocationRef&gt; float_var_literal = Literal&lt;VariableRef, MemoryLocationRef&gt;::<span class="built_in">floating_point_var</span>(float_variable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个指针变量文字</span></span><br><span class="line">VariableRef pointer_variable = <span class="comment">/* 获取指针变量的方式 */</span>;</span><br><span class="line">Literal&lt;VariableRef, MemoryLocationRef&gt; pointer_var_literal = Literal&lt;VariableRef, MemoryLocationRef&gt;::<span class="built_in">pointer_var</span>(pointer_variable);</span><br></pre></td></tr></table></figure>

<p>这些示例演示了如何使用<code>Literal</code>类来创建不同类型的文字，以及如何检查文字的类型并获取其值。请注意，示例中的<code>VariableRef</code>和<code>MemoryLocationRef</code>类型需要根据您的具体情况进行定义和实现。</p>
]]></content>
      <categories>
        <category>log</category>
        <category>learn</category>
      </categories>
      <tags>
        <tag>project</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年11月</title>
    <url>/2023/11/01/2023%E5%B9%B411%E6%9C%88/</url>
    <content><![CDATA[<h1 id="问题日志"><a href="#问题日志" class="headerlink" title="问题日志"></a>问题日志</h1><span id="more"></span>

<h2 id="core-include-ikos-core-literal-hpp文件的作用是什么？"><a href="#core-include-ikos-core-literal-hpp文件的作用是什么？" class="headerlink" title="/core/include/ikos/core/literal.hpp文件的作用是什么？"></a><code>/core/include/ikos/core/literal.hpp</code>文件的作用是什么？</h2><p><code>literal.hpp</code> 文件是 Ikos 抽象解释框架的一部分，用于定义 <code>Literal</code> 类。<code>Literal</code> 类用于表示抽象解释中的文字（literals），即抽象域中的基本元素。这些文字可以是常量、变量或者特殊值，如<code>null</code>和<code>undefined</code>。这个类的作用是为抽象解释引擎提供表示程序状态中的值和变量的通用机制。</p>
<p>具体来说，<code>literal.hpp</code> 文件中的 <code>Literal</code> 类提供了以下功能：</p>
<ol>
<li>表示常量机器整数（<code>MachineInt</code>）和浮点数（<code>DummyNumber</code>）。</li>
<li>表示内存位置（<code>MemoryLocation</code>）。</li>
<li>表示特殊值，如<code>null</code>和<code>undefined</code>。</li>
<li>表示整数、浮点数和指针类型的变量。</li>
<li>支持比较文字之间的相等性。</li>
<li>提供访问文字的类型和值的方法。</li>
<li>支持访问者模式，以便用户可以自定义访问文字的行为。</li>
</ol>
<p><code>Literal</code> 类的设计使其适用于表示不同抽象领域中的文字，例如整数、浮点数、内存位置等。它允许抽象解释引擎轻松地操作和比较程序状态的不同方面，同时提供了灵活性以支持不同的抽象领域和需求。</p>
<p>总之，<code>literal.hpp</code> 文件的作用是定义了 <code>Literal</code> 类，为抽象解释框架提供了表示程序状态中的值和变量的通用机制，以支持静态分析和符号执行等应用。</p>
<h2 id="core-include-ikos-core-number目录下的dummy-number-hpp文件解读"><a href="#core-include-ikos-core-number目录下的dummy-number-hpp文件解读" class="headerlink" title="/core/include/ikos/core/number目录下的dummy_number.hpp文件解读"></a><code>/core/include/ikos/core/number</code>目录下的dummy_number.hpp文件解读</h2><p>这段代码定义了一个结构 <code>DummyNumber</code>，然后重载了输出流操作符 <code>&lt;&lt;</code> 用于将 <code>DummyNumber</code> 对象输出到 <code>std::ostream</code> 流。让我们对这段代码进行详细的解释：</p>
<ol>
<li><p><code>DummyNumber</code> 结构体定义：</p>
<ul>
<li><code>DummyNumber</code> 是一个简单的结构体，它没有任何成员变量或方法。它似乎被设计为一个占位符或标志，用于某些特定的情况。</li>
</ul>
</li>
<li><p>重载输出流操作符 <code>&lt;&lt;</code>：</p>
<ul>
<li><code>inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const DummyNumber&amp;)</code> 这个函数是对输出流操作符的重载。它接受一个输出流对象 <code>o</code> 和一个 <code>DummyNumber</code> 对象的常量引用（该对象未使用）。</li>
<li>在函数体内，它将字符串 “dummy” 输出到给定的输出流 <code>o</code> 中。</li>
<li>最后，它返回输出流 <code>o</code>，允许对多个输出流操作符进行级联调用。</li>
</ul>
</li>
</ol>
<p>总之，这段代码定义了一个虚拟的 <code>DummyNumber</code> 结构体，然后提供了一个 <code>&lt;&lt;</code> 输出流操作符的实现，该操作符用于将 “dummy” 字符串输出到输出流中。这可能用于在某些情况下表示未定义或无效的数值或情况。</p>
<h2 id="core-include-ikos-core-adt-patricia-tree-map-hpp文件包含的那些函数"><a href="#core-include-ikos-core-adt-patricia-tree-map-hpp文件包含的那些函数" class="headerlink" title="/core/include/ikos/core/adt/patricia_tree/map.hpp文件包含的那些函数"></a><code>/core/include/ikos/core/adt/patricia_tree/map.hpp</code>文件包含的那些函数</h2><p>这个文件包含了一系列与 Patricia Tree 有关的函数的前置声明。这些函数主要用于对 Patricia Tree 进行操作，如插入、查找、更新、删除等。以下是这些函数的解读和解释：</p>
<ol>
<li><p><code>empty</code> 函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; tree)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：检查给定的 Patricia Tree 是否为空。</li>
<li>参数：<code>tree</code> 是一个 <code>std::shared_ptr</code>，指向 Patricia Tree。</li>
<li>返回值：如果 Patricia Tree 为空，则返回 <code>true</code>；否则返回 <code>false</code>。</li>
</ul>
</li>
<li><p><code>size</code> 函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> std::<span class="type">size_t</span> <span class="title">size</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; tree)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：获取给定 Patricia Tree 中键值对的数量。</li>
<li>参数：<code>tree</code> 是一个 <code>std::shared_ptr</code>，指向 Patricia Tree。</li>
<li>返回值：返回 Patricia Tree 中键值对的数量。</li>
</ul>
</li>
<li><p><code>find_value</code> 函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> boost::optional&lt; <span class="type">const</span> Value&amp; &gt; <span class="title">find_value</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; tree,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Key&amp; key)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：在 Patricia Tree 中查找给定键对应的值。</li>
<li>参数：<code>tree</code> 是一个 <code>std::shared_ptr</code>，指向 Patricia Tree；<code>key</code> 是要查找的键。</li>
<li>返回值：如果找到键对应的值，则返回 <code>boost::optional</code> 包含该值；如果找不到，则返回 <code>boost::none</code>。</li>
</ul>
</li>
<li><p><code>leq</code> 函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Compare &gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">leq</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; s,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; t,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> Compare&amp; cmp)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：比较两个 Patricia Tree 是否满足 “小于等于” 的关系。</li>
<li>参数：<code>s</code> 和 <code>t</code> 是两个 <code>std::shared_ptr</code>，分别指向两个 Patricia Tree；<code>cmp</code> 是用于比较键的比较函数对象。</li>
<li>返回值：如果 <code>s</code> 中的所有键都小于等于 <code>t</code> 中的相应键，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
</li>
<li><p><code>equals</code> 函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Compare &gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">equals</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; s,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; t,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> Compare&amp; cmp)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：比较两个 Patricia Tree 是否相等。</li>
<li>参数：<code>s</code> 和 <code>t</code> 是两个 <code>std::shared_ptr</code>，分别指向两个 Patricia Tree；<code>cmp</code> 是用于比较键的比较函数对象。</li>
<li>返回值：如果 <code>s</code> 和 <code>t</code> 中的键值对都相同，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
</li>
</ol>
<p>这些函数的前置声明在 <code>patricia_tree_map_impl</code> 命名空间中，并在其他文件中得到实际实现。这些函数是用于管理和操作 Patricia Tree 数据结构的核心功能，使得可以高效地进行数据存储和检索操作。</p>
<p>继续解释其他函数的作用：</p>
<ol start="6">
<li><p><code>insert_or_assign</code> 函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value &gt;</span><br><span class="line"><span class="keyword">inline</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt; <span class="built_in">insert_or_assign</span>(</span><br><span class="line">    <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; tree,</span><br><span class="line">    <span class="type">const</span> Key&amp; key,</span><br><span class="line">    <span class="type">const</span> Value&amp; value);</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：向 Patricia Tree 中插入或更新一个键值对。</li>
<li>参数：<code>tree</code> 是一个 <code>std::shared_ptr</code>，指向 Patricia Tree；<code>key</code> 是要插入或更新的键；<code>value</code> 是要关联的值。</li>
<li>返回值：返回一个新的 Patricia Tree，其中包含插入或更新后的键值对。</li>
</ul>
</li>
<li><p><code>update_or_insert</code> 函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> CombiningFunction &gt;</span><br><span class="line"><span class="keyword">inline</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt; <span class="built_in">update_or_insert</span>(</span><br><span class="line">    <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; tree,</span><br><span class="line">    <span class="type">const</span> CombiningFunction&amp; combine,</span><br><span class="line">    <span class="type">const</span> Key&amp; key,</span><br><span class="line">    <span class="type">const</span> Value&amp; value);</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：根据用户定义的合并函数，更新或插入一个键值对。</li>
<li>参数：<code>tree</code> 是一个 <code>std::shared_ptr</code>，指向 Patricia Tree；<code>combine</code> 是用户定义的合并函数；<code>key</code> 是要插入或更新的键；<code>value</code> 是要关联的值。</li>
<li>返回值：返回一个新的 Patricia Tree，其中包含按照用户定义的合并函数进行更新或插入后的键值对。</li>
</ul>
</li>
<li><p><code>update_or_ignore</code> 函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> CombiningFunction &gt;</span><br><span class="line"><span class="keyword">inline</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt; <span class="built_in">update_or_ignore</span>(</span><br><span class="line">    <span class="type">const</span> std.shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; tree,</span><br><span class="line">    <span class="type">const</span> CombiningFunction&amp; combine,</span><br><span class="line">    <span class="type">const</span> Key&amp; key,</span><br><span class="line">    <span class="type">const</span> Value&amp; value);</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：根据用户定义的合并函数，更新或忽略（如果合并函数返回 <code>None</code>）一个键值对。</li>
<li>参数：<code>tree</code> 是一个 <code>std::shared_ptr</code>，指向 Patricia Tree；<code>combine</code> 是用户定义的合并函数；<code>key</code> 是要更新或插入的键；<code>value</code> 是要关联的值。</li>
<li>返回值：返回一个新的 Patricia Tree，其中包含按照用户定义的合并函数进行更新或忽略后的键值对。</li>
</ul>
</li>
</ol>
<p>这些函数提供了对 Patricia Tree 进行增删改查的操作，并允许用户使用自定义的合并函数，使其非常灵活和可定制。这对于需要高效地管理键值对的应用程序非常有用，例如静态分析和数据流分析。</p>
<p>继续解释其他函数的作用：</p>
<ol start="9">
<li><p><code>erase</code> 函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value &gt;</span><br><span class="line"><span class="keyword">inline</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt; <span class="built_in">erase</span>(</span><br><span class="line">    <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; tree,</span><br><span class="line">    <span class="type">const</span> Key&amp; key);</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：从 Patricia Tree 中移除指定键的键值对。</li>
<li>参数：<code>tree</code> 是一个 <code>std::shared_ptr</code>，指向 Patricia Tree；<code>key</code> 是要移除的键。</li>
<li>返回值：返回一个新的 Patricia Tree，其中不再包含指定键的键值对。</li>
</ul>
</li>
<li><p><code>transform</code> 函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> UnaryOp &gt;</span><br><span class="line"><span class="keyword">inline</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt; <span class="built_in">transform</span>(</span><br><span class="line">    <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; tree,</span><br><span class="line">    <span class="type">const</span> UnaryOp&amp; op);</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：应用用户定义的一元操作符（<code>UnaryOp</code>）到每个键值对上，以更新值。</li>
<li>参数：<code>tree</code> 是一个 <code>std::shared_ptr</code>，指向 Patricia Tree；<code>op</code> 是用户定义的一元操作符。</li>
<li>返回值：返回一个新的 Patricia Tree，其中包含更新后的键值对。</li>
</ul>
</li>
<li><p><code>join</code> 函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> CombiningFunction &gt;</span><br><span class="line"><span class="keyword">inline</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt; <span class="built_in">join</span>(</span><br><span class="line">    <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; s,</span><br><span class="line">    <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; t,</span><br><span class="line">    <span class="type">const</span> CombiningFunction&amp; combine);</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：将两个 Patricia Trees（<code>s</code> 和 <code>t</code>）合并为一个，根据用户定义的合并函数（<code>CombiningFunction</code>）来处理冲突。</li>
<li>参数：<code>s</code> 和 <code>t</code> 是两个 <code>std::shared_ptr</code>，指向待合并的 Patricia Trees；<code>combine</code> 是用户定义的合并函数。</li>
<li>返回值：返回一个新的 Patricia Tree，其中包含 <code>s</code> 和 <code>t</code> 合并后的键值对。</li>
</ul>
</li>
<li><p><code>intersect</code> 函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> CombiningFunction &gt;</span><br><span class="line"><span class="keyword">inline</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt; <span class="built_in">intersect</span>(</span><br><span class="line">    <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; s,</span><br><span class="line">    <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; t,</span><br><span class="line">    <span class="type">const</span> CombiningFunction&amp; combine);</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：计算两个 Patricia Trees（<code>s</code> 和 <code>t</code>）的交集，根据用户定义的合并函数（<code>CombiningFunction</code>）来处理冲突。</li>
<li>参数：<code>s</code> 和 <code>t</code> 是两个 <code>std::shared_ptr</code>，指向待计算交集的 Patricia Trees；<code>combine</code> 是用户定义的合并函数。</li>
<li>返回值：返回一个新的 Patricia Tree，其中包含 <code>s</code> 和 <code>t</code> 的交集后的键值对。</li>
</ul>
</li>
<li><p><code>binary_operation</code> 函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> BinaryOp &gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">typename</span> BinaryOp::ResultType <span class="title">binary_operation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; s,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::shared_ptr&lt; <span class="type">const</span> PatriciaTree&lt; Key, Value &gt; &gt;&amp; t,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> BinaryOp&amp; op)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>作用：执行用户定义的二元操作符（<code>BinaryOp</code>）来处理两个 Patricia Trees（<code>s</code> 和 <code>t</code>）之间的关系。</li>
<li>参数：<code>s</code> 和 <code>t</code> 是两个 <code>std::shared_ptr</code>，指向 Patricia Trees；<code>op</code> 是用户定义的二元操作符。</li>
<li>返回值：根据用户定义的二元操作符，返回一个结果，其类型由 <code>BinaryOp::ResultType</code> 指定。</li>
</ul>
</li>
</ol>
<p>这些函数扩展了 Patricia Tree 的功能，使其适用于各种用例，包括插入、更新、删除、合并、交集计算和用户定义操作等操作。这对于处理数据结构的不同需求非常有用。</p>
<h2 id="SFINAE技巧来检查类型是否符合某种特性"><a href="#SFINAE技巧来检查类型是否符合某种特性" class="headerlink" title="SFINAE技巧来检查类型是否符合某种特性"></a><code>SFINAE技巧来检查类型是否符合某种特性</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IsIndexable</span>&lt;</span><br><span class="line">    T,</span><br><span class="line">    IndexableTrait,</span><br><span class="line">    <span class="comment">// Check if IndexableTrait has: index(const T&amp;) -&gt; Index</span></span><br><span class="line">    std::<span class="type">enable_if_t</span>&lt; std::is_same&lt; Index,</span><br><span class="line">                                    <span class="keyword">decltype</span>(IndexableTrait::<span class="built_in">index</span>(</span><br><span class="line">                                        std::<span class="built_in">declval</span>&lt; T &gt;())) &gt;::value &gt; &gt;</span><br><span class="line">    : std::true_type &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这部分代码是一个SFINAE（Substitution Failure Is Not An Error）的技巧，用于检查类型是否实现了 <code>IndexableTraits</code> 的特性。让我详细解释它：</p>
<ul>
<li><p><code>IsIndexable</code> 是一个模板结构，它接受三个参数：</p>
<ol>
<li><code>T</code>：要检查的类型。</li>
<li><code>IndexableTrait</code>：用于检查 <code>T</code> 类型是否实现 <code>IndexableTraits</code> 的 traits 类型。</li>
<li>一个额外的默认模板参数，用于SFINAE。</li>
</ol>
</li>
<li><p>在这个结构中，我们使用SFINAE技巧，通过 <code>std::enable_if_t</code> 来检查特性是否存在。<code>std::enable_if_t</code> 是C++标准库提供的帮助我们进行SFINAE的工具，当条件为真时，它会启用这个结构。</p>
</li>
<li><p><code>std::is_same&lt; Index, decltype(IndexableTrait::index(std::declval&lt;T&gt;())) &gt;</code> 是条件部分。它检查 <code>IndexableTrait</code> 是否具有一个名为 <code>index</code> 的静态方法，该方法接受一个 <code>T</code> 类型对象，并返回一个 <code>Index</code> 类型。这个方法实际上是用于获取对象的唯一索引。</p>
</li>
<li><p>如果条件 <code>std::is_same&lt;...&gt;</code> 为真，表示 <code>IndexableTrait</code> 类型有一个 <code>index</code> 方法，并且这个方法返回的类型为 <code>Index</code>，那么 <code>IsIndexable</code> 的 <code>value</code> 成员将被设置为 <code>true</code>，表示类型 <code>T</code> 可以索引。</p>
</li>
</ul>
<p>因此，这段代码的目的是使用SFINAE技巧来检查类型 <code>T</code> 是否实现了 <code>IndexableTraits</code> 特性。如果是，那么 <code>IsIndexable</code> 结构体的 <code>value</code> 成员将为 <code>true</code>。这对于编写通用代码，以处理各种类型的索引对象非常有用，因为它允许您在编译时检查类型是否实现了必要的特性。</p>
<p>SFINAE（Substitution Failure Is Not An Error）是C++编程中的一种重要技巧，用于在编译时控制模板特化的选择。这个技巧允许我们通过模板元编程实现高度通用和灵活的代码，根据类型的特性来选择不同的代码路径，而不会导致编译错误。</p>
<p>SFINAE 基本思想是，如果模板实例化过程中出现错误，编译器不应该抛出错误，而是应该选择备用的模板特化。这种行为使得我们可以根据某些条件（通常是类型特性）来排除或选择模板特化。</p>
<p>SFINAE 的常见应用包括：</p>
<ol>
<li>函数重载：可以根据不同的参数类型或数量选择不同的函数重载。</li>
<li>检查类型特性：可以通过SFINAE来检查类型是否具有某些成员函数、类型别名或特定特性。</li>
<li>选择模板特化：可以根据类型特性来选择不同的模板特化。</li>
<li>禁用特定特化：可以使用SFINAE来排除某些特化。</li>
</ol>
<p>SFINAE 通常与以下工具一起使用：</p>
<ul>
<li><code>std::enable_if</code>：通过在函数模板参数中使用 <code>std::enable_if</code>，可以根据条件来启用或禁用函数模板。</li>
<li><code>std::enable_if_t</code>：是 <code>std::enable_if</code> 的C++14版本，用于更简洁的类型转发。</li>
<li><code>decltype</code>：用于获取表达式的类型，通常用于SFINAE条件的构造。</li>
<li><code>std::is_same</code>、<code>std::is_convertible</code> 等类型特性检查工具。</li>
</ul>
<p>例如，以下是一个使用SFINAE的示例，用于检查一个类型是否具有某个特定成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HasToString</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">test</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">decltype</span><span class="params">(std::declval&lt;U&gt;().toString(), std::true_type())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">test</span><span class="params">(...)</span> -&gt; std::false_type</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="keyword">decltype</span>(<span class="built_in">test</span>&lt;T&gt;(<span class="number">0</span>))::value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>HasToString</code> 结构体用于检查类型 <code>T</code> 是否具有名为 <code>toString</code> 的成员函数。通过SFINAE技巧，它会选择不同的 <code>test</code> 函数模板来检查，如果 <code>T</code> 具有 <code>toString</code> 函数，那么 <code>HasToString::value</code> 将为 <code>true</code>，否则为 <code>false</code>。</p>
<p>SFINAE 是C++中非常强大和灵活的编程技巧，允许编写更通用和类型安全的代码。它在元编程、模板元编程和类型特性检查等方面发挥着关键作用。</p>
<p><code>std::is_same</code> 和 <code>std::is_convertible</code> 是C++标准库提供的类型特性检查工具，用于在编译时检查类型关系。它们通常与SFINAE（Substitution Failure Is Not An Error）一起使用，以选择不同的代码路径或生成不同的模板特化。</p>
<ol>
<li><p><code>std::is_same</code>：</p>
<ul>
<li><code>std::is_same</code> 是一个类型特性检查工具，用于检查两个类型是否相同。</li>
<li>它的模板参数是两个类型，如果这两个类型相同，那么它的 <code>value</code> 成员变量将为 <code>true</code>，否则为 <code>false</code>。</li>
<li>这可以用于在模板编程中根据类型是否相同来选择不同的特化。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::value, <span class="string">&quot;int and int are the same&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(!std::is_same&lt;<span class="type">int</span>, <span class="type">double</span>&gt;::value, <span class="string">&quot;int and double are not the same&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>std::is_convertible</code>：</p>
<ul>
<li><code>std::is_convertible</code> 是另一个类型特性检查工具，用于检查一个类型是否可以隐式转换为另一个类型。</li>
<li>它的模板参数是两个类型，如果第一个类型可以隐式转换为第二个类型，那么它的 <code>value</code> 成员变量将为 <code>true</code>，否则为 <code>false</code>。</li>
<li>这可以用于在模板编程中检查是否可以进行类型转换。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_convertible&lt;<span class="type">int</span>, <span class="type">double</span>&gt;::value, <span class="string">&quot;int can be converted to double&quot;</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(!std::is_convertible&lt;<span class="type">double</span>, <span class="type">int</span>&gt;::value, <span class="string">&quot;double cannot be converted to int&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这两个类型特性检查工具对于编写泛型代码、模板特化和类型安全性检查非常有用。它们可以在编译时捕捉许多类型相关的错误，使代码更加健壮和安全。</p>
]]></content>
      <categories>
        <category>log</category>
        <category>learn</category>
      </categories>
      <tags>
        <tag>project</tag>
        <tag>log</tag>
      </tags>
  </entry>
</search>
