<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git的使用</title>
    <url>/2023/06/13/git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="主要介绍git的使用规则"><a href="#主要介绍git的使用规则" class="headerlink" title="主要介绍git的使用规则"></a>主要介绍git的使用规则</h2><span id="more"></span>

<p><img src="/paper_source/git%E6%8C%87%E4%BB%A4/graph.jpg"></p>
<p>一些信息查找命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git branch -al</span><br><span class="line">git branch -r</span><br></pre></td></tr></table></figure>

<p>在要推送的项目下，打开git，首先需要初始化。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>然后连接远程仓库，这个远程仓库需要自己预先建立（github或其他代码管理平台都可以），如我想连接自己的zoush99。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:zoush99/zoush99.github.io.git</span><br></pre></td></tr></table></figure>

<p>将远程仓库的某个分支拉取到本地。（第一个参数是远程分支，第二个参数是本地分支）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull --set-upstream-to=origin/source <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>将本地仓库加入到提交目录中。（加入了所有文件，也可以加入特定文件）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>提交到仓库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;提交备注&quot;</span></span><br></pre></td></tr></table></figure>

<p>上传到远程仓库。（第一个参数是远程分支，第二个参数是本地分支）如果加上参数<code>-u</code>则会将本地分支作为追踪分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>以上是完整的过程，但是还需要一些常见的指令。</p>
<p>将远程仓库的文件复制到本地。（将默认的分支拉取到本地，后面一个参数是将本地文件夹重命名为source）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:zoush99/zoush99.github.io.git <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>拉取指定分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b <span class="built_in">source</span> git@github.com:zoush99/zoush99.github.io.git <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>拉取到本地后，可以查看是哪个分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>新建并且切换为本地分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>新建本地分支，并且从远程仓库拉取代码。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b <span class="built_in">source</span> origin/source</span><br></pre></td></tr></table></figure>
<p>删除本地分支，注意要切换到其他分支后，才能删除本地分支，在当前分支时不能删除当前分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -d <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>删除远程分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin -d <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>其他需要注意的：用命令<code>git pull --set-upstream-to=origin/source source</code>将修改的远程代码拉取到本地后，直接用<code>git push origin source</code>提交，不需要<code>add</code>和<code>commit</code>，因为<code>pull=fetch+merge</code>。</p>
<p>注意<code>fetch</code>和<code>merge</code>指令和<code>pull</code>指令。</p>
<p>更新远程仓库的某个分支到本地。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>将远程仓库的某个分支下载到本地新建的分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin <span class="built_in">source</span>:<span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>将远程分支合并到本地当前分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git merge origin/source</span><br></pre></td></tr></table></figure>

<p>上面两个命令连续执行，相当于如下的<code>pull</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>版本回滚操作，回到之前的版本，防止数据丢失。</p>
<p>查看版本号。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>使用指令回到目标版本号指定的版本。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --hard 目标版本号</span><br></pre></td></tr></table></figure>

<p>再提交。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure>

<p>也可以用<code>revert</code>操作。但这里不打算介绍这种方法，看起来有些麻烦。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git pages发布页面和源代码同步脚本</title>
    <url>/2023/06/26/git-pages%E5%8F%91%E5%B8%83%E9%A1%B5%E9%9D%A2%E5%92%8C%E6%BA%90%E4%BB%A3%E7%A0%81%E5%90%8C%E6%AD%A5%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="github-pages界面和源代码同步"><a href="#github-pages界面和源代码同步" class="headerlink" title="github pages界面和源代码同步"></a>github pages界面和源代码同步</h2><span id="more"></span>

<blockquote>
<p> 为了便于自己记录并且保存自己的做项目或者生活中记录的重点事项，也为了多设备单账号协同发布。所以打算写一个脚本用来便于运行脚本分别发布并且同步源代码。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">!</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This simple script is designed to make it easier to publish my github pages and to be able to synchronize the <span class="built_in">source</span> code updates to the sourcecode branch.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &quot;the name of this scipt is publish&quot;</span><br><span class="line">echo &quot;First post on pages&quot;</span><br><span class="line">hexo g -d</span><br><span class="line"></span><br><span class="line">result=`git branch | grep &quot;*&quot;`</span><br><span class="line">curBranch=$&#123;result:2&#125;</span><br><span class="line">echo &quot;Then upload to sourcecode branch&quot;</span><br><span class="line">read -p &quot;Enter submission notes:&quot; notes</span><br><span class="line">echo &quot;Determine if the local branch is a sourcecode branch, if so, upload directly, otherwise switch to sourcecode branch and upload again&quot;</span><br><span class="line">echo &quot;Current git branch is $curBranch&quot;</span><br><span class="line">if [ $&#123;curBranch&#125; == &quot;sourcecode&quot; ]</span><br><span class="line">    then </span><br><span class="line">        echo &quot;the branch is sourcecode, upload directly&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;Switch to the sourcecode branch, then upload&quot;</span><br><span class="line">        git checkout sourcecode </span><br><span class="line">fi </span><br><span class="line"></span><br><span class="line">git pull origin sourcecode &amp;&amp;</span><br><span class="line">git add . &amp;&amp;</span><br><span class="line">git commit -m $notes &amp;&amp; </span><br><span class="line">git push origin sourcecode</span><br></pre></td></tr></table></figure>

<p>实现了简单的快捷上传操作。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Classic-Flang说明</title>
    <url>/2023/07/14/Classic-Flang%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="Flang的使用情况"><a href="#Flang的使用情况" class="headerlink" title="Flang的使用情况"></a>Flang的使用情况</h2><span id="more"></span>

<p>之前搞了那么久，现在终于得开始了解这个工具了。先慢慢使用，看看它的能力以及学习一下转换而来的LLVM IR的语法。</p>
<h2 id="安装Flang"><a href="#安装Flang" class="headerlink" title="安装Flang"></a>安装Flang</h2><p><img src="/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/%E5%AE%89%E8%A3%85Flang.jpg"></p>
<p>我安装的是github网站上的flang-compiler项目的legacy版本<a href="https://github.com/flang-compiler/flang/tree/legacy">flang-compiler&#x2F;flang at legacy (github.com)</a>。使用的安装脚本是根据网站上提供的安装脚本，并稍作修改：改进了下载版本等信息，总体而言没有做太大改进。为了保证开源包的安全性（可用性），fork到个人目录下：<a href="https://github.com/zoush99/flang/tree/legacy">zoush99&#x2F;flang at legacy (github.com)</a>。</p>
<p>为了让自己养成良好习惯，在这里记录一下安装的步骤。</p>
<p>安装LLVM需要一系列现代编译链：build-essensial和CMake的版本不低于3.3，并且应该到LLVM的网站满足所需要的依赖，才能进行安装步骤。推荐链接：<a href="http://llvm.org/docs/GettingStarted.html#host-c-toolchain-both-compiler-and-standard-library">Getting started with LLVM</a>和<a href="http://llvm.org/docs/CMake.html">CMake llvm</a>。</p>
<p>安装需要依赖后，直接安装其提供的LLVM14版本。其中的一些细节不做讨论。一些解释详见<a href="https://github.com/flang-compiler/flang/wiki/Building-Flang">Building Flang · flang-compiler&#x2F;flang Wiki (github.com)</a></p>
<p>我们这里需要直接将安装脚本罗列下来，并且依次执行即可。</p>
<p>首先是安装的初始化脚本：将CMake的命令进行初始设置，一定要提前执行。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">INSTALL_PREFIX=`<span class="built_in">pwd</span>`/install</span><br><span class="line"></span><br><span class="line"><span class="comment"># Targets to build should be one of: X86 PowerPC AArch64</span></span><br><span class="line">CMAKE_OPTIONS=<span class="string">&quot;-DCMAKE_INSTALL_PREFIX=<span class="variable">$INSTALL_PREFIX</span> \</span></span><br><span class="line"><span class="string">    -DLLVM_CONFIG=<span class="variable">$INSTALL_PREFIX</span>/bin/llvm-config \</span></span><br><span class="line"><span class="string">    -DCMAKE_CXX_COMPILER=<span class="variable">$INSTALL_PREFIX</span>/bin/clang++ \</span></span><br><span class="line"><span class="string">    -DCMAKE_C_COMPILER=<span class="variable">$INSTALL_PREFIX</span>/bin/clang \</span></span><br><span class="line"><span class="string">    -DCMAKE_Fortran_COMPILER=<span class="variable">$INSTALL_PREFIX</span>/bin/flang </span></span><br><span class="line"><span class="string">    -DCMAKE_Fortran_COMPILER_ID=Flang \</span></span><br><span class="line"><span class="string">    -DLLVM_TARGETS_TO_BUILD=X86&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后是安装llvm14的脚本，直接执行即可。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">. setup.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -d classic-flang-llvm-project ]]; <span class="keyword">then</span></span><br><span class="line">    git <span class="built_in">clone</span> -b release_14x https://github.com/zoush99/classic-flang-llvm-project.git</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> classic-flang-llvm-project</span><br><span class="line"><span class="built_in">mkdir</span> -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake <span class="variable">$CMAKE_OPTIONS</span> -DCMAKE_C_COMPILER=/usr/bin/gcc -DCMAKE_CXX_COMPILER=/usr/bin/g++ -DLLVM_ENABLE_CLASSIC_FLANG=ON -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang;openmp&quot;</span> -DCMAKE_BUILD_TYPE=Release ../llvm</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>将classic-flang-llvm-project&#x2F;build&#x2F;bin目录加入到环境变量，或install&#x2F;bin加入到环境变量。测试Clang命令是否正确执行，这时发现也会存在Flang的命令，但只是将Flang链接到Clang命令，之后安装Flang才会对Fortran程序起作用。</p>
<p>然后安装Flang的legacy版本，这个版本最近更新是在8个月前，因为要适配IKOS&#x2F;Clam，所以需要llvm14版本。目前Flang已经更新到15或更高版本。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">. setup.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -d flang ]]; <span class="keyword">then</span></span><br><span class="line">    git <span class="built_in">clone</span> -b legacy https://github.com/zoush99/flang.git</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">cd</span> flang/runtime/libpgmath</span><br><span class="line"> <span class="built_in">mkdir</span> -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"> cmake <span class="variable">$CMAKE_OPTIONS</span> ..</span><br><span class="line"> make -j4</span><br><span class="line"> sudo make install)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> flang</span><br><span class="line"><span class="built_in">mkdir</span> -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake <span class="variable">$CMAKE_OPTIONS</span> -DFLANG_LLVM_EXTENSIONS=ON ..</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>这样就把Flang安装成功，之后若使用IKOS还需要安装一个14版本的llvm，但二者相互不影响，因为他们针对不同的处理模块。等安装IKOS时需要将原有的（安装Flang所需）Clang从环境变量中移除（加注释），而安装新的llvm从而加入到环境变量中。之后需要编译IKOS时应该使用官方llvm。</p>
<p>之后所作更改时（Flang和IKOS各自）应该记住这点，因为所使用的llvm版本相同但内容不同，且不冲突。</p>
<p>安装完成后，我还需要将编译得到的一些动态或静态库复制到系统默认查询位置中<code>/usr/lib</code>或<code>/usr/local</code>。这样才算完全没问题。</p>
<h2 id="使用Flang"><a href="#使用Flang" class="headerlink" title="使用Flang"></a>使用Flang</h2><p>使用命令：</p>
<p><code> flang -help</code></p>
<p>来查找它所接受的命令，Flang本身支持所有的Clang的命令，而且支持针对Fortran特定的命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">OVERVIEW: clang LLVM compiler</span><br><span class="line"></span><br><span class="line">USAGE: clang-14 [options] file...</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -<span class="comment">###                    Print (but do not run) the commands to run for this compilation</span></span><br><span class="line">  -cpp                    Enable predefined and <span class="built_in">command</span> line preprocessor macros</span><br><span class="line">  -c                      Only run preprocess, compile, and assemble steps</span><br><span class="line">  -D &lt;macro&gt;=&lt;value&gt;      Define &lt;macro&gt; to &lt;value&gt; (or 1 <span class="keyword">if</span> &lt;value&gt; omitted)</span><br><span class="line">  -E                      Only run the preprocessor</span><br><span class="line">  -falternative-parameter-statement</span><br><span class="line">                          Enable the old style PARAMETER statement</span><br><span class="line">  -fbackslash             Specify that backslash <span class="keyword">in</span> string introduces an escape character</span><br><span class="line">  -fcolor-diagnostics     Enable colors <span class="keyword">in</span> diagnostics</span><br><span class="line">  -fdefault-double-8      Set the default double precision kind to an 8 byte wide <span class="built_in">type</span></span><br><span class="line">  -fdefault-integer-8     Set the default <span class="built_in">integer</span> kind to an 8 byte wide <span class="built_in">type</span></span><br><span class="line">  -fdefault-real-8        Set the default real kind to an 8 byte wide <span class="built_in">type</span></span><br><span class="line">  -ffixed-form            Process <span class="built_in">source</span> files <span class="keyword">in</span> fixed form</span><br><span class="line">  -ffixed-line-length-&lt;value&gt;</span><br><span class="line">                          Set line length <span class="keyword">in</span> fixed-form format Fortran, current supporting only 72 and 132 characters</span><br><span class="line">  -ffree-form             Process <span class="built_in">source</span> files <span class="keyword">in</span> free form</span><br><span class="line">  -finput-charset=&lt;value&gt; Specify the default character <span class="built_in">set</span> <span class="keyword">for</span> <span class="built_in">source</span> files</span><br><span class="line">  -fintrinsic-modules-path &lt;<span class="built_in">dir</span>&gt;</span><br><span class="line">                          Specify <span class="built_in">where</span> to find the compiled intrinsic modules</span><br><span class="line">  -flarge-sizes           Use INTEGER(KIND=8) <span class="keyword">for</span> the result <span class="built_in">type</span> <span class="keyword">in</span> size-related intrinsics</span><br><span class="line">  -fno-color-diagnostics  Disable colors <span class="keyword">in</span> diagnostics</span><br><span class="line">  -fno-fixed-form         Disable fixed-form format <span class="keyword">for</span> Fortran</span><br><span class="line">  -fno-free-form          Disable free-form format <span class="keyword">for</span> Fortran</span><br><span class="line">  -fopenacc               Enable OpenACC</span><br><span class="line">  -fopenmp                Parse OpenMP pragmas and generate parallel code.</span><br><span class="line">  -<span class="built_in">help</span>                   Display available options</span><br><span class="line">  -I &lt;<span class="built_in">dir</span>&gt;                Add directory to the end of the list of include search paths</span><br><span class="line">  -module-dir &lt;<span class="built_in">dir</span>&gt;       Put MODULE files <span class="keyword">in</span> &lt;<span class="built_in">dir</span>&gt;</span><br><span class="line">  -nocpp                  Disable predefined and <span class="built_in">command</span> line preprocessor macros</span><br><span class="line">  -o &lt;file&gt;               Write output to &lt;file&gt;</span><br><span class="line">  -pedantic               Warn on language extensions</span><br><span class="line">  -P                      Disable linemarker output <span class="keyword">in</span> -E mode</span><br><span class="line">  -std=&lt;value&gt;            Language standard to compile <span class="keyword">for</span></span><br><span class="line">  -U &lt;macro&gt;              Undefine macro &lt;macro&gt;</span><br><span class="line">  --version               Print version information</span><br><span class="line">  -W&lt;warning&gt;             Enable the specified warning</span><br><span class="line">  -Xflang &lt;arg&gt;           Pass &lt;arg&gt; to the flang compiler</span><br></pre></td></tr></table></figure>

<p>因为我们要用的只是将Fortran转成IR，而且不涉及并行程序（OpenMP），所以只用传统的一些命令行转化即可。</p>
<p>下面列举出一些可以使用的组合命令，以及它们的功能。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">flang -emit-llvm test.f90 -S -c -o test.ll</span><br><span class="line"><span class="comment"># 传统的clang命令生成llvm IR，且是可读版本.ll：汇编文件</span></span><br><span class="line">flang -emit-llvm test.f90 -c -o test.bc</span><br><span class="line"><span class="comment"># 从源码转换成机器码.bc：位码文件</span></span><br><span class="line">llvm-as test.ll -o test.bc</span><br><span class="line"><span class="comment"># 将.ll转换成.bc</span></span><br><span class="line">llvm-dis test.bc -o test.ll</span><br><span class="line"><span class="comment"># 将.bc转换成.ll</span></span><br><span class="line">lli test.bc</span><br><span class="line"><span class="comment"># 直接执行.bc文件</span></span><br><span class="line">llvm-extract --func=foo test.bc -o test-func.bc	<span class="comment"># 用test.ll也可以</span></span><br><span class="line"><span class="comment"># 从位码文件中抽取函数名为foo的函数，除了抽取函数，还可以抽取别名和全局变量</span></span><br></pre></td></tr></table></figure>

<p>一般来说，只用生成汇编文件或位码文件即可，汇编文件用来人为阅读，位码文件直接输入到IKOS中进行分析。</p>
<p>列出Clang的一些命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. .c -&gt; .i</span></span><br><span class="line">clang -E -c test.c -o test.i</span><br><span class="line"><span class="comment"># 2. .c -&gt; .bc</span></span><br><span class="line">clang -emit-llvm test.c -c -o test.bc</span><br><span class="line"><span class="comment"># 3. .c -&gt; .ll</span></span><br><span class="line">clang -emit-llvm test.c -S -o test.ll</span><br><span class="line"><span class="comment"># 4. .i -&gt; .bc</span></span><br><span class="line">clang -emit-llvm test.i -c -o test.bc</span><br><span class="line"><span class="comment"># 5. .i -&gt; .ll</span></span><br><span class="line">clang -emit-llvm test.i -S -o test.ll</span><br><span class="line"><span class="comment"># 6. .bc -&gt; .ll</span></span><br><span class="line">llvm-dis test.bc -o test.ll</span><br><span class="line"><span class="comment"># 7. .ll -&gt; .bc</span></span><br><span class="line">llvm-as test.ll -o test.bc</span><br><span class="line"><span class="comment"># 8. 多 bc 合并为一个 bc</span></span><br><span class="line">llvm-link test1.bc test2.bc -o test.bc</span><br></pre></td></tr></table></figure>

<p><img src="/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/Center.jpg" alt="img"></p>
<h2 id="Flang转换成-ll的结果"><a href="#Flang转换成-ll的结果" class="headerlink" title="Flang转换成.ll的结果"></a>Flang转换成.ll的结果</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">source_filename = <span class="string">&quot;/path/to/source.c&quot;</span></span><br><span class="line"><span class="comment"># 这里描述了源文件的名称和所在路径</span></span><br><span class="line">target datalayout = <span class="string">&quot;layout specification&quot;</span></span><br><span class="line"><span class="comment"># 这里描述了目标机器中数据的内存布局方式，包括字节序、类型以及对齐方式</span></span><br><span class="line"><span class="comment"># 这个参数对理解LLVM关系不大</span></span><br><span class="line">target triple = <span class="string">&quot;ARCHITECTURE-VENDOR-OPERATIONG_SYSTEM&quot;</span></span><br><span class="line">target triple = <span class="string">&quot;ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT&quot;</span></span><br><span class="line"><span class="comment"># 描述了目标机器是什么，从而指示后端生成相应的目标代码</span></span><br><span class="line">Identifiers</span><br><span class="line"><span class="comment"># 标识符分为：全局标识符和局部标识符。全局标识符以@开头，如全局函数、全局变量。局部标识符以%开头，类似于汇编语言中的寄存器</span></span><br><span class="line"><span class="comment"># 标识符有3种形式：</span></span><br><span class="line"><span class="comment">## 有名称的值，表示带有前缀（@或%）的字符串。如：%Val, @name</span></span><br><span class="line"><span class="comment">## 无名称的值，表示带前缀（@或%）的无符号数值。如%0, %1, @2</span></span><br><span class="line"><span class="comment">## 常量</span></span><br><span class="line">Functions</span><br><span class="line"><span class="comment"># define用于定义一个函数</span></span><br><span class="line">define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]</span><br><span class="line">       [cconv] [ret attrs]</span><br><span class="line">       &lt;ResultType&gt; @&lt;FunctionName&gt; ([argument list])</span><br><span class="line">       [(unnamed_addr|local_unnamed_addr)] [AddrSpace] [fn Attrs]</span><br><span class="line">       [section <span class="string">&quot;name&quot;</span>] [comdat [(<span class="variable">$name</span>)]] [align N] [gc] [prefix Constant]</span><br><span class="line">       [prologue Constant] [personality Constant] (!name !N)* &#123; ... &#125;</span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">define dso_local void @foo(i32 %x) <span class="comment">#0 &#123;</span></span><br><span class="line">  ; 省略 ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># define void @foo(i32 %x) &#123; ... &#125;，表示定义一个函数。其函数名称为foo，返回值的数据类型为void，参数（用%x表示）的数据类型为 i32（占用4字节的整型）</span></span><br><span class="line"><span class="comment"># #0，用于修饰函数时表示一组函数属性。这些属性定义在文件末尾</span></span><br><span class="line">  7 define weak dso_local void @foo(i32 %x) <span class="comment">#0 &#123;</span></span><br><span class="line">  8 entry:</span><br><span class="line">  9   %x.addr = alloca i32, align 4</span><br><span class="line"> 10   %y = alloca i32, align 4</span><br><span class="line"> 11   %z = alloca i32, align 4</span><br><span class="line"> 12   store i32 %x, i32* %x.addr, align 4</span><br><span class="line"> 13   %0 = load i32, i32* %x.addr, align 4</span><br><span class="line"> 14   %cmp = icmp eq i32 %0, 0</span><br><span class="line"> 15   br i1 %cmp, label %if.then, label %if.end</span><br><span class="line"> 16 </span><br><span class="line"> 17 if.then:                                          ; preds = %entry</span><br><span class="line"> 18   store i32 5, i32* %y, align 4</span><br><span class="line"> 19   br label %if.end</span><br><span class="line"> 20 </span><br><span class="line"> 21 if.end:                                           ; preds = %if.then, %entry</span><br><span class="line"> 22   %1 = load i32, i32* %x.addr, align 4</span><br><span class="line"> 23   %tobool = icmp ne i32 %1, 0</span><br><span class="line"> 24   br i1 %tobool, label %if.end2, label %if.then1</span><br><span class="line"> 25 </span><br><span class="line"> 26 if.then1:                                         ; preds = %if.end</span><br><span class="line"> 27   store i32 6, i32* %z, align 4</span><br><span class="line"> 28   br label %if.end2</span><br><span class="line"> 29 </span><br><span class="line"> 30 if.end2:                                          ; preds = %if.then1, %if.end</span><br><span class="line"> 31   ret void</span><br><span class="line"> 32 &#125;</span><br><span class="line"><span class="comment"># LLVM IR中，函数体是由基本块构成的。基本块是由一系列顺序执行的语句构成的，并（可选地）以标签作为起始。不同的标签代表不同的基本块</span></span><br><span class="line"><span class="comment"># 基本块的特点如下：</span></span><br><span class="line"><span class="comment">## 仅有一个入口，即基本块中的第一条指令</span></span><br><span class="line"><span class="comment">## 仅有一个出口，即基本块中的最后一条指令（被称为terminator instruction）。该指令要么跳转到其他基本块（不包括入口基本块），要买从函数返回</span></span><br><span class="line"><span class="comment">## 函数体中第一个出现的基本块，称为入口基本块（Entry Basic Block）。它是一个特殊的基本块，在进入函数时立即执行该基本块，并且不允许作为其他基本块的跳转目标（即不允许该基本块有前继结点）</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>project</tag>
        <tag>Flang</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年9月</title>
    <url>/2023/09/05/2023%E5%B9%B49%E6%9C%88/</url>
    <content><![CDATA[<h2 id="问题日志"><a href="#问题日志" class="headerlink" title="问题日志"></a>问题日志</h2><span id="more"></span>

<h3 id="Flang运行命令flang-function-f90-o-function-exe遇到问题："><a href="#Flang运行命令flang-function-f90-o-function-exe遇到问题：" class="headerlink" title="Flang运行命令flang function.f90 -o function.exe遇到问题："></a>Flang运行命令<code>flang function.f90 -o function.exe</code>遇到问题：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: cannot find -lflangmain</span><br><span class="line">/usr/bin/ld: cannot find -lflang</span><br><span class="line">/usr/bin/ld: cannot find -lflangrti</span><br><span class="line">/usr/bin/ld: cannot find -lpgmath</span><br><span class="line">clang-14: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure>

<p>解决办法：<a href="https://blog.51cto.com/crocodile/964277?articleABtest=1">解决&#x2F;usr&#x2F;bin&#x2F;ld: cannot find -lxxx_crocodile的记录空间的技术博客_51CTO博客</a></p>
<p>分析原因：编译Flang生成的动态库没有放到&#x2F;usr&#x2F;lib中，因此在使用时找不到该库。现在需要将这些文件放到系统指定查找的位置。</p>
<p>也就是将编译好的文件复制到默认查找的库的地址下去：<code>sudo cp -a lib* /usr/lib/</code>，这样就能解决问题了。</p>
<h3 id="linux下的so、a和o文件的区别"><a href="#linux下的so、a和o文件的区别" class="headerlink" title="linux下的so、a和o文件的区别"></a>linux下的so、a和o文件的区别</h3><p>如一个C程序，经过gcc编译后得到的依次是：.i,.s,.o。分别是预处理文件、汇编文件和二进制文件（单元编译的结果），将许多单元编译的.o文件链接成一个文件后，便是编译产物。</p>
<p>.o是中间文件，相当于windows系统下的.obj文件 。</p>
<p>.a为静态库，是好多个.o合在一起,用于静态链接， 相当于windows系统下的lib。</p>
<p>.so 为共享库，是shared object,用于动态链接的，相当于windows系统下的dll。</p>
<h3 id="gcc的编译过程"><a href="#gcc的编译过程" class="headerlink" title="gcc的编译过程"></a>gcc的编译过程</h3><p>编译过程的分步执行：<br>为了更好地理解gcc的工作过程，我们可以让在gcc工作的<strong>4个阶段</strong>中的任何一个阶段中停止下来。相关的参数有：<br><strong>-E</strong><br>预编译后停下来，生成后缀为 <strong>.i 的预编译文件</strong>。<br><strong>-c</strong><br>编译后停下来，生成后缀为 <strong>.o 的目标文件</strong>。<br><strong>-S</strong><br>汇编后停下来，生成后缀为 <strong>.s 的汇编源文件</strong>。</p>
<p>第一步：进行预编译，使用 -E 参数<br><code>gcc -E test.c -o test.i</code><br>查看 test.i 文件中的内容，会发现 stdio.h 的内容确实都插到文件里去了，而其他应当被预处理的宏定义也都做了相应的处理。<br>第二步：将 test.i 编译为目标代码，使用 -c 参数<br><code>gcc -c test.c -o test.o</code><br>第三步：生成汇编源文件<br><code>gcc -S test.c -o test.s</code><br>第四步：将生成的目标文件链接成可执行文件<br><code>gcc test.o - o test</code></p>
<p>对于稍微复杂的情况，比如有多个源代码文件、需要链接库或有其他比较特别的要求，就要给定适当的调用选项参数。</p>
<h3 id="解决Flang和IKOS适配问题的思路"><a href="#解决Flang和IKOS适配问题的思路" class="headerlink" title="解决Flang和IKOS适配问题的思路"></a>解决Flang和IKOS适配问题的思路</h3><p><img src="/paper_source/2023%E5%B9%B49%E6%9C%88/Flang%E4%B8%8EIKOS%E9%80%82%E9%85%8D%E6%80%9D%E8%B7%AF.jpg" alt="image-20230906101050110"></p>
]]></content>
      <categories>
        <category>log</category>
        <category>learn</category>
      </categories>
      <tags>
        <tag>project</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>clion的使用</title>
    <url>/2023/09/05/clion%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="将Clion作为编程工具"><a href="#将Clion作为编程工具" class="headerlink" title="将Clion作为编程工具"></a>将Clion作为编程工具</h2><span id="more"></span>

<p>首先将Clion中的一些快捷指令快速记录，以备后续之需。目前的工作主要是将Clion作为C++语言的开发工具，加上在ubuntu上使用十分方便。</p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li>ALT+1：显示隐藏工程栏</li>
<li>CTRL+&#x2F;：注释or解注释光标所在行</li>
<li>CTRL+SHIFT+&#x2F;：注释or解注释选中的多行代码</li>
<li>在某个函数的上面一行输入&#x2F;**+ENTER：快速生成某种格式的注释（for 大型项目）</li>
<li>CTRL+D：快速复制光标所在行</li>
<li>CTRL+X：快速剪切光标所在行</li>
<li>CTRL+W：实现某个字符、某个字符串、某段代码的扩选（智能扩选）</li>
<li>ALT+SHIFT+INSERT：按以下此组合建，在选中代码，可以实现多行某段代码的选中</li>
<li>CTRL+ALT+ “-” or “+” ：展开or折叠光标所在的花括号</li>
<li>CTRL+SHIFT+ “-” or “+” ：展开or折叠所有花括号</li>
<li>CTRL+鼠标左键：由函数声明跳转到函数定义 or 由函数定义跳转回函数声明</li>
<li>CTRL+ALT+R：重新格式化代码</li>
<li>ALT+ENTER：智能提示代码错误与解决方案</li>
<li>CTRL+F：匹配查找代码</li>
<li>CTRL+Z：返回编辑前</li>
<li>SHIFT+CTRL+Z：返回编辑后信息</li>
<li>CTRL+F：查找</li>
<li>CTRL+R：替换</li>
<li>CTRL+L：向后查找</li>
<li>CTRL+Shift+L：向前查找</li>
<li>CTRL+ALT+S：设置</li>
<li>Shift+F10：运行</li>
<li>Shift+F9：调试</li>
</ul>
<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><ul>
<li>单步运行（不跳转至其他标签，仅在本程序内）</li>
<li>单步运行（可调转到自己编写的库or头文件）</li>
<li>单步运行（可强制跳转到第三方库or头文件）</li>
<li>从第三方库跳回源文件</li>
<li>监测选中的变量</li>
</ul>
]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>IKOS</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>Classic-Flang说明</title>
    <url>/2023/07/14/%E5%92%8C%E7%AC%A6%E8%80%81%E5%B8%88%E8%AE%A8%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="2023-8-22"><a href="#2023-8-22" class="headerlink" title="2023-8-22"></a>2023-8-22</h2><span id="more"></span>

<p>哪些地方可以做？</p>
<p>陈：之前的想法：</p>
<p><img src="C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20230822101758868.png" alt="image-20230822101758868"></p>
<p>陈：需要考虑哪些效果预期比现在效果更好？</p>
<p>陈：利用已有前端IKOS（不变式生成能力比Clam好），先实现简单的例子，基于已有工作（博士论文，发在群里）、IC3（没听清楚）。</p>
<p>符：考虑现在比较好的方法，过程间结合图论的方法（不同的上下文调用到同一个图上，在图的算法上解决？已有很多工作做这个内容）。</p>
<p>陈：发文章需要带点新的内容，传统程序分析可能比较难，如现在流行的部分程序分析（partial），&#x3D;&#x3D;增量式程序分析（代码演化、变更时，未变更部分不用重新分析，只分析已修改部分）&#x3D;&#x3D;。</p>
<p>陈：过程间分析的瓶颈：代码量大需过程间时，在大规模和精度之间平衡？怎么找到平衡？韩国学者工作：selective上下文敏感。</p>
<p><img src="C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20230822101813289.png" alt="image-20230822101813289"></p>
<p>符：抽象解释解决嵌套循环问题困难，约束求解相对较好？</p>
<p>陈：应用场景的结合：数组（约束求解做过相关工作，但比较初级）、浮点（未做过相关工作，有待考虑）、过程间？</p>
<p>符：数组，自动分段，10年左右提出，进展较少。</p>
<p>符：浮点，基于约束的方法，相比于数组创新力更强。</p>
<p>陈：增量式程序分析：约束求解和抽象解释能否结合？（incremental）</p>
]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>chat</tag>
      </tags>
  </entry>
  <entry>
    <title>ikos的使用</title>
    <url>/2023/09/05/ikos%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="IKOS-Analyzer"><a href="#IKOS-Analyzer" class="headerlink" title="IKOS Analyzer"></a>IKOS Analyzer</h1><span id="more"></span>

<p>This folder contains the implementation of the analyzer.</p>
<h2 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h2><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#installation">Installation</a><ul>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#build-and-install">Build and Install</a></li>
<li><a href="#tests">Tests</a></li>
<li><a href="#documentation">Documentation</a></li>
</ul>
</li>
<li><a href="#how-to-run-ikos">How to run IKOS</a></li>
<li><a href="#analyze-a-whole-project-with-ikos-scan">Analyze a whole project with ikos-scan</a></li>
<li><a href="#examine-a-report-with-ikos-view">Examine a report with ikos-view</a></li>
<li><a href="#analysis-options">Analysis Options</a><ul>
<li><a href="#checks">Checks</a></li>
<li><a href="#numerical-abstract-domains">Numerical abstract domains</a></li>
<li><a href="#entry-points">Entry points</a></li>
<li><a href="#multi-threading">Multi-threading</a></li>
<li><a href="#optimization-level">Optimization level</a></li>
<li><a href="#inter-procedural-vs-intra-procedural">Inter-procedural vs Intra-procedural</a></li>
<li><a href="#fixpoint-engine-parameters">Fixpoint engine parameters</a></li>
<li><a href="#partitioning">Partitioning</a></li>
<li><a href="#hardware-addresses">Hardware addresses</a></li>
<li><a href="#other-analysis-options">Other analysis options</a></li>
</ul>
</li>
<li><a href="#report-options">Report Options</a><ul>
<li><a href="#format">Format</a></li>
<li><a href="#file">File</a></li>
<li><a href="#status-filter">Status Filter</a></li>
<li><a href="#analysis-filter">Analysis Filter</a></li>
<li><a href="#verbosity">Verbosity</a></li>
<li><a href="#other-report-options">Other report options</a></li>
</ul>
</li>
<li><a href="#apron-support">APRON Support</a></li>
<li><a href="#analysis-assumptions">Analysis Assumptions</a></li>
<li><a href="#analyze-an-embedded-software-requiring-a-cross-compiler">Analyze an embedded software requiring a cross-compiler</a></li>
<li><a href="#model-library-functions-to-reduce-warnings">Model library functions to reduce warnings</a></li>
<li><a href="#overview-of-the-source-code">Overview of the source code</a></li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The IKOS Analyzer is an abstract interpretation-based static analyzer that aims at proving the absence of runtime errors in C and C++ programs.</p>
<p>See <a href="#checks">Checks</a> for the full list of available checks.</p>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>IKOS Analyzer can be installed independently from the other components, but we recommend to build the analyzer from the root directory. To do so, follow the instructions in the root <a href="../README.md">README.md</a>.</p>
<h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><p>To build and run the analyzer, you will need the following dependencies:</p>
<ul>
<li>A C++ compiler that supports C++14 (gcc &gt;&#x3D; 4.9.2 or clang &gt;&#x3D; 3.4)</li>
<li>CMake &gt;&#x3D; 3.4.3</li>
<li>GMP &gt;&#x3D; 4.3.1</li>
<li>Boost &gt;&#x3D; 1.55</li>
<li>Python 2 &gt;&#x3D; 2.7.3 or Python 3 &gt;&#x3D; 3.3</li>
<li>SQLite &gt;&#x3D; 3.6.20</li>
<li>TBB &gt;&#x3D; 2</li>
<li>LLVM and Clang 14.0.x</li>
<li>(Optional) APRON &gt;&#x3D; 0.9.10</li>
<li>(Optional) Pygments</li>
<li>IKOS Core</li>
<li>IKOS AR</li>
<li>IKOS LLVM Frontend</li>
</ul>
<h3 id="Build-and-Install"><a href="#Build-and-Install" class="headerlink" title="Build and Install"></a>Build and Install</h3><p>To build and install the analyzer, run the following commands in the <code>analyzer</code> directory:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake \</span><br><span class="line">    -DCMAKE_INSTALL_PREFIX=/path/to/analyzer-install-directory \</span><br><span class="line">    -DLLVM_CONFIG_EXECUTABLE=/path/to/llvm/bin/llvm-config \</span><br><span class="line">    -DCORE_ROOT=/path/to/core-install-directory \</span><br><span class="line">    -DAR_ROOT=/path/to/ar-install-directory \</span><br><span class="line">    -DFRONTEND_LLVM_ROOT=/path/to/frontend-llvm-install-directory \</span><br><span class="line">    ..</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>

<h3 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h3><p>To build and run the tests, simply type:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make check</span><br></pre></td></tr></table></figure>

<h3 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h3><p>To build the documentation, you will need <a href="http://www.doxygen.org/">Doxygen</a>.</p>
<p>Then, simply type:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make doc</span><br><span class="line">$ open doc/html/index.html</span><br></pre></td></tr></table></figure>

<h2 id="How-to-run-IKOS"><a href="#How-to-run-IKOS" class="headerlink" title="How to run IKOS"></a>How to run IKOS</h2><p>Suppose we want to analyze the following C program in a file, called <em>loop.c</em>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span>: <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"> <span class="number">3</span>: <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"> <span class="number">4</span>:     <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">for</span> (;i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="number">6</span>:         a[i] = i;</span><br><span class="line"> <span class="number">7</span>:     &#125;</span><br><span class="line"> <span class="number">8</span>:     a[i] = i;</span><br><span class="line"> <span class="number">9</span>:     <span class="built_in">printf</span>(<span class="string">&quot;%i&quot;</span>, a[i]);</span><br><span class="line"><span class="number">10</span>: &#125;</span><br></pre></td></tr></table></figure>

<p>To analyze this program with IKOS, simply run:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos loop.c</span><br></pre></td></tr></table></figure>

<p>You shall see the following output. IKOS reports two occurrences of buffer overflow at line 8 and 9.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] Compiling loop.c</span><br><span class="line">[*] Running ikos preprocessor</span><br><span class="line">[*] Running ikos analyzer</span><br><span class="line">[*] Translating LLVM bitcode to AR</span><br><span class="line">[*] Running liveness analysis</span><br><span class="line">[*] Running widening hint analysis</span><br><span class="line">[*] Running interprocedural value analysis</span><br><span class="line">[*] Analyzing entry point &#x27;main&#x27;</span><br><span class="line">[*] Checking properties for entry point &#x27;main&#x27;</span><br><span class="line"></span><br><span class="line"># Time stats:</span><br><span class="line">clang        : 0.037 sec</span><br><span class="line">ikos-analyzer: 0.023 sec</span><br><span class="line">ikos-pp      : 0.007 sec</span><br><span class="line"></span><br><span class="line"># Summary:</span><br><span class="line">Total number of checks                : 7</span><br><span class="line">Total number of unreachable checks    : 0</span><br><span class="line">Total number of safe checks           : 5</span><br><span class="line">Total number of definite unsafe checks: 2</span><br><span class="line">Total number of warnings              : 0</span><br><span class="line"></span><br><span class="line">The program is definitely UNSAFE</span><br><span class="line"></span><br><span class="line"># Results</span><br><span class="line">loop.c: In function &#x27;main&#x27;:</span><br><span class="line">loop.c:8:10: error: buffer overflow, trying to access index 10 of global variable &#x27;a&#x27; of 10 elements</span><br><span class="line">    a[i] = i;</span><br><span class="line">         ^</span><br><span class="line">loop.c: In function &#x27;main&#x27;:</span><br><span class="line">loop.c:9:18: error: buffer overflow, trying to access index 10 of global variable &#x27;a&#x27; of 10 elements</span><br><span class="line">    printf(&quot;%i&quot;, a[i]);</span><br><span class="line">                 ^</span><br></pre></td></tr></table></figure>

<p>The <code>ikos</code> command takes a source file (<code>.c</code>, <code>.cpp</code>) or a LLVM bitcode file (<code>.bc</code>) as input, analyzes it to find runtime errors (also called undefined behaviors), creates a result database <code>output.db</code> in the current working directory and prints a report.</p>
<p>In the report, each line has one of the following status:</p>
<ul>
<li><strong>safe</strong>: the statement is proven safe;</li>
<li><strong>error</strong>: the statement always results into an error (or is unreachable);</li>
<li><strong>unreachable</strong>: the statement is never executed;</li>
<li><strong>warning</strong> may mean three things:<ol>
<li>the statement results into an error for some executions, or</li>
<li>the static analyzer did not have enough information to conclude (check dependent on an external input, for instance), or</li>
<li>the static analyzer was not powerful enough to prove the absence of errors;</li>
</ol>
</li>
</ul>
<p>By default, ikos shows warnings and errors directly in your terminal, like a compiler would do.</p>
<p>If the analysis report is too big, you shall use:</p>
<ul>
<li><code>ikos-report output.db</code> to examine the report in your terminal</li>
<li><code>ikos-view output.db</code> to examine the report in a web interface</li>
</ul>
<h2 id="Analyze-a-whole-project-with-ikos-scan"><a href="#Analyze-a-whole-project-with-ikos-scan" class="headerlink" title="Analyze a whole project with ikos-scan"></a>Analyze a whole project with ikos-scan</h2><p>To run IKOS on a large project, you shall use ikos-scan.</p>
<p>ikos-scan is a command line utility that runs the static analyzer over a codebase after performing a regular build.</p>
<p>The ikos-scan command works by overriding the environment variables <code>CC</code> and <code>CXX</code> to intercept the compiler commands. Behind the scene, it builds the original program as well as the LLVM bitcode file that is necessary to run the analyzer.</p>
<p>To use ikos-scan, just prefix your build commands with <code>ikos-scan</code>. For instance, to analyze pkg-config:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tar xf pkg-config-0.29.2.tar.gz</span><br><span class="line">$ cd pkg-config-0.29.2</span><br><span class="line">$ ikos-scan ./configure</span><br><span class="line">[...]</span><br><span class="line">$ ikos-scan make</span><br><span class="line">[...]</span><br><span class="line">Analyze pkg-config? [Y/n]</span><br></pre></td></tr></table></figure>

<p>ikos-scan will produce a <code>.bc</code> file for each executable in your project. You can analyze them with specific options using <code>ikos [options] program.bc</code>.</p>
<h2 id="Examine-a-report-with-ikos-view"><a href="#Examine-a-report-with-ikos-view" class="headerlink" title="Examine a report with ikos-view"></a>Examine a report with ikos-view</h2><p>ikos-view provides a web interface to examine IKOS results. It is available directly in the analyzer.</p>
<p>The web interface shows the source code with syntax highlighting, and allows you to filter the warnings by checks.</p>
<p>To use ikos-view, first run the analyzer on your project to generate a result database <code>output.db</code>, then simply run:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos-view output.db</span><br></pre></td></tr></table></figure>

<p>It will start a web server. You can then launch your favorite web browser and visit <a href="http://localhost:8080/">http://localhost:8080</a></p>
<p>Note that if you want syntax highlighting, you will need to install <a href="http://pygments.org/">Pygments</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pip install --user pygments</span><br></pre></td></tr></table></figure>

<h2 id="Analysis-Options"><a href="#Analysis-Options" class="headerlink" title="Analysis Options"></a>Analysis Options</h2><p>This section describes the most relevant options of the analyzer.</p>
<h3 id="Checks"><a href="#Checks" class="headerlink" title="Checks"></a>Checks</h3><p>The list of available checks are:</p>
<ul>
<li><strong>buffer overflow analysis</strong>, <code>-a=boa</code>: checks for buffer overflows and out-of-bound array accesses.</li>
<li><strong>division by zero analysis</strong>, <code>-a=dbz</code>: checks for integer divisions by zero.</li>
<li><strong>null pointer analysis</strong>, <code>-a=nullity</code>: checks for null pointer dereferences.</li>
<li><strong>assertion prover</strong>, <code>-a=prover</code>: prove user-defined properties, using <code>__ikos_assert(condition)</code>.</li>
<li><strong>unaligned pointer analysis</strong>, <code>-a=upav</code>: checks for unaligned pointer dereferences.</li>
<li><strong>uninitialized variable analysis</strong>, <code>-a=uva</code>: checks for read of uninitialized variables.</li>
<li><strong>signed integer overflow analysis</strong>, <code>-a=sio</code>: checks for signed integer overflows.</li>
<li><strong>unsigned integer overflow analysis</strong>, <code>-a=uio</code>: checks for unsigned integer overflows.</li>
<li><strong>shift count analysis</strong>, <code>-a=shc</code>: checks for invalid shifts, where the amount shifted is greater or equal to the bit-width of the left operand, or less than zero.</li>
<li><strong>pointer overflow analysis</strong>, <code>-a=poa</code>: checks for pointer arithmetic overflows.</li>
<li><strong>pointer comparison analysis</strong>, <code>-a=pcmp</code>: checks for pointer comparisons between pointers referring to different objects.</li>
<li><strong>soundness analysis</strong>, <code>-a=sound</code>: checks for instructions that could make the analysis unsound, i.e miss bugs.</li>
<li><strong>function call analysis</strong>, <code>-a=fca</code>: checks for function calls through function pointers of the wrong type.</li>
<li><strong>dead code analysis</strong>, <code>-a=dca</code>: checks for unreachable statements.</li>
<li><strong>double free analysis</strong>, <code>-a=dfa</code>: checks for double free, invalid free, use after free and use after return.</li>
<li><strong>debugger</strong>, <code>-a=dbg</code>: prints debug information, using <code>__ikos_print_values(&quot;desc&quot;, x)</code> and <code>__ikos_print_invariant()</code>.</li>
<li><strong>memory watcher</strong>, <code>-a=watch</code>: prints memory writes at a given memory location, using <code>__ikos_watch_mem(ptr, size)</code>.</li>
</ul>
<p>By default, all the checks are enabled except:</p>
<ul>
<li><strong>unaligned pointer analysis</strong>, because it needs a congruence domain to generate meaningful results. See <a href="#numerical-abstract-domains">Numerical abstract domains</a>.</li>
<li><strong>unsigned integer overflow analysis</strong>, because it is not an undefined behavior according to the C standard.</li>
<li><strong>pointer overflow analysis</strong>, because it is redundant with the buffer overflow analysis.</li>
<li><strong>memory watcher</strong>, because it is slow.</li>
</ul>
<p>If you want to run specific checks, use the <code>-a</code> parameter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos -a=boa,nullity test.c</span><br></pre></td></tr></table></figure>

<p>Note that you can use the wildcard character <code>*</code>, <code>+</code> and <code>-</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos -a=&#x27;*,-sio&#x27; test.c</span><br></pre></td></tr></table></figure>

<p>In this example, all the checks are enabled except signed integer overflow checks.</p>
<h3 id="Numerical-abstract-domains"><a href="#Numerical-abstract-domains" class="headerlink" title="Numerical abstract domains"></a>Numerical abstract domains</h3><p>IKOS is based on the theory of <a href="https://www.di.ens.fr/~cousot/AI/IntroAbsInt.html">Abstract Interpretation</a>. The analysis uses a numerical abstract domain internally to model integer variables.</p>
<p>The list of available numerical abstract domains are:</p>
<ul>
<li><code>-d=interval</code>: The interval domain, see <a href="https://www.di.ens.fr/~cousot/COUSOTpapers/publications.www/CousotCousot-POPL-77-ACM-p238--252-1977.pdf">CC77</a>.</li>
<li><code>-d=congruence</code>: The congruence domain, see <a href="http://www.tandfonline.com/doi/abs/10.1080/00207168908803778">Gra89</a>.</li>
<li><code>-d=interval-congruence</code>: The reduced product of interval and congruence.</li>
<li><code>-d=dbm</code>: The Difference-Bound Matrices domain, see <a href="https://www-apr.lip6.fr/~mine/publi/article-mine-padoII.pdf">PADO01</a>.</li>
<li><code>-d=var-pack-dbm</code>: The Difference-Bound Matrices domain with variable packing, see <a href="https://seahorn.github.io/papers/vmcai16.pdf">VMCAI16</a>.</li>
<li><code>-d=var-pack-dbm-congruence</code>: The reduced product of DBM with variable packing and congruence.</li>
<li><code>-d=gauge</code>: The gauge domain, see <a href="https://ti.arc.nasa.gov/publications/4767/download/">CAV12</a>.</li>
<li><code>-d=gauge-interval-congruence</code>: The reduced product of gauge, interval and congruence.</li>
<li><code>-d=apron-interval</code>: The APRON interval domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_21.html#SEC54">Box</a>.</li>
<li><code>-d=apron-octagon</code>: The APRON octagon domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/oct_doc.html">Oct</a>.</li>
<li><code>-d=apron-polka-polyhedra</code>: The APRON polka polyhedra domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_25.html#SEC58">NewPolka</a>.</li>
<li><code>-d=apron-polka-linear-equalities</code>: The APRON polka linear equalities domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_25.html#SEC58">NewPolka</a>.</li>
<li><code>-d=apron-ppl-polyhedra</code>: The APRON PPL polyhedra domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_29.html#SEC65">PPL</a>.</li>
<li><code>-d=apron-ppl-linear-congruences</code>: The APRON PPL linear congruences domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_29.html#SEC65">PPL</a>.</li>
<li><code>-d=apron-pkgrid-polyhedra-lin-cong</code>: The APRON Pkgrid polyhedra and linear congruences domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_33.html#SEC69">Pkgrid</a>.</li>
<li><code>-d=var-pack-apron-octagon</code>: The APRON octagon domain with variable packing.</li>
<li><code>-d=var-pack-apron-polka-polyhedra</code>: The APRON Polka polyhedra domain with variable packing.</li>
<li><code>-d=var-pack-apron-polka-linear-equalities</code>: The APRON Polka linear equalities domain with variable packing.</li>
<li><code>-d=var-pack-apron-ppl-polyhedra</code>: The APRON PPL polyhedra domain with variable packing.</li>
<li><code>-d=var-pack-apron-ppl-linear-congruences</code>: The APRON PPL linear congruences domain with variable packing.</li>
<li><code>-d=var-pack-apron-pkgrid-polyhedra-lin-cong</code>: The APRON Pkgrid polyhedra and linear congruences domain with variable packing.</li>
</ul>
<p>By default, IKOS uses the fastest and least precise numerical domain, the <strong>interval</strong> domain. If you want to run the analysis with a specific domain, use the <code>-d</code> parameter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos -d=var-pack-dbm test.c</span><br></pre></td></tr></table></figure>

<p>For most users, we recommend to analyze your project with the fastest and least precise domain (i.e, interval) first, and then try slower but more precise domains until the analysis is too long for you. This is the best way to reach a low rate of false positives (i.e, warnings).</p>
<p>Here is a list of numerical domains, sorted from the fastest and least precise to the slowest and most precise:</p>
<ul>
<li><code>-d=interval</code></li>
<li><code>-d=gauge-interval-congruence</code></li>
<li><code>-d=var-pack-dbm</code></li>
<li><code>-d=var-pack-apron-octagon</code></li>
<li><code>-d=var-pack-apron-ppl-polyhedra</code></li>
<li><code>-d=dbm</code></li>
<li><code>-d=apron-octagon</code></li>
<li><code>-d=apron-ppl-polyhedra</code></li>
</ul>
<p>You should consider running different analyses in this specific order.</p>
<p>Please also note that:</p>
<ul>
<li>Floating point variables are safely ignored.</li>
<li>In order to use the <strong>APRON</strong> abstract domain, you need to build IKOS with APRON first. See <a href="#apron-support">APRON Support</a>.</li>
</ul>
<h3 id="Entry-points"><a href="#Entry-points" class="headerlink" title="Entry points"></a>Entry points</h3><p>By default, the analyzer assumes the entry point of the program is <code>main</code>. You can specify a list of entry points using the <code>--entry-points</code> parameter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos --entry-points=foo,bar test.c</span><br></pre></td></tr></table></figure>

<p>IKOS analyses each entry point independently, as if they were running in different processes.</p>
<h3 id="Multi-threading"><a href="#Multi-threading" class="headerlink" title="Multi-threading"></a>Multi-threading</h3><p>The analyzer can use multi-threading to speed up the analysis. You can specify the number of threads to use with the <code>--jobs</code> or <code>-j</code> parameter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos --jobs=4 test.c</span><br></pre></td></tr></table></figure>

<p>Use <code>-j</code> to use all available threads. By default, the analyzer only uses one thread.</p>
<p><strong>Warning:</strong> APRON numerical abstract domains are currently NOT thread-safe and might cause crashes.</p>
<h3 id="Optimization-level"><a href="#Optimization-level" class="headerlink" title="Optimization level"></a>Optimization level</h3><p>The parameter <code>--opt</code> allows you to set the optimization level. Optimizations are performed by running a set of LLVM passes on the analyzed code.</p>
<p>Available levels are:</p>
<ul>
<li><strong>none</strong>: Disable all optimizations.</li>
<li><strong>basic</strong>: Basic set of optimizations (similar to <code>-O1</code>). This is the default value.</li>
<li><strong>aggressive</strong>: Aggressive optimizations (similar to <code>-O3</code>). This is not recommended since it might hide errors. The translation from LLVM to AR might fail because of unsupported instructions.</li>
</ul>
<h3 id="Inter-procedural-vs-Intra-procedural"><a href="#Inter-procedural-vs-Intra-procedural" class="headerlink" title="Inter-procedural vs Intra-procedural"></a>Inter-procedural vs Intra-procedural</h3><p>An <strong>inter-procedural</strong> analysis analyzes a function considering its call stack while an <strong>intra-procedural</strong> analysis ignores it. The former produces more precise results than the latter but it is often much more expensive.</p>
<p>By default, IKOS performs an inter-procedural analysis. Use <code>--proc=intra</code> to perform an intra-procedural analysis.</p>
<h3 id="Fixpoint-engine-parameters"><a href="#Fixpoint-engine-parameters" class="headerlink" title="Fixpoint engine parameters"></a>Fixpoint engine parameters</h3><p>The analyzer uses the theory of Abstract Interpretation to compute a fixpoint of the semantic of the program. The fixpoint engine can be tuned using several parameters.</p>
<p>When visiting a loop, the engine will first compute a fixed number of iterations, then use a widening strategy periodically to approximate the behavior of the loop, until convergence.</p>
<p>The fixed number of iterations performed before the widening strategy can be set using <code>--widening-delay</code>. By default, it is 1.</p>
<p>The period of the widening strategy can be set using <code>--widening-period</code>. By default, it is 1, thus the widening strategy is always applied.</p>
<p>The widening strategy can be set using <code>--widening-strategy=</code>:</p>
<ul>
<li><strong>widen</strong>: Use the widening operator to approximate the behavior of the loop (default)</li>
<li><strong>join</strong>: Use the join operator, effectively computing all iterations (very slow)</li>
</ul>
<p>After reaching a fixpoint, the engine will perform extra iterations to regain precision using a narrowing strategy, until convergence.</p>
<p>The narrowing strategy can be set using <code>--narrowing-strategy=</code>:</p>
<ul>
<li><strong>narrow</strong>: Use the narrowing operator, ensuring a fast convergence</li>
<li><strong>meet</strong>: Use the meet operator, convergence can be slow</li>
<li><strong>auto</strong>: Use the narrowing operator if available for the numerical abstract domain. Otherwise, perform 2 iterations using the meet operator (default)</li>
</ul>
<p>You can specify a fixed number of narrowing iterations to perform using <code>--narrowing-iterations</code>.</p>
<p>You can specify the widening delay for a given function using <code>--widening-delay-functions</code>. For instance, <code>--widening-delay-functions=&quot;main:10, f:32&quot;</code>.</p>
<h3 id="Partitioning"><a href="#Partitioning" class="headerlink" title="Partitioning"></a>Partitioning</h3><p>The analyzer can use abstract domain partitioning based on integer variables using the <code>--partitioning</code> option.</p>
<p>Using <code>--partitioning=return</code>, the analyzer will split the states at the end of a function according to the function return codes.</p>
<p>This can be used to improve the precision of the analysis on the following code pattern:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> status = xxx();</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Error in xxx</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = yyy();</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">// Error in yyy</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    zzz();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Instead of performing the abstract union and lose precision, the analyzer will keep 3 invariants for each outcome of the <code>init</code> function.</p>
<p>Using <code>--partitioning=manual</code>, the analyzer will split the states according to the values of a given integer variable, set with <code>__ikos_partitioning_var_int(x)</code>.</p>
<p>By default, partitioning is disabled.</p>
<h3 id="Hardware-addresses"><a href="#Hardware-addresses" class="headerlink" title="Hardware addresses"></a>Hardware addresses</h3><p>In C code for embedded systems, it is usual to read or write at specific addresses to communicate with the hardware. By default, IKOS treats memory accesses at specific addresses as errors.</p>
<p>You can provide the <code>--hardware-addresses</code> parameter to specify a range of valid memory addresses:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos --hardware-addresses=0x20-0x40 project.bc</span><br></pre></td></tr></table></figure>

<p>During the analysis, IKOS will assume that memory accesses in the range <code>[0x20, 0x40]</code> (in bytes, inclusive) are safe.</p>
<h3 id="Other-analysis-options"><a href="#Other-analysis-options" class="headerlink" title="Other analysis options"></a>Other analysis options</h3><ul>
<li><code>--globals-init</code>: use the given strategy for initialization of global variables.</li>
<li><code>--no-init-globals</code>: disable global variable initialization for the given entry points.</li>
<li><code>--no-liveness</code>: disable the liveness analysis.</li>
<li><code>--no-pointer</code>: disable the pointer analysis.</li>
<li><code>--no-widening-hints</code>: disable the detection of widening hints.</li>
<li><code>--no-fixpoint-cache</code>: disable the cache of fixpoint for called functions.</li>
<li><code>--no-checks</code>: disable all the checks</li>
<li><code>--argc</code>: specify the value of <code>argc</code> for the analysis.</li>
<li><code>--no-libc</code>: do not use libc intrinsics. Useful for bare metal programming.</li>
</ul>
<p>See <code>ikos --help</code> for more information.</p>
<h2 id="Report-Options"><a href="#Report-Options" class="headerlink" title="Report Options"></a>Report Options</h2><p>This section describes the most relevant report options supported by <code>ikos</code> and <code>ikos-report</code>.</p>
<h3 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h3><p>You can specify the format of the report using the <code>--format</code> (or <code>-f</code>) parameter.</p>
<p>Available formats are:</p>
<ul>
<li><strong>text</strong>: Text format, convenient for the terminal;</li>
<li><strong>csv</strong>: CSV format, convenient for spreadsheet import;</li>
<li><strong>json</strong>: JSON format, convenient for developers.</li>
<li><strong>web</strong>: Web interface, using ikos-view.</li>
<li><strong>no</strong>: Disable the report.</li>
</ul>
<p>By default, if the report has less than 15 entries, it will be printed out using the text format.</p>
<p>We recommend to use <a href="#examine-a-report-with-ikos-view">ikos-view</a> to examine reports of large projects.</p>
<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>By default, the report is generated on the standard output. You can write it into a file using <code>--report-file=/path/to/report</code></p>
<h3 id="Status-Filter"><a href="#Status-Filter" class="headerlink" title="Status Filter"></a>Status Filter</h3><p>Use <code>--status-filter</code> to filter unwanted checks.</p>
<p>Possible values are: <strong>error</strong>, <strong>warning</strong>, <strong>safe</strong>, <strong>unreachable</strong>.</p>
<p>Note that you can use the wildcard character <code>*</code>, <code>+</code> and <code>-</code>.</p>
<h3 id="Analysis-Filter"><a href="#Analysis-Filter" class="headerlink" title="Analysis Filter"></a>Analysis Filter</h3><p>Use <code>--analyses-filter</code> to filter unwanted checks.</p>
<p>Possible values are described in <a href="#checks">Checks</a>.</p>
<p>Note that you can use the wildcard character <code>*</code>, <code>+</code> and <code>-</code>. For instance:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos-report --analyses-filter=&#x27;*,-boa&#x27; output.db</span><br></pre></td></tr></table></figure>

<p>This will generate a report with all the checks, except buffer overflows.</p>
<h3 id="Verbosity"><a href="#Verbosity" class="headerlink" title="Verbosity"></a>Verbosity</h3><p>Use <code>--report-verbosity [1-4]</code> to specify the verbosity. A verbosity of one will give you very short messages, where a verbosity of 4 will provide you with all the information the analyzer has.</p>
<h4 id="Other-report-options"><a href="#Other-report-options" class="headerlink" title="Other report options"></a>Other report options</h4><p>See <code>ikos-report --help</code> for more information.</p>
<h2 id="APRON-Support"><a href="#APRON-Support" class="headerlink" title="APRON Support"></a>APRON Support</h2><p><a href="http://apron.cri.ensmp.fr/library/">APRON</a> is a C library for static analysis using Abstract Interpretation. It implements several complex abstract domains, such as the Polyhedra domain.</p>
<p>IKOS provides a wrapper for APRON, allowing you to use any APRON abstract domain in the analyzer.</p>
<p>To use APRON, first download, build and install it. Consider using the svn trunk. You will also need to build APRON with <a href="http://bugseng.com/products/ppl/">Parma Polyhedra Library</a> enabled. Set <code>HAS_PPL = 1</code> and define <code>PPL_PREFIX</code> in your <code>Makefile.config</code></p>
<p>Now, to build IKOS with APRON support, just provide the option <code>-DAPRON_ROOT=/path/to/apron-install</code> when running cmake. For instance:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake \</span><br><span class="line">    -DCMAKE_INSTALL_PREFIX=/path/to/ikos-install \</span><br><span class="line">    -DAPRON_ROOT=/path/to/apron-install \</span><br><span class="line">    ..</span><br></pre></td></tr></table></figure>

<p>See <a href="#numerical-abstract-domains">Numerical abstract domains</a> for the list of numerical abstract domains.</p>
<h2 id="Analysis-Assumptions"><a href="#Analysis-Assumptions" class="headerlink" title="Analysis Assumptions"></a>Analysis Assumptions</h2><p>This section describes the assumptions made by the analyzer about the code.</p>
<p>First, the analyzed code is compiled with the <strong>Clang</strong> compiler using the host target. Thus, Clang is responsible for specifying the data model (size of types), the data layout (alignments), the endianness, the signedness of <code>char</code>, the semantic of floating points, etc. depending on the host target. The analyzer uses the generated LLVM bitcode from Clang. This means that you can get different results depending on your host target.</p>
<p>During the analysis, the analyzer will make the following assumptions:</p>
<ul>
<li>The program is single-threaded.</li>
<li>The program does not receive signals.</li>
<li>The program does not receive interrupts.</li>
<li>Extern functions (without implementation) do not update global variables.</li>
<li>Extern functions can write on their pointer parameters, but only with one level of indirection:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>** p)</span>; <span class="comment">// Assume to write on *p but not **p</span></span><br></pre></td></tr></table></figure></li>
<li>Extern functions do not call user-defined functions (no callbacks).</li>
<li>Extern functions can throw exceptions.</li>
<li>Extern functions return well-initialized values.</li>
<li>Recursive function calls can update any value in memory.</li>
<li>Recursive function calls can throw exceptions.</li>
<li>Recursive function calls return well-initialized values.</li>
<li>Assembly codes are treated as extern function calls.</li>
<li>C standard library functions do not throw exceptions.</li>
</ul>
<h2 id="Analyze-an-embedded-software-requiring-a-cross-compiler"><a href="#Analyze-an-embedded-software-requiring-a-cross-compiler" class="headerlink" title="Analyze an embedded software requiring a cross-compiler"></a>Analyze an embedded software requiring a cross-compiler</h2><p>Running the analyzer on an embedded software that requires a cross-compiler can be challenging.</p>
<p>You should try to use <a href="#analyze-a-whole-project-with-ikos-scan">ikos-scan</a> first, but this will probably fail with compiler errors.</p>
<p>To solve this issue, you will need to create an alternative build file that compiles everything to LLVM bitcode. For instance, if you use <code>make</code>, you could create <code>Makefile.llvm</code> based on <code>Makefile</code>.</p>
<p>In the alternative build file:</p>
<ul>
<li>Locate the build rules that generate intermediate object files (<code>.o</code>).</li>
<li>In these rules, add the flag <code>-save-temps=obj</code> to the cross-compiler commands. This will generate a preprocessed file <code>.i</code> in addition to the <code>.o</code>.</li>
<li>At the end of these rules, add a command to compile the preprocessed file <code>.i</code> to LLVM bitcode <code>.bc</code> using: <code>clang -c -emit-llvm -D_FORTIFY_SOURCE=0 -D__IKOS__ -g -O0 -Xclang -disable-O0-optnone &lt;file.i&gt; -o &lt;file.bc&gt;</code>.</li>
<li>Locate the build rules that link the intermediate object files into binaries or shared libraries.</li>
<li>At the end of these rules, link the LLVM bitcodes <code>.bc</code> together using <code>llvm-link</code>.</li>
</ul>
<p>For instance, in <code>Makefile.llvm</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%.o: %.c</span><br><span class="line">	$(CC) -c $(CPPFLAGS) $(CFLAGS) -save-temps=obj $&lt; -o $@</span><br><span class="line">	clang -c -emit-llvm -D_FORTIFY_SOURCE=0 -D__IKOS__ -g -O0 -Xclang -disable-O0-optnone $(subst .o,.i,$@) -o $(subst .o,.bc,$@)</span><br><span class="line"></span><br><span class="line">program: a.o b.o</span><br><span class="line">	$(CC) $(CPPFLAGS) $(CFLAGS) a.o b.o -o $@</span><br><span class="line">	llvm-link a.bc b.bc -o $@.bc</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -f *.o *.i *.s *.bc</span><br></pre></td></tr></table></figure>

<p>Then, run your build tool using the alternative build file to generate the LLVM bitcode (e.g, <code>make -f Makefile.llvm</code>).</p>
<p>You can finally analyze your program by running ikos on the generated LLVM bitcode file (e.g, <code>ikos program.bc</code>).</p>
<h2 id="Model-library-functions-to-reduce-warnings"><a href="#Model-library-functions-to-reduce-warnings" class="headerlink" title="Model library functions to reduce warnings"></a>Model library functions to reduce warnings</h2><p>The analyzer doesn’t require the libraries used by your program. It will consider library functions as unknown extern functions and make some <a href="#analysis-assumptions">assumptions</a> about them.</p>
<p>The analyzer will produce a warning for each call to an unknown function. You can use <code>ikos-report --analyses-filter=sound output.db</code> to list these warnings, or filter the “ignored call side effect” in ikos-view.</p>
<p>You can model library functions to improve the precision of the analysis and reduce the number of warnings. To model a library function, simply write a small implementation for it and link it in your program. This is usually called a “stub”.</p>
<p>For instance, a stub for <code>fgets</code> could be:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ikos/analyzer/intrinsic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">fgets</span><span class="params">(<span class="type">char</span>* <span class="keyword">restrict</span> str, <span class="type">int</span> size, FILE* <span class="keyword">restrict</span> stream)</span> &#123;</span><br><span class="line">    __ikos_assert(size &gt;= <span class="number">0</span>);</span><br><span class="line">    __ikos_forget_mem(stream, <span class="keyword">sizeof</span>(FILE));</span><br><span class="line">    __ikos_abstract_mem(str, size);</span><br><span class="line">    <span class="keyword">return</span> __ikos_nondet_int() ? str : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The analyzer provides helper functions to implement these stubs, see <a href="include/ikos/analyzer/intrinsic.h">include&#x2F;ikos&#x2F;analyzer&#x2F;intrinsic.h</a></p>
<p>Note that most functions of the C standard library are already modeled, but not all of them.</p>
<h2 id="Overview-of-the-source-code"><a href="#Overview-of-the-source-code" class="headerlink" title="Overview of the source code"></a>Overview of the source code</h2><p>The following illustrates the directory structure of this folder:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── doc</span><br><span class="line">│   └── doxygen</span><br><span class="line">│       └── latex</span><br><span class="line">├── include</span><br><span class="line">│   └── ikos</span><br><span class="line">│       └── analyzer</span><br><span class="line">│           ├── analysis</span><br><span class="line">│           │   ├── execution_engine</span><br><span class="line">│           │   ├── pointer</span><br><span class="line">│           │   └── value</span><br><span class="line">│           ├── checker</span><br><span class="line">│           ├── database</span><br><span class="line">│           │   └── table</span><br><span class="line">│           ├── json</span><br><span class="line">│           ├── support</span><br><span class="line">│           └── util</span><br><span class="line">├── python</span><br><span class="line">│   └── ikos</span><br><span class="line">│       └── view</span><br><span class="line">│           ├── static</span><br><span class="line">│           │   ├── css</span><br><span class="line">│           │   └── js</span><br><span class="line">│           └── template</span><br><span class="line">├── script</span><br><span class="line">├── src</span><br><span class="line">│   ├── analysis</span><br><span class="line">│   │   ├── pointer</span><br><span class="line">│   │   └── value</span><br><span class="line">│   │       └── machine_int_domain</span><br><span class="line">│   ├── checker</span><br><span class="line">│   ├── database</span><br><span class="line">│   │   └── table</span><br><span class="line">│   ├── json</span><br><span class="line">│   └── util</span><br><span class="line">└── test</span><br><span class="line">    └── regression</span><br></pre></td></tr></table></figure>

<h4 id="doc-x2F"><a href="#doc-x2F" class="headerlink" title="doc&#x2F;"></a>doc&#x2F;</h4><p>Contains Doxygen files.</p>
<h4 id="include-x2F"><a href="#include-x2F" class="headerlink" title="include&#x2F;"></a>include&#x2F;</h4><ul>
<li><a href="include/ikos/analyzer/intrinsic.h">include&#x2F;ikos&#x2F;analyzer&#x2F;intrinsic.h</a> contains definition of IKOS intrinsics that can be used in analyzed source code.</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-analysis"><a href="#include-x2F-ikos-x2F-analyzer-x2F-analysis" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;analysis"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;analysis</h5><ul>
<li><p><a href="include/ikos/analyzer/analysis/call_context.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;call_context.hpp</a> contains definition of a call context and the call context factory.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/context.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;context.hpp</a> contains definition of the global context of the analyzer.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/literal.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;literal.hpp</a> contains definition of the literal factory. It converts an AR operand to an AR-independent format.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/liveness.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;liveness.hpp</a> contains definition of the liveness analysis. It computes the set of live and dead variables for all functions.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/memory_location.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;memory_location.hpp</a> contains definition of symbolic memory locations (global, stack, heap-allocated, etc), and the memory location factory.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/option.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;option.hpp</a> contains definition of analysis options.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/variable.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;variable.hpp</a> contains definition of variables (local, global, etc), and the variable factory.</p>
</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-execution-engine"><a href="#include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-execution-engine" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine</h5><ul>
<li><p><a href="include/ikos/analyzer/analysis/execution_engine/context_insensitive.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine&#x2F;context_insensitive.hpp</a> contains definition of <code>ContextInsensitiveCallExecutionEngine</code>, a call execution engine for context-insensitive analyses.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/execution_engine/engine.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine&#x2F;engine.hpp</a> contains definition of base classes for execution engines. It defines an API to execute AR statements.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/execution_engine/inliner.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine&#x2F;inliner.hpp</a> contains definition of <code>InlineCallExecutionEngine</code>, a call execution engine performing dynamic inlining.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/execution_engine/numerical.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine&#x2F;numerical.hpp</a> contains definition of <code>NumericalExecutionEngine</code>, the main execution engine of the analyzer. It executes AR statements on an abstract domain.</p>
</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-pointer"><a href="#include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-pointer" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer</h5><ul>
<li><p><a href="include/ikos/analyzer/analysis/pointer/constraint.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer&#x2F;constraint.hpp</a> contains definition of <code>PointerConstraintsGenerator</code>, a generator of pointer constraints given an AR function or global variable.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/pointer/function.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer&#x2F;function.hpp</a> contains definition of a function pointer analysis.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/pointer/pointer.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer&#x2F;pointer.hpp</a> contains definition of a pointer analysis.</p>
</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-value"><a href="#include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-value" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value</h5><ul>
<li><p><a href="include/ikos/analyzer/analysis/value/abstract_domain.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value&#x2F;abstract_domain.hpp</a> contains definition the abstract domain used during the value analysis.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/value/interprocedural.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value&#x2F;interprocedural.hpp</a> contains definition the interprocedural value analysis.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/value/intraprocedural.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value&#x2F;intraprocedural.hpp</a> contains definition the intraprocedural value analysis.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/value/machine_int_domain.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value&#x2F;machine_int_domain.hpp</a> contains definition the machine integer abstract domain used during the value analysis.</p>
</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-checker"><a href="#include-x2F-ikos-x2F-analyzer-x2F-checker" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;checker"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;checker</h5><p>Contains definition of the different checks on the code (buffer overflow, division by zero, etc.), given the result of an analysis.</p>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-database-x2F-table"><a href="#include-x2F-ikos-x2F-analyzer-x2F-database-x2F-table" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;database&#x2F;table"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;database&#x2F;table</h5><p>Contains definition of the different output database tables.</p>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-json"><a href="#include-x2F-ikos-x2F-analyzer-x2F-json" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;json"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;json</h5><p>Contains definition of a JSON library.</p>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-support"><a href="#include-x2F-ikos-x2F-analyzer-x2F-support" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;support"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;support</h5><p>Contains various helpers, e.g, assertions.</p>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-util"><a href="#include-x2F-ikos-x2F-analyzer-x2F-util" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;util"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;util</h5><p>Contains definition of utilities for the analyzer, e.g, logging, colors, timers, etc.</p>
<h4 id="python-x2F"><a href="#python-x2F" class="headerlink" title="python&#x2F;"></a>python&#x2F;</h4><ul>
<li><p><a href="python/ikos/analyzer.py">python&#x2F;ikos&#x2F;analyzer.py</a> contains implementation of the <code>ikos</code> command line tool.</p>
</li>
<li><p><a href="python/ikos/report.py">python&#x2F;ikos&#x2F;report.py</a> contains implementation of the <code>ikos-report</code> command line tool.</p>
</li>
<li><p><a href="python/ikos/settings.py.in">python&#x2F;ikos&#x2F;settings.py.in</a> contains implementation of the <code>ikos-config</code> command line tool.</p>
</li>
<li><p><a href="python/ikos/view.py">python&#x2F;ikos&#x2F;view.py</a> contains implementation of the <code>ikos-view</code> command line tool.</p>
</li>
</ul>
<h5 id="python-x2F-ikos-x2F-analyzer-x2F-view"><a href="#python-x2F-ikos-x2F-analyzer-x2F-view" class="headerlink" title="python&#x2F;ikos&#x2F;analyzer&#x2F;view"></a>python&#x2F;ikos&#x2F;analyzer&#x2F;view</h5><p>Contains the web resources for ikos-view. It includes HTML, CSS and JS code.</p>
<h4 id="script-x2F"><a href="#script-x2F" class="headerlink" title="script&#x2F;"></a>script&#x2F;</h4><p>Contains python entry points for the command line tools.</p>
<h4 id="src-x2F"><a href="#src-x2F" class="headerlink" title="src&#x2F;"></a>src&#x2F;</h4><p>Contains implementation files, following the structure of <code>include/ikos/analyzer</code>.</p>
<ul>
<li><a href="src/ikos_analyzer.cpp">src&#x2F;ikos_analyzer.cpp</a> contains the implementation of <code>ikos-analyzer</code>. This is the entry point for all analyses.</li>
</ul>
]]></content>
      <categories>
        <category>ikos</category>
      </categories>
      <tags>
        <tag>ikos</tag>
      </tags>
  </entry>
</search>
