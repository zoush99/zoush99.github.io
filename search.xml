<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git的使用</title>
    <url>/2023/06/13/git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="主要介绍git的使用规则"><a href="#主要介绍git的使用规则" class="headerlink" title="主要介绍git的使用规则"></a>主要介绍git的使用规则</h2><span id="more"></span>

<p><img src="/paper_source/git%E6%8C%87%E4%BB%A4/graph.jpg"></p>
<p>一些信息查找命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git branch -al</span><br><span class="line">git branch -r</span><br></pre></td></tr></table></figure>

<p>在要推送的项目下，打开git，首先需要初始化。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>然后连接远程仓库，这个远程仓库需要自己预先建立（github或其他代码管理平台都可以），如我想连接自己的zoush99。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:zoush99/zoush99.github.io.git</span><br></pre></td></tr></table></figure>

<p>将远程仓库的某个分支拉取到本地。（第一个参数是远程分支，第二个参数是本地分支）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull --set-upstream-to=origin/source <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>将本地仓库加入到提交目录中。（加入了所有文件，也可以加入特定文件）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>提交到仓库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;提交备注&quot;</span></span><br></pre></td></tr></table></figure>

<p>上传到远程仓库。（第一个参数是远程分支，第二个参数是本地分支）如果加上参数<code>-u</code>则会将本地分支作为追踪分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>以上是完整的过程，但是还需要一些常见的指令。</p>
<p>将远程仓库的文件复制到本地。（将默认的分支拉取到本地，后面一个参数是将本地文件夹重命名为source）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:zoush99/zoush99.github.io.git <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>拉取指定分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b <span class="built_in">source</span> git@github.com:zoush99/zoush99.github.io.git <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>拉取到本地后，可以查看是哪个分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>新建并且切换为本地分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>新建本地分支，并且从远程仓库拉取代码。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b <span class="built_in">source</span> origin/source</span><br></pre></td></tr></table></figure>
<p>删除本地分支，注意要切换到其他分支后，才能删除本地分支，在当前分支时不能删除当前分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -d <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>删除远程分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin -d <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>其他需要注意的：用命令<code>git pull --set-upstream-to=origin/source source</code>将修改的远程代码拉取到本地后，直接用<code>git push origin source</code>提交，不需要<code>add</code>和<code>commit</code>，因为<code>pull=fetch+merge</code>。</p>
<p>注意<code>fetch</code>和<code>merge</code>指令和<code>pull</code>指令。</p>
<p>更新远程仓库的某个分支到本地。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>将远程仓库的某个分支下载到本地新建的分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin <span class="built_in">source</span>:<span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>将远程分支合并到本地当前分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git merge origin/source</span><br></pre></td></tr></table></figure>

<p>上面两个命令连续执行，相当于如下的<code>pull</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<p>版本回滚操作，回到之前的版本，防止数据丢失。</p>
<p>查看版本号。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>使用指令回到目标版本号指定的版本。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --hard 目标版本号</span><br></pre></td></tr></table></figure>

<p>再提交。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure>

<p>也可以用<code>revert</code>操作。但这里不打算介绍这种方法，看起来有些麻烦。</p>
<p>建立本地分支和远程分支的关联（创建远程分支）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin 202309（分支名）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git pages发布页面和源代码同步脚本</title>
    <url>/2023/06/26/git-pages%E5%8F%91%E5%B8%83%E9%A1%B5%E9%9D%A2%E5%92%8C%E6%BA%90%E4%BB%A3%E7%A0%81%E5%90%8C%E6%AD%A5%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="github-pages界面和源代码同步"><a href="#github-pages界面和源代码同步" class="headerlink" title="github pages界面和源代码同步"></a>github pages界面和源代码同步</h2><span id="more"></span>

<blockquote>
<p> 为了便于自己记录并且保存自己的做项目或者生活中记录的重点事项，也为了多设备单账号协同发布。所以打算写一个脚本用来便于运行脚本分别发布并且同步源代码。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">!</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This simple script is designed to make it easier to publish my github pages and to be able to synchronize the <span class="built_in">source</span> code updates to the sourcecode branch.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &quot;the name of this scipt is publish&quot;</span><br><span class="line">echo &quot;First post on pages&quot;</span><br><span class="line">hexo g -d</span><br><span class="line"></span><br><span class="line">result=`git branch | grep &quot;*&quot;`</span><br><span class="line">curBranch=$&#123;result:2&#125;</span><br><span class="line">echo &quot;Then upload to sourcecode branch&quot;</span><br><span class="line">read -p &quot;Enter submission notes:&quot; notes</span><br><span class="line">echo &quot;Determine if the local branch is a sourcecode branch, if so, upload directly, otherwise switch to sourcecode branch and upload again&quot;</span><br><span class="line">echo &quot;Current git branch is $curBranch&quot;</span><br><span class="line">if [ $&#123;curBranch&#125; == &quot;sourcecode&quot; ]</span><br><span class="line">    then </span><br><span class="line">        echo &quot;the branch is sourcecode, upload directly&quot;</span><br><span class="line">    else</span><br><span class="line">        echo &quot;Switch to the sourcecode branch, then upload&quot;</span><br><span class="line">        git checkout sourcecode </span><br><span class="line">fi </span><br><span class="line"></span><br><span class="line">git pull origin sourcecode &amp;&amp;</span><br><span class="line">git add . &amp;&amp;</span><br><span class="line">git commit -m $notes &amp;&amp; </span><br><span class="line">git push origin sourcecode</span><br></pre></td></tr></table></figure>

<p>实现了简单的快捷上传操作。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Classic-Flang说明</title>
    <url>/2023/07/14/Classic-Flang%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="Flang的使用情况"><a href="#Flang的使用情况" class="headerlink" title="Flang的使用情况"></a>Flang的使用情况</h2><span id="more"></span>

<p>之前搞了那么久，现在终于得开始了解这个工具了。先慢慢使用，看看它的能力以及学习一下转换而来的LLVM IR的语法。</p>
<h2 id="安装Flang"><a href="#安装Flang" class="headerlink" title="安装Flang"></a>安装Flang</h2><p><img src="/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/%E5%AE%89%E8%A3%85Flang.jpg"></p>
<p>我安装的是github网站上的flang-compiler项目的legacy版本<a href="https://github.com/flang-compiler/flang/tree/legacy">flang-compiler&#x2F;flang at legacy (github.com)</a>。使用的安装脚本是根据网站上提供的安装脚本，并稍作修改：改进了下载版本等信息，总体而言没有做太大改进。为了保证开源包的安全性（可用性），fork到个人目录下：<a href="https://github.com/zoush99/flang/tree/legacy">zoush99&#x2F;flang at legacy (github.com)</a>。</p>
<p>为了让自己养成良好习惯，在这里记录一下安装的步骤。</p>
<p>安装LLVM需要一系列现代编译链：build-essensial和CMake的版本不低于3.3，并且应该到LLVM的网站满足所需要的依赖，才能进行安装步骤。推荐链接：<a href="http://llvm.org/docs/GettingStarted.html#host-c-toolchain-both-compiler-and-standard-library">Getting started with LLVM</a>和<a href="http://llvm.org/docs/CMake.html">CMake llvm</a>。</p>
<p>安装需要依赖后，直接安装其提供的LLVM14版本。其中的一些细节不做讨论。一些解释详见<a href="https://github.com/flang-compiler/flang/wiki/Building-Flang">Building Flang · flang-compiler&#x2F;flang Wiki (github.com)</a></p>
<p>我们这里需要直接将安装脚本罗列下来，并且依次执行即可。</p>
<p>首先是安装的初始化脚本：将CMake的命令进行初始设置，一定要提前执行。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">INSTALL_PREFIX=`<span class="built_in">pwd</span>`/install</span><br><span class="line"></span><br><span class="line"><span class="comment"># Targets to build should be one of: X86 PowerPC AArch64</span></span><br><span class="line">CMAKE_OPTIONS=<span class="string">&quot;-DCMAKE_INSTALL_PREFIX=<span class="variable">$INSTALL_PREFIX</span> \</span></span><br><span class="line"><span class="string">    -DLLVM_CONFIG=<span class="variable">$INSTALL_PREFIX</span>/bin/llvm-config \</span></span><br><span class="line"><span class="string">    -DCMAKE_CXX_COMPILER=<span class="variable">$INSTALL_PREFIX</span>/bin/clang++ \</span></span><br><span class="line"><span class="string">    -DCMAKE_C_COMPILER=<span class="variable">$INSTALL_PREFIX</span>/bin/clang \</span></span><br><span class="line"><span class="string">    -DCMAKE_Fortran_COMPILER=<span class="variable">$INSTALL_PREFIX</span>/bin/flang </span></span><br><span class="line"><span class="string">    -DCMAKE_Fortran_COMPILER_ID=Flang \</span></span><br><span class="line"><span class="string">    -DLLVM_TARGETS_TO_BUILD=X86&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后是安装llvm14的脚本，直接执行即可。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">. setup.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -d classic-flang-llvm-project ]]; <span class="keyword">then</span></span><br><span class="line">    git <span class="built_in">clone</span> -b release_14x https://github.com/zoush99/classic-flang-llvm-project.git</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> classic-flang-llvm-project</span><br><span class="line"><span class="built_in">mkdir</span> -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake <span class="variable">$CMAKE_OPTIONS</span> -DCMAKE_C_COMPILER=/usr/bin/gcc -DCMAKE_CXX_COMPILER=/usr/bin/g++ -DLLVM_ENABLE_CLASSIC_FLANG=ON -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang;openmp&quot;</span> -DCMAKE_BUILD_TYPE=Release ../llvm</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>将classic-flang-llvm-project&#x2F;build&#x2F;bin目录加入到环境变量，或install&#x2F;bin加入到环境变量。测试Clang命令是否正确执行，这时发现也会存在Flang的命令，但只是将Flang链接到Clang命令，之后安装Flang才会对Fortran程序起作用。</p>
<p>然后安装Flang的legacy版本，这个版本最近更新是在8个月前，因为要适配IKOS&#x2F;Clam，所以需要llvm14版本。目前Flang已经更新到15或更高版本。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">. setup.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -d flang ]]; <span class="keyword">then</span></span><br><span class="line">    git <span class="built_in">clone</span> -b legacy https://github.com/zoush99/flang.git</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">cd</span> flang/runtime/libpgmath</span><br><span class="line"> <span class="built_in">mkdir</span> -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"> cmake <span class="variable">$CMAKE_OPTIONS</span> ..</span><br><span class="line"> make -j4</span><br><span class="line"> sudo make install)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> flang</span><br><span class="line"><span class="built_in">mkdir</span> -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake <span class="variable">$CMAKE_OPTIONS</span> -DFLANG_LLVM_EXTENSIONS=ON ..</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>这样就把Flang安装成功，之后若使用IKOS还需要安装一个14版本的llvm，但二者相互不影响，因为他们针对不同的处理模块。等安装IKOS时需要将原有的（安装Flang所需）Clang从环境变量中移除（加注释），而安装新的llvm从而加入到环境变量中。之后需要编译IKOS时应该使用官方llvm。</p>
<p>之后所作更改时（Flang和IKOS各自）应该记住这点，因为所使用的llvm版本相同但内容不同，且不冲突。</p>
<p>安装完成后，我还需要将编译得到的一些动态或静态库复制到系统默认查询位置中<code>/usr/lib</code>或<code>/usr/local</code>。这样才算完全没问题。</p>
<h2 id="使用Flang"><a href="#使用Flang" class="headerlink" title="使用Flang"></a>使用Flang</h2><p>使用命令：</p>
<p><code> flang -help</code></p>
<p>来查找它所接受的命令，Flang本身支持所有的Clang的命令，而且支持针对Fortran特定的命令。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">OVERVIEW: clang LLVM compiler</span><br><span class="line"></span><br><span class="line">USAGE: clang-14 [options] file...</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -<span class="comment">###                    Print (but do not run) the commands to run for this compilation</span></span><br><span class="line">  -cpp                    Enable predefined and <span class="built_in">command</span> line preprocessor macros</span><br><span class="line">  -c                      Only run preprocess, compile, and assemble steps</span><br><span class="line">  -D &lt;macro&gt;=&lt;value&gt;      Define &lt;macro&gt; to &lt;value&gt; (or 1 <span class="keyword">if</span> &lt;value&gt; omitted)</span><br><span class="line">  -E                      Only run the preprocessor</span><br><span class="line">  -falternative-parameter-statement</span><br><span class="line">                          Enable the old style PARAMETER statement</span><br><span class="line">  -fbackslash             Specify that backslash <span class="keyword">in</span> string introduces an escape character</span><br><span class="line">  -fcolor-diagnostics     Enable colors <span class="keyword">in</span> diagnostics</span><br><span class="line">  -fdefault-double-8      Set the default double precision kind to an 8 byte wide <span class="built_in">type</span></span><br><span class="line">  -fdefault-integer-8     Set the default <span class="built_in">integer</span> kind to an 8 byte wide <span class="built_in">type</span></span><br><span class="line">  -fdefault-real-8        Set the default real kind to an 8 byte wide <span class="built_in">type</span></span><br><span class="line">  -ffixed-form            Process <span class="built_in">source</span> files <span class="keyword">in</span> fixed form</span><br><span class="line">  -ffixed-line-length-&lt;value&gt;</span><br><span class="line">                          Set line length <span class="keyword">in</span> fixed-form format Fortran, current supporting only 72 and 132 characters</span><br><span class="line">  -ffree-form             Process <span class="built_in">source</span> files <span class="keyword">in</span> free form</span><br><span class="line">  -finput-charset=&lt;value&gt; Specify the default character <span class="built_in">set</span> <span class="keyword">for</span> <span class="built_in">source</span> files</span><br><span class="line">  -fintrinsic-modules-path &lt;<span class="built_in">dir</span>&gt;</span><br><span class="line">                          Specify <span class="built_in">where</span> to find the compiled intrinsic modules</span><br><span class="line">  -flarge-sizes           Use INTEGER(KIND=8) <span class="keyword">for</span> the result <span class="built_in">type</span> <span class="keyword">in</span> size-related intrinsics</span><br><span class="line">  -fno-color-diagnostics  Disable colors <span class="keyword">in</span> diagnostics</span><br><span class="line">  -fno-fixed-form         Disable fixed-form format <span class="keyword">for</span> Fortran</span><br><span class="line">  -fno-free-form          Disable free-form format <span class="keyword">for</span> Fortran</span><br><span class="line">  -fopenacc               Enable OpenACC</span><br><span class="line">  -fopenmp                Parse OpenMP pragmas and generate parallel code.</span><br><span class="line">  -<span class="built_in">help</span>                   Display available options</span><br><span class="line">  -I &lt;<span class="built_in">dir</span>&gt;                Add directory to the end of the list of include search paths</span><br><span class="line">  -module-dir &lt;<span class="built_in">dir</span>&gt;       Put MODULE files <span class="keyword">in</span> &lt;<span class="built_in">dir</span>&gt;</span><br><span class="line">  -nocpp                  Disable predefined and <span class="built_in">command</span> line preprocessor macros</span><br><span class="line">  -o &lt;file&gt;               Write output to &lt;file&gt;</span><br><span class="line">  -pedantic               Warn on language extensions</span><br><span class="line">  -P                      Disable linemarker output <span class="keyword">in</span> -E mode</span><br><span class="line">  -std=&lt;value&gt;            Language standard to compile <span class="keyword">for</span></span><br><span class="line">  -U &lt;macro&gt;              Undefine macro &lt;macro&gt;</span><br><span class="line">  --version               Print version information</span><br><span class="line">  -W&lt;warning&gt;             Enable the specified warning</span><br><span class="line">  -Xflang &lt;arg&gt;           Pass &lt;arg&gt; to the flang compiler</span><br></pre></td></tr></table></figure>

<p>因为我们要用的只是将Fortran转成IR，而且不涉及并行程序（OpenMP），所以只用传统的一些命令行转化即可。</p>
<p>下面列举出一些可以使用的组合命令，以及它们的功能。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">flang -emit-llvm test.f90 -S -c -o test.ll</span><br><span class="line"><span class="comment"># 传统的clang命令生成llvm IR，且是可读版本.ll：汇编文件</span></span><br><span class="line">flang -emit-llvm test.f90 -c -o test.bc</span><br><span class="line"><span class="comment"># 从源码转换成机器码.bc：位码文件</span></span><br><span class="line">llvm-as test.ll -o test.bc</span><br><span class="line"><span class="comment"># 将.ll转换成.bc</span></span><br><span class="line">llvm-dis test.bc -o test.ll</span><br><span class="line"><span class="comment"># 将.bc转换成.ll</span></span><br><span class="line">lli test.bc</span><br><span class="line"><span class="comment"># 直接执行.bc文件</span></span><br><span class="line">llvm-extract --func=foo test.bc -o test-func.bc	<span class="comment"># 用test.ll也可以</span></span><br><span class="line"><span class="comment"># 从位码文件中抽取函数名为foo的函数，除了抽取函数，还可以抽取别名和全局变量</span></span><br></pre></td></tr></table></figure>

<p>一般来说，只用生成汇编文件或位码文件即可，汇编文件用来人为阅读，位码文件直接输入到IKOS中进行分析。</p>
<p>列出Clang的一些命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. .c -&gt; .i</span></span><br><span class="line">clang -E -c test.c -o test.i</span><br><span class="line"><span class="comment"># 2. .c -&gt; .bc</span></span><br><span class="line">clang -emit-llvm test.c -c -o test.bc</span><br><span class="line"><span class="comment"># 3. .c -&gt; .ll</span></span><br><span class="line">clang -emit-llvm test.c -S -o test.ll</span><br><span class="line"><span class="comment"># 4. .i -&gt; .bc</span></span><br><span class="line">clang -emit-llvm test.i -c -o test.bc</span><br><span class="line"><span class="comment"># 5. .i -&gt; .ll</span></span><br><span class="line">clang -emit-llvm test.i -S -o test.ll</span><br><span class="line"><span class="comment"># 6. .bc -&gt; .ll</span></span><br><span class="line">llvm-dis test.bc -o test.ll</span><br><span class="line"><span class="comment"># 7. .ll -&gt; .bc</span></span><br><span class="line">llvm-as test.ll -o test.bc</span><br><span class="line"><span class="comment"># 8. 多 bc 合并为一个 bc</span></span><br><span class="line">llvm-link test1.bc test2.bc -o test.bc</span><br></pre></td></tr></table></figure>

<p><img src="/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/Center.jpg" alt="img"></p>
<h2 id="Flang转换成-ll的结果"><a href="#Flang转换成-ll的结果" class="headerlink" title="Flang转换成.ll的结果"></a>Flang转换成.ll的结果</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">source_filename = <span class="string">&quot;/path/to/source.c&quot;</span></span><br><span class="line"><span class="comment"># 这里描述了源文件的名称和所在路径</span></span><br><span class="line">target datalayout = <span class="string">&quot;layout specification&quot;</span></span><br><span class="line"><span class="comment"># 这里描述了目标机器中数据的内存布局方式，包括字节序、类型以及对齐方式</span></span><br><span class="line"><span class="comment"># 这个参数对理解LLVM关系不大</span></span><br><span class="line">target triple = <span class="string">&quot;ARCHITECTURE-VENDOR-OPERATIONG_SYSTEM&quot;</span></span><br><span class="line">target triple = <span class="string">&quot;ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT&quot;</span></span><br><span class="line"><span class="comment"># 描述了目标机器是什么，从而指示后端生成相应的目标代码</span></span><br><span class="line">Identifiers</span><br><span class="line"><span class="comment"># 标识符分为：全局标识符和局部标识符。全局标识符以@开头，如全局函数、全局变量。局部标识符以%开头，类似于汇编语言中的寄存器</span></span><br><span class="line"><span class="comment"># 标识符有3种形式：</span></span><br><span class="line"><span class="comment">## 有名称的值，表示带有前缀（@或%）的字符串。如：%Val, @name</span></span><br><span class="line"><span class="comment">## 无名称的值，表示带前缀（@或%）的无符号数值。如%0, %1, @2</span></span><br><span class="line"><span class="comment">## 常量</span></span><br><span class="line">Functions</span><br><span class="line"><span class="comment"># define用于定义一个函数</span></span><br><span class="line">define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]</span><br><span class="line">       [cconv] [ret attrs]</span><br><span class="line">       &lt;ResultType&gt; @&lt;FunctionName&gt; ([argument list])</span><br><span class="line">       [(unnamed_addr|local_unnamed_addr)] [AddrSpace] [fn Attrs]</span><br><span class="line">       [section <span class="string">&quot;name&quot;</span>] [comdat [(<span class="variable">$name</span>)]] [align N] [gc] [prefix Constant]</span><br><span class="line">       [prologue Constant] [personality Constant] (!name !N)* &#123; ... &#125;</span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">define dso_local void @foo(i32 %x) <span class="comment">#0 &#123;</span></span><br><span class="line">  ; 省略 ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># define void @foo(i32 %x) &#123; ... &#125;，表示定义一个函数。其函数名称为foo，返回值的数据类型为void，参数（用%x表示）的数据类型为 i32（占用4字节的整型）</span></span><br><span class="line"><span class="comment"># #0，用于修饰函数时表示一组函数属性。这些属性定义在文件末尾</span></span><br><span class="line">  7 define weak dso_local void @foo(i32 %x) <span class="comment">#0 &#123;</span></span><br><span class="line">  8 entry:</span><br><span class="line">  9   %x.addr = alloca i32, align 4</span><br><span class="line"> 10   %y = alloca i32, align 4</span><br><span class="line"> 11   %z = alloca i32, align 4</span><br><span class="line"> 12   store i32 %x, i32* %x.addr, align 4</span><br><span class="line"> 13   %0 = load i32, i32* %x.addr, align 4</span><br><span class="line"> 14   %cmp = icmp eq i32 %0, 0</span><br><span class="line"> 15   br i1 %cmp, label %if.then, label %if.end</span><br><span class="line"> 16 </span><br><span class="line"> 17 if.then:                                          ; preds = %entry</span><br><span class="line"> 18   store i32 5, i32* %y, align 4</span><br><span class="line"> 19   br label %if.end</span><br><span class="line"> 20 </span><br><span class="line"> 21 if.end:                                           ; preds = %if.then, %entry</span><br><span class="line"> 22   %1 = load i32, i32* %x.addr, align 4</span><br><span class="line"> 23   %tobool = icmp ne i32 %1, 0</span><br><span class="line"> 24   br i1 %tobool, label %if.end2, label %if.then1</span><br><span class="line"> 25 </span><br><span class="line"> 26 if.then1:                                         ; preds = %if.end</span><br><span class="line"> 27   store i32 6, i32* %z, align 4</span><br><span class="line"> 28   br label %if.end2</span><br><span class="line"> 29 </span><br><span class="line"> 30 if.end2:                                          ; preds = %if.then1, %if.end</span><br><span class="line"> 31   ret void</span><br><span class="line"> 32 &#125;</span><br><span class="line"><span class="comment"># LLVM IR中，函数体是由基本块构成的。基本块是由一系列顺序执行的语句构成的，并（可选地）以标签作为起始。不同的标签代表不同的基本块</span></span><br><span class="line"><span class="comment"># 基本块的特点如下：</span></span><br><span class="line"><span class="comment">## 仅有一个入口，即基本块中的第一条指令</span></span><br><span class="line"><span class="comment">## 仅有一个出口，即基本块中的最后一条指令（被称为terminator instruction）。该指令要么跳转到其他基本块（不包括入口基本块），要买从函数返回</span></span><br><span class="line"><span class="comment">## 函数体中第一个出现的基本块，称为入口基本块（Entry Basic Block）。它是一个特殊的基本块，在进入函数时立即执行该基本块，并且不允许作为其他基本块的跳转目标（即不允许该基本块有前继结点）</span></span><br></pre></td></tr></table></figure>

<h2 id="LLVM-IR生成文件过程"><a href="#LLVM-IR生成文件过程" class="headerlink" title="LLVM IR生成文件过程"></a>LLVM IR生成文件过程</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.c --frontend--&gt; AST --frontend--&gt; LLVM IR --LLVM opt--&gt; LLVM IR --LLVM llc--&gt; .s Assembly --OS Assembler--&gt; .o --OS Linker--&gt; executable</span><br></pre></td></tr></table></figure>

<h2 id="LLVM-IR语法的基本概念"><a href="#LLVM-IR语法的基本概念" class="headerlink" title="LLVM IR语法的基本概念"></a>LLVM IR语法的基本概念</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>以<code>;</code>开头并一直延申到行尾，作为注释行。</p>
<h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><p>主程序是可执行程序执行的入口点，所以任何可执行程序都需要<code>main</code>函数才能运行。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是主程序，在<code>@main()</code>之后的就是函数的函数体，<code>ret i32 0</code>就代表C语言中的<code>return 0;</code>。因此，如果要增加代码，就只需要在大括号内，<code>ret i32 0</code>前增加代码即可。</p>
<h3 id="目标数据布局"><a href="#目标数据布局" class="headerlink" title="目标数据布局"></a>目标数据布局</h3><p>LLVM也支持我们手动定制这样的数据布局，例如，我们可以在LLVM IR的源代码中写：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target</span> <span class="keyword">datalayout</span> <span class="operator">=</span> <span class="string">&quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br></pre></td></tr></table></figure>

<p>这一长串文字就定义了目标的数据布局。具体而言：</p>
<ul>
<li><code>e</code>: 小端序</li>
<li><code>m:e</code>: 符号表中使用ELF格式的命名修饰</li>
<li><code>p270:32:32-p271:32:32-p272:64:64</code>: 与地址空间有关</li>
<li><code>i64:64</code>: 将<code>i64</code>类型的变量采用64位的ABI对齐</li>
<li><code>f80:128</code>: 将<code>long double</code>类型的变量采用128位的ABI对齐</li>
<li><code>n8:16:32:64</code>: 目标CPU的原生整型包含8位、16位、32位和64位</li>
<li><code>S128</code>: 栈以128位自然对齐</li>
</ul>
<h3 id="C的例子"><a href="#C的例子" class="headerlink" title="C的例子"></a>C的例子</h3><p>关于符号和符号表，这些还是挺抽象的，我们不如用一个具体的C语言的例子来看看效果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> c;</span><br><span class="line"><span class="type">void</span> <span class="title function_">d</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">e</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们先理解一下这个C语言代码各个符号的含义：</p>
<ul>
<li><p><code>a</code></p>
<p> 定义在<strong>当前文件中的全局变量</strong>，别的文件也可以使用这个符号</p>
</li>
<li><p><code>b</code></p>
<p> 定义在<strong>别的文件中的全局变量</strong>，当前文件需要使用这个符号</p>
</li>
<li><p><code>c</code></p>
<p> 定义在<strong>当前文件中的全局变量，别的文件不可以使用这个符号</strong></p>
</li>
<li><p><code>d</code></p>
<p> 定义在<strong>别的文件中的函数，当前文件需要使用这个符号</strong></p>
</li>
<li><p><code>e</code></p>
<p> 定义在<strong>当前文件中的函数，别的文件也可以使用这个符号</strong></p>
</li>
<li><p><code>f</code></p>
<p> 定义在<strong>当前文件中的函数，别的文件不可以使用这个符号</strong></p>
</li>
</ul>
<p>以上六种，是我们在C语言编程中最常见的符号形式。</p>
<p>我们使用Clang将其编译为LLVM IR，是什么样子的呢？</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@a</span> <span class="operator">=</span> dso_local <span class="keyword">global</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line"><span class="title">@b</span> <span class="operator">=</span> <span class="keyword">external</span> <span class="keyword">global</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line"><span class="title">@c</span> <span class="operator">=</span> <span class="keyword">internal</span> <span class="keyword">global</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@d</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@e</span>() &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="keyword">internal</span> void <span class="title">@f</span>() &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现几件事（在默认的编译选项下）：</p>
<ul>
<li>C语言中的<code>static</code>，也就是当前文件中定义，别的文件不可以用的，都会加上<code>internal</code>修饰符</li>
<li>C语言中的<code>extern</code>，也就是别的文件中定义的，全局变量会加上<code>external</code>修饰符，函数会使用<code>declare</code></li>
<li>C语言中定义的，可以给别的文件使用的全局变量或函数，不会加上链接类型修饰符，并且会加上<code>dso_local</code>保证不会被抢占</li>
</ul>
<h2 id="寄存器和栈"><a href="#寄存器和栈" class="headerlink" title="寄存器和栈"></a>寄存器和栈</h2><p>这两种数据我选择放在一起讲。我们知道，大多数对数据的操作，如加减乘除、比大小等，都需要操作的是<strong>寄存器</strong>内的数据。那么，我们为什么需要把数据放在<strong>栈</strong>上呢？主要有两个原因：</p>
<ul>
<li>寄存器数量不够</li>
<li>需要操作内存地址</li>
</ul>
<p>如果我们一个函数内有三四十个局部变量，但是家用型CPU最多也就十几个通用寄存器，所以我们不可能把所有变量都放在寄存器中。因此我们需要把一部分数据放在内存中，栈就是一个很好的存储数据的地方；此外，有时候我们需要直接操作内存地址，但是寄存器并没有通用的地址表示，所以只能把数据放在栈上来完成对地址的操作。</p>
<p>因此，<strong>在不操作内存地址的前提下，栈只是寄存器的一个替代品。</strong>如果寄存器的数量足够，并且代码中没有需要操作内存地址的时候，寄存器是足够胜任的，并且更加高效的。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>正因为如此，LLVM IR引入了虚拟寄存器的概念。在LLVM IR中，一个函数的局部变量可以是寄存器或者栈上的变量。对于寄存器而言，我们只需要像普通的赋值语句一样操作，但需要注意名字必须以<code>%</code>开头：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%local_variable</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>此时，<code>%local_variable</code>这个变量就代表一个寄存器，它此时的值就是<code>1</code>和<code>2</code>相加的结果。我们可以写一个简单的程序验证这一点：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; register_test.ll</span></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="variable">%local_variable</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%local_variable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们查看其编译出的汇编代码，其主函数为：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">main:</span></span><br><span class="line">    movl    <span class="number">$2</span>, %eax</span><br><span class="line">    addl    <span class="number">$1</span>, %eax</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>

<p>确实这个局部变量<code>%local_variable</code>变成了寄存器<code>eax</code>。</p>
<p>关于寄存器，我们还需了解一点。在不同的ABI下，会有一些callee-saved register和caller-saved register。简单来说，就是在函数内部，某些寄存器的值不能改变。或者说，在函数返回时，某些寄存器的值要和进入函数前相同。比如，在System V的ABI下，<code>rbp</code>, <code>rbx</code>, <code>r12</code>, <code>r13</code>, <code>r14</code>, <code>r15</code>都需要满足这一条件。由于LLVM IR是面向多平台的，所以我们需要一份代码适用于多种ABI。因此，<strong>LLVM IR内部自动帮我们做了这些事。如果我们把所有没有被保留的寄存器都用光了，那么LLVM IR会帮我们把这些被保留的寄存器放在栈上，然后继续使用这些被保留寄存器。当函数退出时，会帮我们自动从栈上获取到相应的值放回寄存器内。</strong></p>
<p>那么，如果所有通用寄存器都用光了，该怎么办？LLVM IR会帮我们把剩余的值放在栈上，但是对我们用户而言，<em>实际上都是虚拟寄存器，用户是感觉不到差别的。</em></p>
<p>因此，我们可以粗略地理解LLVM IR对寄存器的使用：</p>
<ul>
<li>当所需寄存器数量较少时，直接使用callee-saved register，即不需要保留的寄存器</li>
<li>当callee-saved register不够时，将caller-saved register原本的值压栈，然后使用caller-saved register</li>
<li>当寄存器用光以后，就把多的虚拟寄存器的值压栈</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>我们之前说过，当不需要操作地址并且寄存器数量足够时，我们可以直接使用寄存器。而LLVM IR的策略保证了我们可以<strong>使用无数的虚拟寄存器</strong>。那么，<em>在需要操作地址以及需要可变变量时，我们就需要使用栈。</em></p>
<p>LLVM IR对栈的使用十分简单，直接使用<code>alloca</code>指令即可。如：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%local_variable</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br></pre></td></tr></table></figure>

<p>就可以声明一个在栈上的变量了。关于栈上变量的操作，我会在之后提到，目前我们对栈上变量的了解只需这么多。</p>
<p>###数据的使用</p>
<p>在之前的两篇文章中，我们解释了LLVM中是如何对应数据区、寄存器和栈上的数据的。那么，这些数据定义了以后，该如何使用呢？</p>
<h3 id="全局变量和栈上变量皆指针"><a href="#全局变量和栈上变量皆指针" class="headerlink" title="全局变量和栈上变量皆指针"></a>全局变量和栈上变量皆指针</h3><p>下面，我们就需要讲怎样使用<em>全局变量和栈上的变量</em>。这两种变量实际上是类似的，LLVM IR把它们都看作指针。也就是说，对于全局变量：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@global_variable</span> <span class="operator">=</span> <span class="keyword">global</span> <span class="type">i32</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>和栈上变量</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%local_variable</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br></pre></td></tr></table></figure>

<p>这两个变量实际上都是<code>ptr</code>指针，指向它们所处的一个<code>i32</code>大小的内存区域。所以，我们不能这样：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="title">@global_variable</span> <span class="comment">; Wrong!</span></span><br></pre></td></tr></table></figure>

<p>因为<code>@global_variable</code>只是一个指针。</p>
<p>如果要操作这些值，必须使用<code>load</code>和<code>store</code>这两个命令。如果我们要获取<code>@global_variable</code>的值，就需要</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="title">@global_variable</span></span><br></pre></td></tr></table></figure>

<p>这个指令的意思是，把一个<code>ptr</code>指针<code>@global_variable</code>的<code>i32</code>类型的值赋给虚拟寄存器<code>%1</code>，然后我们就能愉快地</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="variable">%1</span></span><br></pre></td></tr></table></figure>

<p>这样了。</p>
<p>类似地，如果我们要将值存储到全局变量或栈上变量里，会需要<code>store</code>命令：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> ptr <span class="title">@global_variable</span></span><br></pre></td></tr></table></figure>

<p>这个代表将<code>i32</code>类型的值<code>1</code>赋给<code>ptr</code>类型的全局变量<code>@global_variable</code>所指的内存区域中。</p>
<h3 id="SSA"><a href="#SSA" class="headerlink" title="SSA"></a>SSA</h3><p>LLVM IR是一个严格遵守SSA(Static Single Assignment)策略的语言。SSA的要求很简单：每个变量只被赋值一次。也就是说，你不能</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>对<code>%1</code>同时赋值两次是不被允许的。</p>
<p>SSA作为一个历史悠久的概念，已经有了相当成熟的相关技术。通过使用SSA，编译器可以进行更好的优化，应用更成熟的算法，得到更好的结果。这里因为个人能力有限，就不再多对SSA进行介绍。我们只需要知道，通过约束每个变量只被赋值一次，可以让LLVM更好地优化。</p>
<p>上面这个例子好做，直接把3加4的结果赋值给一个新的虚拟寄存器就好了。但是，并非所有的情况都这么简单。在一些复杂情况下，将值存储在栈上再取出来，或者使用<code>phi</code>指令，也是一个更好的选择。</p>
<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>我们知道，汇编语言是弱类型的，我们操作汇编语言的时候，实际上考虑的是一些二进制序列。但是，LLVM IR却是强类型的，在LLVM IR中所有变量都必须有类型。这是因为，我们在使用高级语言编程的时候，往往都会使用强类型的语言，弱类型的语言无必要性，也不利于维护。因此，使用强类型语言，LLVM IR可以更好地进行优化。</p>
<h3 id="基本的数据类型"><a href="#基本的数据类型" class="headerlink" title="基本的数据类型"></a>基本的数据类型</h3><p>LLVM IR中比较基本的数据类型包括：</p>
<ul>
<li>空类型（<code>void</code>）</li>
<li>整型（<code>iN</code>）</li>
<li>浮点型（<code>float</code>、<code>double</code>等）</li>
</ul>
<p>空类型一般是作为不返回值的函数的返回类型，没有特别的含义，就代表「什么都没有」。</p>
<p>整型是指<code>i1</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>这类的数据类型。这里<code>iN</code>的<code>N</code>可以是任意正整数，可以是<code>i3</code>，<code>i1942652</code>。但最常用，最符合常理的就是<code>i1</code>以及8的整数倍。<code>i1</code>有两个值：<code>true</code>和<code>false</code>。也就是说，下面的代码可以正确编译：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%boolean_variable</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i1</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i1</span> <span class="keyword">true</span><span class="punctuation">,</span> ptr <span class="variable">%boolean_variable</span></span><br></pre></td></tr></table></figure>

<p>对于大于1位的整型，也就是如<code>i8</code>, <code>i16</code>等类型，我们可以直接用数字字面量赋值：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%integer_variable</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">128</span><span class="punctuation">,</span> ptr <span class="variable">%integer_variable</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">-128</span><span class="punctuation">,</span> ptr <span class="variable">%integer_variable</span></span><br></pre></td></tr></table></figure>

<h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>有一点需要注意的是，在LLVM IR中，整型默认是有符号整型，也就是说我们可以直接将<code>-128</code>以补码形式赋值给<code>i32</code>类型的变量。在LLVM IR中，整型的有无符号是<strong>体现在操作指令而非类型上</strong>的，比方说，对于两个整型变量的除法，LLVM IR分别提供了<code>udiv</code>和<code>sdiv</code>指令分别适用于无符号整型除法和有符号整型除法：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">udiv</span> <span class="type">i8</span> <span class="number">-6</span><span class="punctuation">,</span> <span class="number">2</span>    <span class="comment">; Get (256 - 6) / 2 = 125</span></span><br><span class="line"><span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">sdiv</span> <span class="type">i8</span> <span class="number">-6</span><span class="punctuation">,</span> <span class="number">2</span>    <span class="comment">; Get (-6) / 2 = -3</span></span><br></pre></td></tr></table></figure>

<p>我们可以用这样一个简单的程序验证：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; div_test.ll</span></span><br><span class="line"><span class="keyword">define</span> <span class="type">i8</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">udiv</span> <span class="type">i8</span> <span class="number">-6</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line">    <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">sdiv</span> <span class="type">i8</span> <span class="number">-6</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i8</span> <span class="variable">%1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别将<code>ret</code>语句的参数换成<code>%1</code>和<code>%2</code>以后，将代码编译成可执行文件，在终端下运行并查看返回值即可。</p>
<p>总结一下就是，LLVM IR中的<em>整型默认按有符号补码存储</em>，但一个变量究竟是否要被看作有无符号数需要看其参与的指令。</p>
<h3 id="转换指令"><a href="#转换指令" class="headerlink" title="转换指令"></a>转换指令</h3><p>与整型密切相关的就是转换指令，比如说，将<code>i8</code>类型的数<code>-127</code>转换成<code>i32</code>类型的数，将<code>i32</code>类型的数<code>257</code>转换成<code>i8</code>类型的数等。总的来说，LLVM IR中提供三种指令：<code>trunc</code> .. <code>to</code>指令，<code>zext</code> .. <code>to</code>指令和<code>sext</code> .. <code>to</code>指令。</p>
<p>将长的整型转换成短的整型很简单，直接把多余的高位去掉就行，LLVM IR提供的是<code>trunc</code> .. <code>to</code>指令：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%trunc_integer</span> <span class="operator">=</span> <span class="keyword">trunc</span> <span class="type">i32</span> <span class="number">257</span> <span class="keyword">to</span> <span class="type">i8</span> <span class="comment">; Trunc 32 bit 100000001 to 8 bit, get 1</span></span><br></pre></td></tr></table></figure>

<p>将短的整型变成长的整型则相对比较复杂。这是因为，在补码中最高位是符号位，并不表示实际的数值。因此，如果单纯地在更高位补<code>0</code>，那么<code>i8</code>类型的<code>-1</code>（补码为<code>11111111</code>）就会变成<code>i32</code>的<code>255</code>。这虽然符合道理，但有时候我们需要<code>i8</code>类型的<code>-1</code>扩展到<code>i32</code>时仍然是<code>-1</code>。LLVM IR为我们提供了两种指令：零扩展的<code>zext</code> .. <code>to</code>指令和符号扩展的<code>sext</code> .. <code>to</code>指令。</p>
<p>零扩展就是最简单的，直接在高位补<code>0</code>，而符号扩展则是用原数的符号位来填充。也就是说我们如下的代码：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%zext_integer</span> <span class="operator">=</span> <span class="keyword">zext</span> <span class="type">i8</span> <span class="number">-1</span> <span class="keyword">to</span> <span class="type">i32</span> <span class="comment">; Extend 8 bit 0xFF to 32 bit 0x000000FF, get 255</span></span><br><span class="line"><span class="variable">%sext_integer</span> <span class="operator">=</span> <span class="keyword">sext</span> <span class="type">i8</span> <span class="number">-1</span> <span class="keyword">to</span> <span class="type">i32</span> <span class="comment">; Extend 8 bit 0xFF to 32 bit 0xFFFFFFFF, get -1</span></span><br></pre></td></tr></table></figure>

<p>类似地，浮点型的数和整型的数也可以相互转换，使用<code>fptoui</code> .. <code>to</code>, <code>fptosi</code> .. <code>to</code>, <code>uitofp</code> .. <code>to</code>, <code>sitofp</code> .. <code>to</code>可以分别将浮点数转换为无符号、有符号整型，将无符号、有符号整型转换为浮点数。不过有一点要注意的是，如果将大数转换为小的数，那么并不保证截断，如将浮点型的<code>257.1</code>转换成<code>i8</code>（上限为<code>128</code>），那么就会产生未定义行为。所以，在浮点型和整型相互转换的时候，需要在高级语言层面做一些调整，如使用饱和转换等。</p>
<h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><p>LLVM IR中的指针类型就是<code>ptr</code>。与C语言不同，LLVM IR中的指针不含有其指向内容的类型，也就是说，类似于C语言中的<code>void *</code>。我们之前提到，LLVM IR中的全局变量和栈上分配的变量都是指针，所以其类型都是指针类型。</p>
<p>在高级语言中，直接操作裸指针的机会都比较少，除非在性能极其敏感的场景下，由最厉害的大佬才能操作裸指针。这是因为，裸指针极其危险，稍有不慎就会出现段错误等致命错误，所以我们使用指针时应该慎之又慎。</p>
<p>LLVM IR为大佬们提供了操作裸指针的一些指令。在C语言中，我们会遇到这种场景：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">size_t</span> address_of_x = (<span class="type">size_t</span>)&amp;x;</span><br><span class="line"><span class="type">size_t</span> address_of_y = address_of_x - <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> also_y = *(<span class="type">int</span> *)address_of_y;</span><br></pre></td></tr></table></figure>

<p>这种场景比较无脑，但确实是合理的，需要将指针看作一个具体的数值进行加减。到x86_64的汇编语言层次，取地址就变成了<code>lea</code>命令，解引用倒是比较正常，就是一个简单的<code>mov</code>。</p>
<p>在LLVM IR层次，为了使指针能像整型一样加减，提供了<code>ptrtoint</code> .. <code>to</code>指令和<code>inttoptr</code> .. <code>to</code>指令，分别解决将指针转换为整型，和将整型转换为指针的功能。也就是说，我们可以粗略地将上面的程序转写为</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%x</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span> <span class="comment">; %x is of type ptr, which is the address of variable x</span></span><br><span class="line"><span class="variable">%y</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span> <span class="comment">; %y is of type ptr, which is the address of variable y</span></span><br><span class="line"><span class="variable">%address_of_x</span> <span class="operator">=</span> <span class="keyword">ptrtoint</span> ptr <span class="variable">%x</span> <span class="keyword">to</span> <span class="type">i64</span></span><br><span class="line"><span class="variable">%address_of_y</span> <span class="operator">=</span> <span class="keyword">sub</span> <span class="type">i64</span> <span class="variable">%address_of_x</span><span class="punctuation">,</span> <span class="number">4</span></span><br><span class="line"><span class="variable">%also_y</span> <span class="operator">=</span> <span class="keyword">inttoptr</span> <span class="type">i64</span> <span class="variable">%address_of_y</span> <span class="keyword">to</span> ptr <span class="comment">; %also_y is of type ptr, which is the address of variable y</span></span><br></pre></td></tr></table></figure>

<h2 id="聚合类型"><a href="#聚合类型" class="headerlink" title="聚合类型"></a>聚合类型</h2><p>比起指针类型而言，更重要的是<strong>聚合类型</strong>。我们在C语言中常见的聚合类型有数组和结构体，LLVM IR也为我们提供了相应的支持。</p>
<p>数组类型很简单，我们要声明一个类似C语言中的<code>int a[4]</code>，只需要</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%a</span> <span class="operator">=</span> <span class="keyword">alloca</span> [<span class="number">4</span> <span class="keyword">x</span> <span class="type">i32</span>]</span><br></pre></td></tr></table></figure>

<p>也就是说，C语言中的<code>int[4]</code>类型在LLVM IR中可以写成<code>[4 x i32]</code>。注意，**这里面是个<code>x</code>不是<code>*</code>**。</p>
<p>我们也可以使用类似地语法进行初始化：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@global_array</span> <span class="operator">=</span> <span class="keyword">global</span> [<span class="number">4</span> <span class="keyword">x</span> <span class="type">i32</span>] [<span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>特别地，我们知道，字符串在底层可以看作字符组成的数组，所以LLVM IR为我们提供了语法糖：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@global_string</span> <span class="operator">=</span> <span class="keyword">global</span> [<span class="number">12</span> <span class="keyword">x</span> <span class="type">i8</span>] <span class="keyword">c</span><span class="string">&quot;Hello world<span class="char escape_">\00</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>在字符串中，转义字符必须以<code>\xy</code>的形式出现，其中<code>xy</code>是这个转义字符的ASCII码。比如说，字符串的结尾，C语言中的<code>\0</code>，在LLVM IR中就表现为<code>\00</code>。</p>
<p>结构体的类型也相对比较简单，在C语言中的结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">char</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在LLVM IR中就成了</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123;</span><br><span class="line">    <span class="type">i32</span><span class="punctuation">,</span></span><br><span class="line">    <span class="type">i8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们初始化一个结构体也很简单：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@global_structure</span> <span class="operator">=</span> <span class="keyword">global</span> <span class="variable">%MyStruct</span> &#123; <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i8</span> <span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">; or</span></span><br><span class="line"><span class="title">@global_structure</span> <span class="operator">=</span> <span class="keyword">global</span> &#123; <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i8</span> &#125; &#123; <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i8</span> <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，无论是数组还是结构体，其作为全局变量或栈上变量，依然是指针，也就是说，<code>@global_array</code>的类型是<code>ptr</code>, <code>@global_structure</code>的类型也是<code>ptr</code>。接下来的问题就是，我们如何对聚合类型进行操作呢？</p>
<p>在LLVM IR中，<em>如果我们想对一个聚合类型的某些字段进行操作，需要区分这个聚合类型是指针形式的</em>，也就是以全局变量或者栈形式存储，还是值形式的，也就是以寄存器形式存储。</p>
<h3 id="getelementptr"><a href="#getelementptr" class="headerlink" title="getelementptr"></a><code>getelementptr</code></h3><p>首先，我们将介绍以指针形式存储的聚合类型，该如何访问其字段。</p>
<h4 id="访问数组元素字段"><a href="#访问数组元素字段" class="headerlink" title="访问数组元素字段"></a>访问数组元素字段</h4><p>我们先来看一个最直观的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="keyword">struct</span> MyStruct *my_structs_ptr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> my_y = my_structs_ptr[<span class="number">2</span>].y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有一个<code>foo</code>函数，其接收了一个参数<code>my_structs_ptr</code>。从函数体的语义可知，这里这个参数，实际上指向了一个数组，我们要取这个数组的第三个元素的<code>y</code>字段。</p>
<p>我们先直接看结论，用LLVM IR来表示为</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123; <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(ptr <span class="variable">%my_structs_ptr</span>) &#123;</span><br><span class="line">    <span class="variable">%my_y_in_stack</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%my_y_ptr</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="variable">%MyStruct</span><span class="punctuation">,</span> ptr <span class="variable">%my_structs_ptr</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line">    <span class="variable">%my_y_val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%my_y_ptr</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%my_y_val</span><span class="punctuation">,</span> ptr <span class="variable">%my_y_in_stack</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以注意到，最核心的就是<code>getelementptr</code>指令了。它的四个参数的语义分别为<code>%MyStruct, ptr %my_structs_ptr, i64 2, i32 1</code></p>
<p>我们要取地址的指针，它指向区域的类型为<code>%MyStruct</code></p>
<ul>
<li><p><code>ptr %my_structs_ptr</code></p>
<p> 我们要操作的指针，是<code>ptr %my_structs_ptr</code></p>
</li>
<li><p><code>i64 2</code></p>
<p> 取偏移量为2的那个元素，也就是<code>my_structs_ptr[2]</code></p>
</li>
<li><p><code>i32 1</code></p>
<p> 对于获得到的那个元素，取索引为1的字段，也就是<code>my_structs_ptr[2].y</code></p>
</li>
</ul>
<p>通过这个指令，我们获得了<code>my_structs_ptr[2].y</code>的地址，随后的LLVM IR指令就是将这个地址的值放到了局部变量中。</p>
<h4 id="访问指针字段"><a href="#访问指针字段" class="headerlink" title="访问指针字段"></a>访问指针字段</h4><p>接下来，我们看这样一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="keyword">struct</span> MyStruct *my_structs_ptr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> my_y = my_structs_ptr-&gt;y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其对应的LLVM IR为</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123; <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(ptr <span class="variable">%my_structs_ptr</span>) &#123;</span><br><span class="line">    <span class="variable">%my_y_in_stack</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%my_y_ptr</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="variable">%MyStruct</span><span class="punctuation">,</span> ptr <span class="variable">%my_structs_ptr</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line">    <span class="variable">%my_y_val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%my_y_ptr</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%my_y_val</span><span class="punctuation">,</span> ptr <span class="variable">%my_y_in_stack</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唯一的改动，就是将之前的偏移量<code>i64 2</code>改为<code>i64 0</code>。</p>
<p>这看上去挺符合直觉的。等等，符合直觉吗？</p>
<p>我们发现，即使是将<code>my_structs_ptr</code>看作是指向结构体的指针，而非指向数组的指针，仍然要加一个偏移量<code>0</code>。这是因为，C语言中，对于一个数组<code>array</code>，<code>&amp;array[0]</code>和指向首元素的<code>array_ptr</code>是同一个东西。为了兼容C语言这个特性，LLVM IR在<code>getelementptr</code>中，将所有的指针都看作一个指向数组首地址的指针。因此，我们需要额外加一个<code>i64 0</code>的偏移量来解决这个问题。</p>
<h4 id="级联访问"><a href="#级联访问" class="headerlink" title="级联访问"></a>级联访问</h4><p>此外，<code>getelementptr</code>还可以接多个参数，类似于级联调用。我们有C程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> <span class="title">my_structs</span>[4];</span></span><br></pre></td></tr></table></figure>

<p>那么如果我们想获得<code>my_structs[2].y[3]</code>的地址，只需要</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123;</span><br><span class="line">    <span class="type">i32</span><span class="punctuation">,</span></span><br><span class="line">    [<span class="number">5</span> <span class="keyword">x</span> <span class="type">i32</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">%my_structs</span> <span class="operator">=</span> <span class="keyword">alloca</span> [<span class="number">4</span> <span class="keyword">x</span> <span class="variable">%MyStruct</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">4</span> <span class="keyword">x</span> <span class="variable">%MyStruct</span>]<span class="punctuation">,</span> ptr <span class="variable">%my_structs</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>我们可以查看官方提供的<a href="http://llvm.org/docs/GetElementPtr.html">The Often Misunderstood GEP Instruction</a>指南更多地了解<code>getelementptr</code>的机理。</p>
<h2 id="extractvalue和insertvalue"><a href="#extractvalue和insertvalue" class="headerlink" title="extractvalue和insertvalue"></a><code>extractvalue</code>和<code>insertvalue</code></h2><p>除了我们上面讲的这种情况，也就是把结构体分配在栈或者全局变量，然后操作其指针以外，还有什么情况呢？我们考虑这种情况：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; extract_insert_value.ll</span></span><br><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123;</span><br><span class="line">    <span class="type">i32</span><span class="punctuation">,</span></span><br><span class="line">    <span class="type">i32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title">@my_struct</span> <span class="operator">=</span> <span class="keyword">global</span> <span class="variable">%MyStruct</span> &#123; <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="variable">%MyStruct</span><span class="punctuation">,</span> ptr <span class="title">@my_struct</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，我们的结构体是直接放在虚拟寄存器<code>%1</code>里，<code>%1</code>并不是存储<code>@my_struct</code>的指针，而是直接存储这个结构体的值。这时，我们并不能用<code>getelementptr</code>来操作<code>%1</code>，因为这个指令需要的是一个指针。因此，LLVM IR提供了<code>extractvalue</code>和<code>insertvalue</code>指令。</p>
<p>因此，如果要获得<code>@my_struct</code>第二个字段的值，我们需要</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">extractvalue</span> <span class="variable">%MyStruct</span> <span class="variable">%1</span><span class="punctuation">,</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>1</code>就代表第二个字段（从<code>0</code>开始）。</p>
<p>类似地，如果要将<code>%1</code>的第二个字段赋值为<code>233</code>，只需要</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">insertvalue</span> <span class="variable">%MyStruct</span> <span class="variable">%1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">233</span><span class="punctuation">,</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>然后<code>%3</code>就会是<code>%1</code>将第二个字段赋值为<code>233</code>后的值。</p>
<p><code>extractvalue</code>和<code>insertvalue</code>并不只适用于结构体，也同样适用于<strong>存储在虚拟寄存器中的数组</strong>，这里不再赘述。</p>
<h2 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a>标签类型</h2><p>在汇编语言中，一切的控制语句、函数调用都是由标签来控制的，在LLVM IR中，控制语句也是需要标签来完成。其具体的内容我会在之后专门有一篇控制语句的文章来解释。</p>
<h2 id="元数据类型"><a href="#元数据类型" class="headerlink" title="元数据类型"></a>元数据类型</h2><p>在我们使用Clang将C语言程序输出成LLVM IR时，会发现代码的最后几行有</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">!llvm.module.flags</span> <span class="operator">=</span> !&#123;<span class="title">!0</span><span class="punctuation">,</span> <span class="title">!1</span><span class="punctuation">,</span> <span class="title">!2</span><span class="punctuation">,</span> <span class="title">!3</span>&#125;</span><br><span class="line"><span class="title">!llvm.ident</span> <span class="operator">=</span> !&#123;<span class="title">!4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!0</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> !<span class="string">&quot;wchar_size&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">4</span>&#125;</span><br><span class="line"><span class="title">!1</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">8</span><span class="punctuation">,</span> !<span class="string">&quot;PIC Level&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span>&#125;</span><br><span class="line"><span class="title">!2</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">7</span><span class="punctuation">,</span> !<span class="string">&quot;PIE Level&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span>&#125;</span><br><span class="line"><span class="title">!3</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">7</span><span class="punctuation">,</span> !<span class="string">&quot;uwtable&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span>&#125;</span><br><span class="line"><span class="title">!4</span> <span class="operator">=</span> !&#123;!<span class="string">&quot;Homebrew clang version 16.0.6&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>类似于这样的东西。</p>
<p>在LLVM IR中，以<code>!</code>开头的标识符为<strong>元数据</strong>。元数据是为了<em>将额外的信息附加在程序中传递给LLVM后端，使后端能够好地优化或生成代码。</em>用于Debug的信息就是通过元数据形式传递的。我们可以使用<code>-g</code>选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang -S -emit-llvm -g test.c</span><br></pre></td></tr></table></figure>

<p>来在LLVM IR中附加额外的Debug信息。关于元数据，在后续的章节里会有更具体的介绍。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>最后，还有一种叫做属性的概念。属性并不是类型，其一般用于函数。比如说，告诉编译器这个函数不会抛出错误，不需要某些优化等等。我们可以看到</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>() <span class="keyword">nounwind</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>nounwind</code>就是一个属性。</p>
<p>有时候，一个函数的属性会特别特别多，并且有多个函数都有相同的属性。那么，就会有大量重复的篇幅用来给每一个函数说明属性。因此，<strong>LLVM IR引入了属性组的概念</strong>，我们在将一个简单的C程序编译成LLVM IR时，会发现代码中有</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; <span class="keyword">noinline</span> <span class="keyword">nounwind</span> <span class="keyword">optnone</span> <span class="keyword">ssp</span> <span class="keyword">uwtable</span> <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;darwin-stkchk-strong-link&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span><span class="operator">=</span><span class="string">&quot;0&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;probe-stack&quot;</span><span class="operator">=</span><span class="string">&quot;___chkstk_darwin&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span><span class="operator">=</span><span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span><span class="operator">=</span><span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这种一大长串的，就是属性组。属性组总是以<code>#</code>开头。当我们函数需要它的时候，只需要</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span> <span class="variable">#0</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接使用<code>#0</code>即可。关于属性，后续也会有专门的章节进行介绍。</p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>在程序分析领域，往往会强调一对概念：<strong>数据流与控制流</strong>。所谓数据流，就是指一个程序中的数据，从硬盘到内存，从内存到寄存器，等等一系列的数据搬运、处理的过程。这一过程，在之前的文章中已经详细地介绍了。</p>
<p>而控制流，则是指程序执行指令的顺序。最简单地，我们的程序在除了顺序执行指令，还可以通过<code>if</code>语句进行条件跳转，通过<code>for</code>、<code>while</code>语句进行循环，还可以通过函数调用进入到别的函数。凡此种种，都是程序控制流的变化。</p>
<p>在使用LLVM作为编译器的时候，控制流往往就意味着更多的优化可能，如分支布局、函数内联。在使用LLVM作为静态分析工具的过程中，控制流也意味着更高的复杂度，如间接跳转、间接调用的识别和恢复。</p>
<p>因此，我们需要仔细了解LLVM中的控制流。</p>
<h2 id="汇编层面的控制语句"><a href="#汇编层面的控制语句" class="headerlink" title="汇编层面的控制语句"></a>汇编层面的控制语句</h2><p>在大多数语言中，常见的控制语句主要有四种：</p>
<ul>
<li><code>if</code> .. <code>else</code></li>
<li><code>for</code></li>
<li><code>while</code></li>
<li><code>switch</code></li>
</ul>
<p>在汇编语言层面，控制语句则被分解为两种核心的指令：条件跳转与无条件跳转（<code>switch</code>其实还有一些工作，之后会提到）。我们下面分别来看看在汇编层面是怎样实现控制语句的。</p>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if .. else"></a><code>if</code> .. <code>else</code></h3><p>我们有以下C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="comment">// Do something A</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Do something B</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Do something C</span></span><br></pre></td></tr></table></figure>

<p>为了将这个指令改写成汇编指令，我们同时需要条件跳转与无条件跳转。我们用伪代码表示其汇编指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Compare a and b</span><br><span class="line">    Jump to label B if comparison is a is not greater than b // conditional jump</span><br><span class="line">label A:</span><br><span class="line">    Do something A</span><br><span class="line">    Jump to label C // unconditional jump</span><br><span class="line">label B:</span><br><span class="line">    Do something B</span><br><span class="line">label C:</span><br><span class="line">    Do something C</span><br></pre></td></tr></table></figure>

<p>汇编语言通过条件跳转、无条件跳转和三个标签（<code>label A</code>标签实际上没有作用，只不过让代码更加清晰）实现了高级语言层面的<code>if</code> .. <code>else</code>语句。</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a><code>for</code></h3><p>我们有以下C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// Do something A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Do something B</span></span><br></pre></td></tr></table></figure>

<p>为了将这个指令改写为汇编指令，我们同样地需要条件跳转与无条件跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    int i = 0</span><br><span class="line">label start:</span><br><span class="line">    Compare i and 4</span><br><span class="line">    Jump to label B if comparison is i is not less than 4 // conditional jump</span><br><span class="line">label A:</span><br><span class="line">    Do something A</span><br><span class="line">    i++</span><br><span class="line">    Jump to label start // unconditional jump</span><br><span class="line">label B:</span><br><span class="line">    Do something B</span><br></pre></td></tr></table></figure>

<p>而<code>while</code>与<code>for</code>则极其类似，只不过少了初始化与自增的操作，这里不再赘述。</p>
<p>根据我们在汇编语言中积累的经验，我们得出，要实现大多数高级语言的控制语句，我们需要四个东西：</p>
<ul>
<li>标签</li>
<li>无条件跳转</li>
<li>比较大小的指令</li>
<li>条件跳转</li>
</ul>
<h2 id="LLVM-IR层面的控制语句"><a href="#LLVM-IR层面的控制语句" class="headerlink" title="LLVM IR层面的控制语句"></a>LLVM IR层面的控制语句</h2><p>下面就以我们上面的<code>for</code>循环的C语言版本为例，解释如何写其对应的LLVM IR语句。</p>
<p>首先，我们对应的LLVM IR的基本框架为</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                       <span class="comment">; int i = ...</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                   <span class="comment">; ... = 0</span></span><br><span class="line"><span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line"><span class="comment">; Do something A</span></span><br><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>              <span class="comment">; ... = i + 1</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                  <span class="comment">; i = ...</span></span><br><span class="line"><span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<p>这个程序缺少了一些必要的步骤，而我们之后会将其慢慢补上。</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>在LLVM IR中，标签与汇编语言的标签一致，也是以<code>:</code>结尾作标记。我们依照之前写的汇编语言的伪代码，给这个程序加上标签：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                  <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>              <span class="comment">; ... = 0</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>         <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>             <span class="comment">; i = ...</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><p>LLVM IR提供的比较指令为<code>icmp</code>。其接受三个参数：比较方案以及两个比较参数。这样讲比较抽象，我们就来看一下一个最简单的比较指令的例子：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">uge</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="variable">%b</span></span><br></pre></td></tr></table></figure>

<p>这个例子转化为C++语言就是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> comparison_result = ((<span class="type">unsigned</span> <span class="type">int</span>)a &gt;= (<span class="type">unsigned</span> <span class="type">int</span>)b);</span><br></pre></td></tr></table></figure>

<p>这里，<code>uge</code>是比较方案，<code>%a</code>和<code>%b</code>就是用来比较的两个数，而<code>icmp</code>则返回一个<code>i1</code>类型的值，也就是C++中的<code>bool</code>值，用来表示结果是否为真。</p>
<p><code>icmp</code>支持的比较方案很广泛：</p>
<ul>
<li>首先，最简单的是<code>eq</code>与<code>ne</code>，分别代表相等或不相等。</li>
<li>然后，是无符号的比较<code>ugt</code>, <code>uge</code>, <code>ult</code>, <code>ule</code>，分别代表大于、大于等于、小于、小于等于。我们之前在数的表示中提到，LLVM IR中一个整型变量本身的符号是没有意义的，而是需要看在其参与的指令中被看作是什么符号。这里每个方案的<code>u</code>就代表以无符号的形式进行比较。</li>
<li>最后，是有符号的比较<code>sgt</code>, <code>sge</code>, <code>slt</code>, <code>sle</code>，分别是其无符号版本的有符号对应。</li>
</ul>
<p>我们来看加上比较指令之后，我们的例子就变成了：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                               <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                           <span class="comment">; ... = 0</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">    <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">slt</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">4</span> <span class="comment">; Test if i &lt; 4</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>                      <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                          <span class="comment">; i = ...</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<h3 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h3><p>在比较完之后，我们需要条件跳转。我们来看一下我们此刻的目的：若<code>%comparison_result</code>是<code>true</code>，那么跳转到<code>A</code>，否则跳转到<code>B</code>。</p>
<p>LLVM IR为我们提供的条件跳转指令是<code>br</code>，其接受三个参数，第一个参数是<code>i1</code>类型的值，用于作判断；第二和第三个参数分别是值为<code>true</code>和<code>false</code>时需要跳转到的标签。比方说，在我们的例子中，就应该是</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br></pre></td></tr></table></figure>

<p>我们把它加入我们的例子：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                               <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                           <span class="comment">; ... = 0</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">    <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">slt</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">4</span> <span class="comment">; Test if i &lt; 4</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>                      <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                          <span class="comment">; i = ...</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<h3 id="无条件跳转"><a href="#无条件跳转" class="headerlink" title="无条件跳转"></a>无条件跳转</h3><p>无条件跳转更好理解，直接跳转到某一标签处。在LLVM IR中，我们同样可以使用<code>br</code>进行条件跳转。如，如果要直接跳转到<code>start</code>标签处，则可以</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">br</span> label <span class="variable">%start</span></span><br></pre></td></tr></table></figure>

<p>我们也把这加入我们的例子：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                               <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                           <span class="comment">; ... = 0</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">    <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">slt</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">4</span> <span class="comment">; Test if i &lt; 4</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>                      <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                          <span class="comment">; i = ...</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%start</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<p>这样看上去就结束了，然而如果大家把这个代码交给<code>llc</code>的话，并不能编译通过，这是为什么呢？</p>
<h3 id="Basic-block"><a href="#Basic-block" class="headerlink" title="Basic block"></a>Basic block</h3><p>首先，我们来摘录一下LLVM IR的参考指南中<a href="http://llvm.org/docs/LangRef.html#functions">Functions</a>节的一段话：</p>
<blockquote>
<p>A function definition contains a list of basic blocks, forming the CFG (Control Flow Graph) for the function. Each basic block may optionally start with a label (giving the basic block a symbol table entry), contains a list of instructions, and ends with a terminator instruction (such as a branch or function return). If an explicit label name is not provided, a block is assigned an implicit numbered label, using the next value from the same counter as used for unnamed temporaries (see above).</p>
</blockquote>
<p>这段话的大意有几个：</p>
<ul>
<li>一个函数由许多基本块(Basic block)组成</li>
<li>每个基本块包含：<ul>
<li>开头的标签（可省略）</li>
<li>一系列指令</li>
<li>结尾是终结指令</li>
</ul>
</li>
<li>一个基本块没有标签时，会自动赋给它一个标签</li>
</ul>
<p>所谓终结指令，就是指改变执行顺序的指令，如跳转、返回等。</p>
<p>我们来看看我们之前写好的程序是不是符合这个规定。<code>start</code>开头的基本块，在一系列指令后，以</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br></pre></td></tr></table></figure>

<p>结尾，是一个终结指令。<code>A</code>开头的基本块，在一系列指令后，以</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">br</span> label <span class="variable">%start</span></span><br></pre></td></tr></table></figure>

<p>结尾，也是一个终结指令。<code>B</code>开头的基本块，在最后总归是需要函数返回的（这里为了篇幅省略了），所以也一定会带有一个终结指令。</p>
<p>看上去都很符合呀，那为什么编译不通过呢？我们来仔细想一下，我们考虑了所有基本块了吗？要注意到，一个基本块是可以没有名字的，所以，实际上还有一个基本块没有考虑到，就是函数开头的：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>          <span class="comment">; int i = ...</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>      <span class="comment">; ... = 0</span></span><br></pre></td></tr></table></figure>

<p>这个基本块。它并没有以终结指令结尾！</p>
<p>所以，我们把一个终结指令补充在这个基本块的结尾：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                               <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                           <span class="comment">; ... = 0</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%start</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">    <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">slt</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">4</span> <span class="comment">; Test if i &lt; 4</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>                      <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                          <span class="comment">; i = ...</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%start</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<p>这样就完成了我们的例子。</p>
<p>LLVM的工具链甚至为我们提供了可视化控制语句的方法。我们使用之前提到的LLVM工具链中用于优化的<code>opt</code>工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">opt -p dot-cfg for.ll</span><br></pre></td></tr></table></figure>

<p>然后会生成一个<code>.main.dot</code>的文件。如果我们在计算机上装有<a href="http://www.graphviz.org/">Graphviz</a>，那么就可以用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dot .main.dot -Tpng -o for.png</span><br></pre></td></tr></table></figure>

<p>生成其可视化的控制流图（CFG）：</p>
<p><img src="/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/cfg.jpg"></p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a><code>switch</code></h3><p>下面我们来讲讲<code>switch</code>语句。我们有以下C语言程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// do something A</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// do something B</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// do something C</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do something else</span></span><br></pre></td></tr></table></figure>

<p>我们先直接来看其转换成LLVM IR是什么样子的：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="type">i32</span> <span class="variable">%x</span><span class="punctuation">,</span> label <span class="variable">%C</span> [</span><br><span class="line">    <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> label <span class="variable">%A</span></span><br><span class="line">    <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br><span class="line">]</span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line">C:</span><br><span class="line">    <span class="comment">; Do something C</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">    <span class="comment">; Do something else</span></span><br></pre></td></tr></table></figure>

<p>其核心就是第一行的<code>switch</code>指令。其第一个参数<code>i32 %x</code>是用来判断的，也就是我们C语言中的<code>x</code>。第二个参数<code>label %C</code>是C语言中的<code>default</code>分支，这是必须要有的参数。也就是说，我们的<code>switch</code>必须要有<code>default</code>来处理。接下来是一个数组，其意义已经很显然了，如果<code>%x</code>值是<code>0</code>，就去<code>label %A</code>，如果值是<code>1</code>，就去<code>label %B</code>。</p>
<p>LLVM后端对<code>switch</code>语句具体到汇编层面的实现则通常有两种方案：用一系列条件语句或跳转表。</p>
<p>一系列条件语句的实现方式最简单，用伪代码来表示的话就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (x == 0) &#123;</span><br><span class="line">    Jump to label %A</span><br><span class="line">&#125; else if (x == 1) &#123;</span><br><span class="line">    Jump to label %B</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Jump to label %C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是十分符合常理的。然而，我们需要注意到，如果这个<code>switch</code>语句一共有n个分支，那么其查找效率实际上是O(n)。那么，这种实现方案下的<code>switch</code>语句仅仅是<code>if</code> .. <code>else</code>的语法糖，除了增加可维护性，并不会优化什么性能。</p>
<p>跳转表则是一个可以优化性能的<code>switch</code>语句实现方案，其伪代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">labels = [label %A, label %B]</span><br><span class="line">if (x &lt; 0 || x &gt; 1) &#123;</span><br><span class="line">    Jump to label %C</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Jump to labels[x]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这只是一个极其粗糙的近似的实现，我们需要的是理解其基本思想。<strong>跳转表的思想就是利用内存中数组的索引是O(1)复杂度的</strong>，所以我们可以根据目前的<code>x</code>值去查找应该跳转到哪一个地址，这就是跳转表的基本思想。</p>
<p>根据目标平台和<code>switch</code>语句的分支数，LLVM后端会自动选择不同的实现方式去实现<code>switch</code>语句。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a><code>select</code></h3><p>我们经常会遇到一种情况，某一变量的值需要根据条件进行赋值，比如说以下C语言的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        y = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Do something with y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>x</code>大于<code>0</code>，则<code>y</code>为<code>1</code>，否则<code>y</code>为<code>2</code>。这一情况很常见，然而在C语言中，如果要实现这种功能，<code>y</code>需要被实现为可变变量，但实际上无论<code>x</code>如何取值，<code>y</code>只会被赋值一次，并不应该是可变的。</p>
<p>我们知道，LLVM IR中，由于SSA的限制，局部可变变量都必须分配在栈上，虽然LLVM后端最终会进行一定的优化，但写起代码来还需要冗长的<code>alloca</code>, <code>load</code>, <code>store</code>等语句。如果我们按照C语言的思路来写LLVM IR，那么就会是：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%x</span>) &#123;</span><br><span class="line">    <span class="variable">%y</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">sgt</span> <span class="type">i32</span> <span class="variable">%x</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%1</span><span class="punctuation">,</span> label <span class="variable">%btrue</span><span class="punctuation">,</span> label <span class="variable">%bfalse</span></span><br><span class="line"><span class="symbol">btrue:</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> ptr <span class="variable">%y</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">bfalse:</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> ptr <span class="variable">%y</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">    <span class="comment">; do something with %y</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看其编译出的汇编语言是怎样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo:</span><br><span class="line"># %bb.0:</span><br><span class="line">	cmpl	$0, %edi</span><br><span class="line">	jle	.LBB0_2</span><br><span class="line"># %bb.1:                                # %btrue</span><br><span class="line">	movl	$1, -4(%rsp)</span><br><span class="line">	jmp	.LBB0_3</span><br><span class="line">.LBB0_2:                                # %bfalse</span><br><span class="line">	movl	$2, -4(%rsp)</span><br><span class="line">.LBB0_3:                                # %end</span><br><span class="line">	retq</span><br></pre></td></tr></table></figure>

<p>算上注释，C语言代码9行，汇编语言代码11行，LLVM IR代码14行。这LLVM IR同时比低层次和高层次的代码都长，而且这种模式在真实的代码中出现的次数会非常多，这显然是不可以接受的。究其原因，就是这里把<code>y</code>看成了可变变量。那么，有没有什么办法让<code>y</code>不可变但仍然能实现这个功能呢？</p>
<p>首先，我们来看看同样区分可变变量与不可变变量的Rust是怎么做的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fn foo(x: i32) &#123;</span><br><span class="line">    let y = if x &gt; 0 &#123; 1 &#125; else &#123; 2 &#125;;</span><br><span class="line">    // Do something with y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让代码简短的方式很简单，把<code>y</code>看作不可变变量，但同时需要语言支持把<code>if</code>语句视作表达式，当<code>x</code>大于<code>0</code>时，这个表达式返回<code>1</code>，否则返回<code>2</code>。这样，就很简单地实现了我们的需求。</p>
<p>LLVM IR中同样也有这样的指令，那就是<code>select</code>，我们来把上面的例子用<code>select</code>改写：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%x</span>) &#123;</span><br><span class="line">    <span class="variable">%result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">sgt</span> <span class="type">i32</span> <span class="variable">%x</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">    <span class="variable">%y</span> <span class="operator">=</span> <span class="keyword">select</span> <span class="type">i1</span> <span class="variable">%result</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span></span><br><span class="line">    <span class="comment">; Do something with %y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>select</code>指令接受三个参数。第一个参数是用来判断的布尔值，也就是<code>i1</code>类型的<code>icmp</code>判断的结果，如果其为<code>true</code>，则返回第二个参数，否则返回第三个参数。极其合理。</p>
<p><code>select</code>不仅可以简化LLVM代码，也可以优化生成的二进制程序。在大部分情况下，在AMD64架构中，LLVM会将<code>select</code>指令编译为<a href="https://www.felixcloutier.com/x86/cmovcc"><code>CMOV</code>cc</a>指令，也就是条件赋值，从而优化了生成的二进制代码。</p>
<h3 id="phi"><a href="#phi" class="headerlink" title="phi"></a><code>phi</code></h3><p><code>select</code>只能支持两个选择，<code>true</code>选择一个分支，<code>false</code>选择另一个分支，我们是不是可以有支持多种选择的类似<code>switch</code>的版本呢？同时，我们也可以换个角度思考，<code>select</code>是根据<code>i1</code>的值来进行判断，我们其实可以根据控制流进行判断。这就是在SSA技术中大名鼎鼎的<code>phi</code>指令。</p>
<p>为了方便起见，我们首先先来看用<code>phi</code>指令实现的我们上面这个代码：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%x</span>) &#123;</span><br><span class="line">    <span class="variable">%result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">sgt</span> <span class="type">i32</span> <span class="variable">%x</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%result</span><span class="punctuation">,</span> label <span class="variable">%btrue</span><span class="punctuation">,</span> label <span class="variable">%bfalse</span></span><br><span class="line"><span class="symbol">btrue:</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">bfalse:</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">    <span class="variable">%y</span> <span class="operator">=</span> <span class="keyword">phi</span> <span class="type">i32</span> [<span class="number">1</span><span class="punctuation">,</span> <span class="variable">%btrue</span>]<span class="punctuation">,</span> [<span class="number">2</span><span class="punctuation">,</span> <span class="variable">%bfalse</span>]</span><br><span class="line">    <span class="comment">; Do something with %y</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，<code>phi</code>的第一个参数是一个类型，这个类型表示其返回类型为<code>i32</code>。接下来则是两个数组，其表示，如果当前的basic block执行的时候，前一个basic block是<code>%btrue</code>，那么返回<code>1</code>，如果前一个basic block是<code>%bfalse</code>，那么返回<code>2</code>。</p>
<p>也就是说，<code>select</code>是根据其第一个参数<code>i1</code>类型的变量的值来决定返回哪个值，而<code>phi</code>则是根据其之前是哪个basic block来决定其返回值。此外，<code>phi</code>之后可以跟无数的分支，如<code>phi i32 [1, %a], [2, %b], [3, %c]</code>等，从而可以支持多分支的赋值。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在汇编层面，一个函数与一个控制语句极其相似，都是由标签组成，只不过在跳转时增加了一些附加的操作。而在LLVM IR层面，函数则得到了更高一层的抽象。</p>
<h2 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>在LLVM中，一个最基本的函数定义的样子我们之前已经遇到过多次，就是<code>@main</code>函数的样子：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数名之后可以加上参数列表，如：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="variable">%b</span>) &#123;</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个函数定义最基本的框架，就是返回值（<code>i32</code>）+函数名（<code>@foo</code>）+参数列表（<code>(i32 %a, i64 %b）</code>）+函数体（<code>&#123; ret i32 0 &#125;</code>）。</p>
<p>我们可以看到，函数的名称和全局变量一样，都是以<code>@</code>开头的。并且，如果我们查看符号表的话，也会发现其和全局变量一样进入了符号表。因此，函数也有和全局变量完全一致的Linkage Types和Visibility Style，来控制函数名在符号表中的出现情况，因此，可以出现如</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="keyword">private</span> <span class="type">i32</span> <span class="title">@foo</span>() &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的修饰符。</p>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>此外，我们还可以在参数列表之后加上属性，也就是控制优化器和代码生成器的指令。如果我们单纯编译一个简单的C代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>其编译出的LLVM IR实际上是</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@foo</span>() <span class="variable">#0</span> &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; <span class="keyword">noinline</span> <span class="keyword">nounwind</span> <span class="keyword">optnone</span> <span class="keyword">uwtable</span> <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span><span class="operator">=</span><span class="string">&quot;0&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span><span class="operator">=</span><span class="string">&quot;true&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span><span class="operator">=</span><span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span><span class="operator">=</span><span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;tune-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;generic&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>#0</code>就是一个属性组，其包含了<code>noinline</code>、<code>nounwind</code>等若干个函数的属性。这些属性可以控制LLVM在优化和生成函数时的行为。大部分的属性可以在<a href="http://llvm.org/docs/LangRef.html#function-attributes">Function Attributes</a>一节看到。</p>
<p>当函数的属性比较少时，我们可以直接把属性写在函数定义后面，而不用以属性组的形式来写。例如下面这两种写法都是对的：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>() <span class="keyword">nounwind</span> &#123; <span class="keyword">ret</span> void &#125;</span><br><span class="line"><span class="comment">; or</span></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>() <span class="variable">#0</span> &#123; <span class="keyword">ret</span> void &#125;</span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> &#123;</span><br><span class="line">    <span class="keyword">nounwind</span> <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，无论是在代码编译还是在程序分析的过程中，我们最常处理的都在函数级别。因此，属性在这一过程中就是一个非常关键的概念。我们在编译器前端分析的过程中，遇到了特定的函数，给它加上相应的属性；在编译器后端生成代码时，则判断当前函数是否有相应的属性，从而可以在编译器前后端之间传递信息。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>除了函数定义之外，还有一种情况十分常见，那就是函数声明。<strong>我们在一个编译单元（模块）下，可以使用别的模块的函数，这时候就需要在本模块先声明这个函数，才能保证编译时不出错，从而在链接时正确将声明的函数与别的模块下其定义进行链接。</strong></p>
<p>函数声明也相对比较简单，就是使用<code>declare</code>关键词替换<code>define</code>：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="type">i32</span> <span class="title">@printf</span>(<span class="type">i8</span>*<span class="punctuation">,</span> ...) <span class="variable">#1</span></span><br></pre></td></tr></table></figure>

<p>这个就是在C代码中调用<code>stdio.h</code>库的<code>printf</code>函数时，在LLVM IR代码中可以看到的函数声明，其中<code>#1</code>就是又一大串属性组成的属性组。</p>
<h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>在LLVM IR中，函数的调用与高级语言几乎没有什么区别：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span>) &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@bar</span>() &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>call</code>指令可以像高级语言那样直接调用函数。我们来仔细分析一下这里做了哪几件事：</p>
<ul>
<li>传递参数</li>
<li>执行函数</li>
<li>获得返回值</li>
</ul>
<p>居然能干这么多事，这是汇编语言所羡慕不已的。</p>
<h3 id="执行函数"><a href="#执行函数" class="headerlink" title="执行函数"></a>执行函数</h3><p>我们知道，如果一个函数没有任何参数，返回值也是<code>void</code>类型，也就是说在C语言下这个函数是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么调用这个函数就没有了传递参数和获得返回值这两件事，只剩下执行函数，而这是一个最简单的事，以AMD64架构为例：</p>
<ol>
<li>把函数返回地址压栈</li>
<li>跳转到相应函数的地址</li>
</ol>
<p>函数返回也是一个最简单的事：</p>
<ol>
<li>弹栈获得函数返回地址</li>
<li>跳转到相应的返回地址</li>
</ol>
<p>这个在我们的汇编语言基础中已经反复遇到过多次，相信大家都会十分熟练。</p>
<h3 id="传递参数与获得返回值"><a href="#传递参数与获得返回值" class="headerlink" title="传递参数与获得返回值"></a>传递参数与获得返回值</h3><p>谈到这两点，就不得不说调用约定了。我们知道，在汇编语言中，是没有参数传递和返回值的概念的，有的仅仅是让当前的控制流跳转到指定函数执行。所以，一切的参数传递和返回值都需要我们人为约定。也就是说，我们需要约定两件事：</p>
<ul>
<li>被调用的函数希望知道参数是放在哪里的</li>
<li>调用者希望知道调用函数的返回值是放在哪里的</li>
</ul>
<p>这就是调用约定。不同的调用约定会产生不同的特效，也就产生了许多高级语言的feature。</p>
<h4 id="C调用约定"><a href="#C调用约定" class="headerlink" title="C调用约定"></a>C调用约定</h4><p>最广泛使用的调用约定是C调用约定，也就是各个操作系统的标准库使用的调用约定。在AMD64架构下，C调用约定是System V版本的，<strong>所有参数按顺序放入指定寄存器，如果寄存器不够，剩余的则从右往左顺序压栈。而返回值则是按先后顺序放入寄存器或者放入调用者分配的空间中，如果只有一个返回值，那么就会放在<code>rax</code>里。</strong></p>
<p>在LLVM IR中，函数的调用默认使用C调用约定。为了验证，我们可以写一个简单的程序：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; calling_convention_test.ll</span></span><br><span class="line"><span class="variable">%ReturnType</span> <span class="operator">=</span> <span class="keyword">type</span> &#123; <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span> &#125;</span><br><span class="line"><span class="keyword">define</span> <span class="variable">%ReturnType</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a3</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a4</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a5</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a6</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a7</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a8</span>) &#123;</span><br><span class="line">    <span class="keyword">ret</span> <span class="variable">%ReturnType</span> &#123; <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="variable">%ReturnType</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">3</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">4</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">5</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">6</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">7</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们查看其编译出来的汇编代码。在<code>main</code>函数中，参数传递是：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">movl    <span class="number">$1</span>, %edi</span><br><span class="line">movl    <span class="number">$2</span>, %esi</span><br><span class="line">movl    <span class="number">$3</span>, %edx</span><br><span class="line">movl    <span class="number">$4</span>, %ecx</span><br><span class="line">movl    <span class="number">$5</span>, %r8d</span><br><span class="line">movl    <span class="number">$6</span>, %r9d</span><br><span class="line">movl    <span class="number">$7</span>, (%rsp)</span><br><span class="line">movl    <span class="number">$8</span>, <span class="number">8</span>(%rsp)</span><br><span class="line">callq   foo@PLT</span><br></pre></td></tr></table></figure>

<p>而在<code>foo</code>函数内部，返回值传递是：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">movl    <span class="number">$1</span>, %eax</span><br><span class="line">movl    <span class="number">$2</span>, %edx</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>

<p>如果大家去查阅System V的指南的话，会发现完全符合。</p>
<p>这种System V的调用约定有什么好处呢？其最大的特点在于，当寄存器数量不够时，剩余的参数是按<strong>从右向左</strong>的顺序压栈。这就让基于这种调用约定的高级语言可以更轻松地实现可变参数的feature。所谓可变参数，最典型的例子就是C语言中的<code>printf</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, a, b, c, d);</span><br></pre></td></tr></table></figure>

<p><code>printf</code>可以接受任意数量的参数，其参数的数量是由第一个参数<code>&quot;%d %d %d %d&quot;</code>决定的。有多少个需要格式化的变量，接下来就还有多少个参数。</p>
<p>那么，System V的调用约定又是为什么能满足这样的需求呢？假设我们不考虑之前传入寄存器内的参数，只考虑压入栈内的参数。那么，如果是从右往左的顺序压栈，栈顶就是<code>&quot;%d %d %d %d&quot;</code>的地址，接着依次是<code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>。那么，我们的程序就可以先读栈顶，获得字符串，然后确定有多少个参数，接着就继续在栈上读多少个参数。相反，如果是从左往右顺序压栈，那么程序第一个读到的是<code>d</code>，程序也不知道该读多少个参数。</p>
<h4 id="fastcc"><a href="#fastcc" class="headerlink" title="fastcc"></a>fastcc</h4><p>各种语言的调用约定还有许多，可以参考语言指南的<a href="http://llvm.org/docs/LangRef.html#calling-conventions">Calling Conventions</a>一节。把所有的调用约定都讲一遍显然是不可能且枯燥的。所以，我在这里除了C调用约定之外，只再讲一个调用约定fastcc，以体现不同的调用约定能实现不同的高级语言的feature。</p>
<p>fastcc方案是将变量全都传入寄存器中的方案。这种方案使尾调用优化能更方便地实现。</p>
<p>尾调用会出现在很多场景下，用一个比较平凡的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> foo(a - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到，这个函数在返回时有可能会调用自身，这就叫尾调用。为什么尾调用需要优化呢？我们知道，在正常情况下，调用一个函数会产生函数的栈帧，也就是把函数的参数传入栈，把函数的返回地址传入栈。那么如果<code>a</code>很大，那么调用的函数会越来越多，并且直到最后一个被调用的函数返回之前，所有调用的函数的栈都不会回收，也就是说，我们此时栈上充斥着一层一层被调用函数返回的地址。</p>
<p>然而，由于这个函数是在调用者的返回语句里调用，我们实际上可以复用调用者的栈，这就是尾调用优化的基础思想。我们希望，把这样的尾调用变成循环，从而减少栈的使用。通过将参数都传入寄存器，我们可以避免再将参数传入栈，这就是fastcc为尾调用优化提供的帮助。然后，就可以直接将函数调用变成汇编中的<code>jmp</code>。</p>
<p>我们来看如果用fastcc调用约定，LLVM IR该怎么写：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; tail_call_test.ll</span></span><br><span class="line"><span class="keyword">define</span> <span class="keyword">fastcc</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span>) &#123;</span><br><span class="line">    <span class="variable">%res</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">eq</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%res</span><span class="punctuation">,</span> label <span class="variable">%btrue</span><span class="punctuation">,</span> label <span class="variable">%bfalse</span></span><br><span class="line"><span class="symbol">btrue:</span></span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">bfalse:</span></span><br><span class="line">    <span class="variable">%sub</span> <span class="operator">=</span> <span class="keyword">sub</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">    <span class="variable">%tail_call</span> <span class="operator">=</span> <span class="keyword">tail</span> <span class="keyword">call</span> <span class="keyword">fastcc</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%sub</span>)</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%tail_call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>llc</code>对其编译，并加上<code>-tailcallopt</code>的指令（实际上不加也没关系，LLVM后端会自动进行<a href="http://llvm.org/docs/CodeGenerator.html#sibling-call-optimization">Sibling call optimization</a>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">llc tail_call_test.ll -tailcallopt</span><br></pre></td></tr></table></figure>

<p>其编译而成的汇编代码中，其主体为：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    cmpl    <span class="number">$1</span>, %edi</span><br><span class="line">    <span class="keyword">jne</span>     .LBB0_2</span><br><span class="line">    movl    <span class="number">$1</span>, %eax</span><br><span class="line">    retq    <span class="number">$8</span></span><br><span class="line"><span class="symbol">.LBB0_2:</span></span><br><span class="line">    pushq   %rax</span><br><span class="line">    decl    %edi</span><br><span class="line">    popq    %rax</span><br><span class="line">    <span class="keyword">jmp</span>     foo@PLT</span><br></pre></td></tr></table></figure>

<p>我们可以发现，在结尾，使用的是<code>jmp</code>而不是<code>call</code>，所以从高级语言的角度，就可以看作其将尾部的调用变成了循环。并且，有两个操作：<code>pushq    %rax</code>和<code>popq    %rax</code>。这两个操作只是为了栈对齐，具体可以参考stack overflow上的回答<a href="https://stackoverflow.com/a/45823778/10005095">Why does this function push RAX to the stack as the first operation?</a>。</p>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>与控制语句的可视化类似，我们也可以通过LLVM工具链，获得LLVM IR的函数调用图（Call Graph）。</p>
<p>假设我们有以下LLVM IR:</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; cg.ll</span></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo1</span>() &#123;</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@foo4</span>(<span class="type">i32</span> <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@foo2</span>()</span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@foo3</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo4</span>(<span class="type">i32</span> <span class="variable">%0</span>) &#123;</span><br><span class="line">  <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">sgt</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%true_branch</span><span class="punctuation">,</span> label <span class="variable">%false_branch</span></span><br><span class="line"></span><br><span class="line">true_branch:</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@foo1</span>()</span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%final</span></span><br><span class="line"></span><br><span class="line">false_branch:</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@foo2</span>()</span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%final</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">final:</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@foo3</span>()</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>foo4</code>根据输入，调用<code>foo1</code>或者<code>foo2</code>，最终调用<code>foo3</code>。而<code>foo1</code>则递归调用<code>foo4</code>。</p>
<p>对于这样的LLVM IR，我们使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">opt -p dot-callgraph cg.ll</span><br></pre></td></tr></table></figure>

<p>可以生成一个<code>cg.ll.callgraph.dot</code>的文件。类似CFG，我们可以使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dot cg.ll -Tpng -o cg.png</span><br></pre></td></tr></table></figure>

<p>生成如下图所示的函数调用图：</p>
<p><img src="/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/callCFG.jpg" alt="Call Graph"></p>
<h2 id="内置函数、属性和元数据"><a href="#内置函数、属性和元数据" class="headerlink" title="内置函数、属性和元数据"></a>内置函数、属性和元数据</h2><p>在LLVM IR中，除了基础的数据表示、控制流之外，还有内置函数、属性和元数据等，能够影响二进制程序生成的功能。</p>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>我们回顾一下，LLVM IR的作用实际上是将编译器前端与后端解耦合。编程语言的前端开发者，负责将输入的编程语言代码进行解析，生成LLVM IR；指令集架构的后端开发者，负责将输入的LLVM IR生成为目标架构的二进制指令。因此，LLVM IR提供了若干非常基础的指令，如<code>add</code>、<code>br</code>、<code>call</code>等。这样做的好处在于：</p>
<ul>
<li>对前端开发者而言，这些指令语义足够全，使用方法也和常见高级语言类似。</li>
<li>对后端开发者而言，这些指令相对数目比较少，提供的功能也相对较为独立，在大部分常见的指令集中都有类似的指令与其对应。</li>
</ul>
<p>但是，这样的策略也有其弊端：</p>
<ul>
<li>对前端开发者而言，仍然有部分通用的语义无法被单个指令所涵盖</li>
<li>对后端开发者而言，对一些通用指令的优化无法针对LLVM IR指令来做</li>
</ul>
<h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a><code>memcpy</code></h3><p>以内存拷贝为例。熟悉AMD64或者AArch64的开发者一定知道，在这些支持向量操作的指令集架构中，大规模的内存拷贝往往是通过向量指令来实现的，Glibc中的<code>memcpy</code>就是这样实现的。</p>
<p>但是对于通用编程语言来说，标准库往往不喜欢直接调用libc中的函数，会产生一些不必要的依赖。并且，<code>memcpy</code>用向量操作来实现已经是一个非常通用的方案了，所以能不能复用一些逻辑呢？</p>
<p>对于此类，LLVM IR指令过于基础，但是却非常广泛地使用同一套实现逻辑的情况，LLVM IR提供了「<a href="https://llvm.org/docs/LangRef.html#intrinsic-functions">内置函数</a>」（Intrinsic Functions）功能来解决。</p>
<p>所谓内置函数，我们可以理解成一些可以像普通的LLVM IR函数一样调用的函数，但这些函数不需要开发者自己实现，LLVM的后端开发者提供了这些函数的实现。</p>
<p>例如，LLVM IR提供了<a href="https://llvm.org/docs/LangRef.html#llvm-memcpy-intrinsic"><code>llvm.memcpy</code></a>内置函数，以提供内存的拷贝操作。前端开发者只需要调用这个函数，就可以实现内存拷贝功能了。</p>
<p>我们熟知的Rust语言，在利用LLVM生成二进制程序时，就是使用的这个函数，可以参考其封装的<a href="https://github.com/rust-lang/rust/blob/90c541806f23a127002de5b4038be731ba1458ca/compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp#L1448-L1456"><code>LLVMRustBuildMemCpy</code></a>与调用者<a href="https://github.com/rust-lang/rust/blob/90c541806f23a127002de5b4038be731ba1458ca/compiler/rustc_codegen_llvm/src/builder.rs#L871-L896"><code>memcpy</code></a>。</p>
<h3 id="静态分支预测"><a href="#静态分支预测" class="headerlink" title="静态分支预测"></a>静态分支预测</h3><p>LLVM IR提供的内置函数有许多，这里，我们再以静态分支预测为例，介绍一个常见内置函数。</p>
<p>我们在阅读一些大规模项目源码时，例如Linux内核源码、QEMU源码等，往往会注意到大量使用的<code>likely</code>与<code>unlikely</code>，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (likely(x &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>likely</code>是什么？它是干什么用的？事实上，<code>likely</code>与<code>unlikely</code>往往是通过宏定义实现的，它们的作用是静态分支预测。</p>
<p>我们知道，对于C语言等常见的编程语言的<code>if</code>语句，在生成二进制程序的时候，我们可以交换它的两个分支的位置。紧接着<code>cmp</code>等判断语句的分支，在执行时，不会发生跳转，而另一个分支则需要设置PC寄存器来跳转。这种跳转往往会造成一定程度的性能损耗，这些具体的我在「<a href="https://github.com/Evian-Zhang/learn-assembly-on-Apple-Silicon-Mac">在 Apple Silicon Mac 上入门汇编语言</a>」中的<a href="https://evian-zhang.github.io/learn-assembly-on-Apple-Silicon-Mac/11-%E8%B7%B3%E8%BD%AC.html#%E7%BC%96%E8%AF%91%E6%9C%9F%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B">编译期分支预测</a>一节中有详细阐述。总之，我们需要给编译器一些信息，来排布不同的分支布局。</p>
<p>对于Clang来说，这是通过<a href="https://llvm.org/docs/BranchWeightMetadata.html#built-in-expect-instructions">内置<code>expect</code>指令</a>来实现的，也就是说：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x)       __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x)     __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure>

<p>而<code>__builtin_expect</code>这个内置指令，就会翻译为LLVM IR中的<a href="https://llvm.org/docs/LangRef.html#llvm-expect-intrinsic"><code>llvm.expect</code></a>内置函数，从而实现了静态分支预测。</p>
<h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><p>在C语言中，我们会遇到一个函数的修饰符：<code>inline</code>。这个修饰符会提示编译器，建议编译器在遇到这个函数的调用时，内联这个函数。这类的信息，LLVM会将其看作函数的「<a href="https://llvm.org/docs/LangRef.html#function-attributes">属性</a>」（Attribtues）。</p>
<p>在之前，我们也提到过，我们可以：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>() attr<span class="number">1</span> attr<span class="number">2</span> attr<span class="number">3</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个函数有相同的属性，我们可以用一个属性组的形式来复用：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo1</span>() <span class="variable">#0</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo2</span>() <span class="variable">#0</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; attr<span class="number">1</span> attr<span class="number">2</span> attr<span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<p>LLVM支持的函数属性有多种，我们来看看几个比较容易理解的，由函数属性控制的优化：</p>
<h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><p>函数内联是一个非常复杂的概念，这里我们只是简单地来看一下，下面这个C语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a)</span> __<span class="title function_">attribute__</span><span class="params">((always_inline))</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里声明了<code>foo</code>函数，并且用了一个扩展语法<code>__attribute__((always_inline))</code>，这个语法实际上的作用就是给函数加上<code>alwaysinline</code>的属性。</p>
<p>我们查看其生成的LLVM IR：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> dso_local <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> noundef <span class="variable">%0</span>) <span class="variable">#0</span> &#123;</span><br><span class="line">  <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; <span class="keyword">alwaysinline</span> <span class="keyword">nounwind</span> <span class="keyword">uwtable</span> <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span><span class="operator">=</span><span class="string">&quot;0&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span><span class="operator">=</span><span class="string">&quot;true&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span><span class="operator">=</span><span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span><span class="operator">=</span><span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;tune-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;generic&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，其确实有了<code>alwaysinline</code>这个属性。</p>
<h3 id="帧指针清除优化"><a href="#帧指针清除优化" class="headerlink" title="帧指针清除优化"></a>帧指针清除优化</h3><p>我们再来看一个属性控制的优化：帧指针清除优化（Frame Pointer Elimination）。</p>
<p>在讲这个之前，先讲一个比较小的优化。我们将一个非常简单的C程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译为汇编程序，可以发现，<code>foo</code>函数的汇编代码为：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    pushq   %rbp</span><br><span class="line">    <span class="keyword">movq</span>    %rsp, %rbp</span><br><span class="line">    movl    %edi, -<span class="number">4</span>(%rbp)</span><br><span class="line">    movl    %esi, -<span class="number">8</span>(%rbp)</span><br><span class="line">    popq    %rbp</span><br></pre></td></tr></table></figure>

<p>与我们常识有些违背。为啥这里栈不先增加（也就是对<code>rsp</code>寄存器进行<code>sub</code>），就直接把<code>edi</code>, <code>esi</code>的值移入栈内了呢？<code>-4(%rbp)</code>和<code>-8(%rbp)</code>的内存空间此刻似乎并不属于栈。</p>
<p>这是因为，在System V关于amd64架构的标准中，规定了<code>rsp</code>以下128个字节为red zone。这个区域，信号和异常处理函数均不会使用。因此，一个函数可以放心使用<code>rsp</code>以下128个字节的内容。</p>
<p>同时，我们对栈指针进行操作，一个很重要的原因就是为了进一步函数调用的时候，使用<code>call</code>指令会自动将被调用函数的返回地址压栈，那么就需要在调用<code>call</code>指令之前，保证栈顶指针确实指向栈顶，否则压栈就会覆盖一些数据。</p>
<p>但此时，我们的<code>foo</code>函数并没有调用别的函数，也就不会产生压栈行为。因此，如果在栈帧不超过128个字节的情况下，编译器自动为我们省去了这样的操作。为了验证这一点，我们做一个小的修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; bar(); &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，我们再看编译出的<code>foo</code>函数的汇编代码：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    pushq   %rbp</span><br><span class="line">    <span class="keyword">movq</span>    %rsp, %rbp</span><br><span class="line">    subq    <span class="number">$16</span>, %rsp</span><br><span class="line">    movl    %edi, -<span class="number">4</span>(%rbp)</span><br><span class="line">    movl    %esi, -<span class="number">8</span>(%rbp)</span><br><span class="line">    callq   bar</span><br><span class="line">    addq    <span class="number">$16</span>, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>

<p>确实增加了对<code>rbp</code>的<code>sub</code>和<code>add</code>操作。而此时的<code>bar</code>函数，也没有对<code>rsp</code>的操作。</p>
<p>接下来，就要讲帧指针清除优化了。经过我们上述的讨论，一个函数在进入时会有一些固定动作：</p>
<ol>
<li>把<code>rbp</code>压栈</li>
<li>把<code>rsp</code>放入<code>rbp</code></li>
<li>减<code>rsp</code>，预留栈空间</li>
</ol>
<p>在函数返回之前，也有其相应的操作：</p>
<ol>
<li>加<code>rsp</code>，回收栈空间</li>
<li>把<code>rbp</code>最初的值弹栈回到<code>rbp</code></li>
</ol>
<p>我们刚刚讲的优化，使得没有调用别的函数的函数，可以省略掉进入时的第3步和返回前的第1步。那么，是否还可以继续省略呢？</p>
<p>那么，我们就要考虑为什么需要这些步骤。这些步骤都是围绕<code>rbp</code>进行的，而正是因为<code>rbp</code>经常进行这种操作，所以我们把<code>rbp</code>称为帧指针。之所以要进行这些操作，是因为我们在函数执行的过程中，栈顶指针随着不断调用别的函数，会不断移动，导致我们根据栈顶指针的位置，不太方便确定局部变量的位置。而如果我们在一开始就把<code>rsp</code>的值放在<code>rbp</code>中，那么局部变量的位置相对<code>rbp</code>是固定的，就更好确认了。注意到我们这里说根据<code>rsp</code>的值确认局部变量的位置只是不方便，但并不是不能做到。所以，我们可以增加一些编译器的负担，而把帧指针清除。</p>
<p>帧指针清除在LLVM IR层面其实十分方便，就是什么都不写。我们可以观察</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%b</span>) &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> ptr <span class="variable">%1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%b</span><span class="punctuation">,</span> ptr <span class="variable">%2</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数在编译成汇编语言之后，是：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    movl    %edi, -<span class="number">4</span>(%rsp)</span><br><span class="line">    movl    %esi, -<span class="number">8</span>(%rsp)</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>

<p>不仅没有了栈的增加减少（之前提过的优化），也没有了对<code>rbp</code>的操作（帧指针清除）。</p>
<p>要想恢复这一操作也十分简单，在函数参数列表后加上一个属性<code>&quot;frame-pointer&quot;=&quot;all&quot;</code>：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%b</span>) <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> ptr <span class="variable">%1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%b</span><span class="punctuation">,</span> ptr <span class="variable">%2</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其编译后的汇编程序就是：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    pushq   %rbp</span><br><span class="line">    <span class="keyword">movq</span>    %rsp, %rbp</span><br><span class="line">    movl    %edi, -<span class="number">4</span>(%rbp)</span><br><span class="line">    movl    %esi, -<span class="number">8</span>(%rbp)</span><br><span class="line">    popq    %rbp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>

<p>恢复了往日的雄风。</p>
<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>函数的属性可以在前后端之间传递函数的信息，例如，前端发现某个函数需要后端的特殊处理，就给这个函数加一个自定义的属性。而在LLVM的整个管线中的任意一个位置，我们往往都能读到这个属性，从而可以依据是否有这个属性来做特殊的处理&#x2F;优化。正因如此，之所以函数要有属性，是因为函数是LLVM的优化过程中一个非常重要的基础单元，因此需要保留各种信息。</p>
<p>除此之外，我们有时也会希望每一条指令，或者每一个翻译单元，都可以有类似属性一样的信息，可以在管线中传递&#x2F;过滤，从而能获得一些信息。这在LLVM IR中被称为「<a href="https://llvm.org/docs/LangRef.html#metadata">元数据</a>」（Metadata）。</p>
<h3 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h3><p>说了这么多，元数据具体有什么用处呢？元数据的语法又是怎样的呢？我们来看一个具体的例子。</p>
<p>我们知道，在Clang中，传入<code>-g</code>选项可以生成调试信息。那么，调试信息是怎么在LLVM IR中体现的呢？</p>
<p>我们这样一个<code>debug.c</code>文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang debug.c -g -S -emit-llvm</span><br></pre></td></tr></table></figure>

<p>生成LLVM IR文件，其一部分如下：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local <span class="type">i32</span> <span class="title">@sum</span>(<span class="type">i32</span> noundef <span class="variable">%0</span><span class="punctuation">,</span> <span class="type">i32</span> noundef <span class="variable">%1</span>) <span class="variable">#0</span> <span class="title">!dbg</span> <span class="title">!10</span> &#123;</span><br><span class="line">  <span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="variable">%4</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> ptr <span class="variable">%3</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.dbg.declare</span>(metadata ptr <span class="variable">%3</span><span class="punctuation">,</span> metadata <span class="title">!15</span><span class="punctuation">,</span> metadata <span class="title">!DIExpression</span>())<span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!16</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%4</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.dbg.declare</span>(metadata ptr <span class="variable">%4</span><span class="punctuation">,</span> metadata <span class="title">!17</span><span class="punctuation">,</span> metadata <span class="title">!DIExpression</span>())<span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!18</span></span><br><span class="line">  <span class="variable">%5</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%3</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span><span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!19</span></span><br><span class="line">  <span class="variable">%6</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%4</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span><span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!20</span></span><br><span class="line">  <span class="variable">%7</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="keyword">nsw</span> <span class="type">i32</span> <span class="variable">%5</span><span class="punctuation">,</span> <span class="variable">%6</span><span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!21</span></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%7</span><span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"></span><br><span class="line"><span class="title">!llvm.dbg.cu</span> <span class="operator">=</span> !&#123;<span class="title">!0</span>&#125;</span><br><span class="line"><span class="title">!llvm.module.flags</span> <span class="operator">=</span> !&#123;<span class="title">!2</span><span class="punctuation">,</span> <span class="title">!3</span><span class="punctuation">,</span> <span class="title">!4</span><span class="punctuation">,</span> <span class="title">!5</span><span class="punctuation">,</span> <span class="title">!6</span><span class="punctuation">,</span> <span class="title">!7</span><span class="punctuation">,</span> <span class="title">!8</span>&#125;</span><br><span class="line"><span class="title">!llvm.ident</span> <span class="operator">=</span> !&#123;<span class="title">!9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!0</span> <span class="operator">=</span> distinct <span class="title">!DICompileUnit</span>(language: DW_LANG_C<span class="number">11</span><span class="punctuation">,</span> file: <span class="title">!1</span><span class="punctuation">,</span> producer: <span class="string">&quot;Homebrew clang version 16.0.6&quot;</span><span class="punctuation">,</span> isOptimized: <span class="keyword">false</span><span class="punctuation">,</span> runtimeVersion: <span class="number">0</span><span class="punctuation">,</span> emissionKind: FullDebug<span class="punctuation">,</span> splitDebugInlining: <span class="keyword">false</span><span class="punctuation">,</span> nameTableKind: None)</span><br><span class="line"><span class="title">!1</span> <span class="operator">=</span> <span class="title">!DIFile</span>(filename: <span class="string">&quot;debug.c&quot;</span><span class="punctuation">,</span> directory: <span class="string">&quot;...&quot;</span><span class="punctuation">,</span> checksumkind: CSK_MD<span class="number">5</span><span class="punctuation">,</span> checksum: <span class="string">&quot;...&quot;</span>)</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="title">!10</span> <span class="operator">=</span> distinct <span class="title">!DISubprogram</span>(name: <span class="string">&quot;sum&quot;</span><span class="punctuation">,</span> scope: <span class="title">!1</span><span class="punctuation">,</span> file: <span class="title">!1</span><span class="punctuation">,</span> line: <span class="number">1</span><span class="punctuation">,</span> <span class="keyword">type</span>: <span class="title">!11</span><span class="punctuation">,</span> scopeLine: <span class="number">1</span><span class="punctuation">,</span> flags: DIFlagPrototyped<span class="punctuation">,</span> spFlags: DISPFlagDefinition<span class="punctuation">,</span> unit: <span class="title">!0</span><span class="punctuation">,</span> retainedNodes: <span class="title">!14</span>)</span><br><span class="line"><span class="title">!11</span> <span class="operator">=</span> <span class="title">!DISubroutineType</span>(types: <span class="title">!12</span>)</span><br><span class="line"><span class="title">!12</span> <span class="operator">=</span> !&#123;<span class="title">!13</span><span class="punctuation">,</span> <span class="title">!13</span><span class="punctuation">,</span> <span class="title">!13</span>&#125;</span><br><span class="line"><span class="title">!13</span> <span class="operator">=</span> <span class="title">!DIBasicType</span>(name: <span class="string">&quot;int&quot;</span><span class="punctuation">,</span> size: <span class="number">32</span><span class="punctuation">,</span> encoding: DW_ATE_signed)</span><br><span class="line"><span class="title">!14</span> <span class="operator">=</span> !&#123;&#125;</span><br><span class="line"><span class="title">!15</span> <span class="operator">=</span> <span class="title">!DILocalVariable</span>(name: <span class="string">&quot;a&quot;</span><span class="punctuation">,</span> arg: <span class="number">1</span><span class="punctuation">,</span> scope: <span class="title">!10</span><span class="punctuation">,</span> file: <span class="title">!1</span><span class="punctuation">,</span> line: <span class="number">1</span><span class="punctuation">,</span> <span class="keyword">type</span>: <span class="title">!13</span>)</span><br><span class="line"><span class="title">!16</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">1</span><span class="punctuation">,</span> column: <span class="number">13</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!17</span> <span class="operator">=</span> <span class="title">!DILocalVariable</span>(name: <span class="string">&quot;b&quot;</span><span class="punctuation">,</span> arg: <span class="number">2</span><span class="punctuation">,</span> scope: <span class="title">!10</span><span class="punctuation">,</span> file: <span class="title">!1</span><span class="punctuation">,</span> line: <span class="number">1</span><span class="punctuation">,</span> <span class="keyword">type</span>: <span class="title">!13</span>)</span><br><span class="line"><span class="title">!18</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">1</span><span class="punctuation">,</span> column: <span class="number">20</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!19</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">2</span><span class="punctuation">,</span> column: <span class="number">12</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!20</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">2</span><span class="punctuation">,</span> column: <span class="number">16</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!21</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">2</span><span class="punctuation">,</span> column: <span class="number">14</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!22</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">2</span><span class="punctuation">,</span> column: <span class="number">5</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在生成的LLVM IR中，出现了大量以<code>!</code>开头的符号，这就是元数据的语法。</p>
<p>具体而言，我们看到其中的</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">!12</span> <span class="operator">=</span> !&#123;<span class="title">!13</span><span class="punctuation">,</span> <span class="title">!13</span><span class="punctuation">,</span> <span class="title">!13</span>&#125;</span><br><span class="line"><span class="title">!13</span> <span class="operator">=</span> <span class="title">!DIBasicType</span>(name: <span class="string">&quot;int&quot;</span><span class="punctuation">,</span> size: <span class="number">32</span><span class="punctuation">,</span> encoding: DW_ATE_signed)</span><br></pre></td></tr></table></figure>

<p>这里，<code>!13 = ...</code>生成了一个元数据，其内容为一个给定的结构体<code>DIBasicType</code>，而<code>!12</code>这个元数据的内容，则并不是一个给定的结构体，而是由三个<code>!13</code>这个元数据组成的结构。也就是说，元数据的组织相对比较灵活。</p>
<p>在<code>sum</code>函数体中，我们可以看到，几乎每条指令后都附加了一个元数据，在代码下半部分找到对应的元数据，其实就是这行指令对应C语言中源代码里的位置，也就是调试信息中的location。</p>
<p>此外，我们还可以看到<code>llvm.dbg.declare</code>内置函数的调用。这个函数的作用是标记源代码中变量的地址。例如：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> ptr <span class="variable">%3</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">call</span> void <span class="title">@llvm.dbg.declare</span>(metadata ptr <span class="variable">%3</span><span class="punctuation">,</span> metadata <span class="title">!15</span><span class="punctuation">,</span> metadata <span class="title">!DIExpression</span>())<span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!16</span></span><br></pre></td></tr></table></figure>

<p>这里就是指，源代码中位于<code>!15</code>元数据处的变量，也就是<code>a</code>，其在生成的二进制程序中，位于<code>%3</code>变量。</p>
<p>LLVM中的调试信息非常全面且复杂，具体可以看官方文档<a href="https://llvm.org/docs/SourceLevelDebugging.html">Source Level Debugging with LLVM</a>。</p>
<h3 id="控制流完整性"><a href="#控制流完整性" class="headerlink" title="控制流完整性"></a>控制流完整性</h3><p>元数据的另一个用途，就在于控制流完整性保护。当一个攻击者攻击一个二进制程序的时候，最低级的攻击者只是让它崩溃，造成DoS攻击。高级的攻击者，往往想让这个程序执行自己想让它执行的命令。而这一途径，在现代攻击环境下，往往是通过函数指针覆盖来实现的。</p>
<p>举一个例子来说，在前几年，有一个非常著名的漏洞<a href="https://twitter.com/axi0mX/status/1177542201670168576?s=20">checkm8</a>。这个漏洞可以攻击苹果的大部分iPhone设备，并且由于代码处于ROM中，所以被认为无法修复。其具体的分析可以看<a href="https://habr.com/en/companies/dsec/articles/472762/">Technical analysis of the checkm8 exploit</a>和<a href="https://zhuanlan.zhihu.com/p/87456653">iPhone史诗级漏洞checkm8攻击原理浅析 - Gh0u1L5的文章 - 知乎</a>。我们这里只需要了解一点，它的核心是，Apple代码中有一个结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device_io_request</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *callback;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里<code>callback</code>是一个函数指针，在程序执行中会被调用。攻击者通过某种方法，强行覆盖了这个函数指针的值，从而让程序执行自己想要执行的函数。</p>
<p>为了抵御这种攻击，我们往往会采用控制流完整性（Control Flow Integrity, CFI）策略。最简单的思路是，我们在写程序时，函数指针所指向的函数，肯定是有限个确定的函数。那么，我们可以在执行函数指针所对应的间接调用时，检查调用目标是否是那有限个确定的函数，就可以保证不会出现之前的这种问题了。</p>
<p>但是，如何确定这个函数指针究竟能指向哪些函数呢？这个问题非常复杂，编译器往往是做不到这件事的。因此，现在一般会使用比较弱化的控制流完整性策略。在LLVM中，我们可以通过传递<code>-fsanitize=cfi-icall</code>来启用LLVM-CFI所提供的控制流完整性策略（需要同时通过<code>-flto</code>开启LTO），例如，我们有以下程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*f)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo1</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo2</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> a)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">baz</span><span class="params">(f func)</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将其保存为<code>cfi.c</code>，然后在命令行中使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang cfi.c -flto -fsanitize=cfi-icall -S -emit-llvm</span><br></pre></td></tr></table></figure>

<p>可以生成一个开启了LLVM-CFI策略的LLVM IR代码。</p>
<p>那么，LLVM-CFI策略是什么呢？由于其相对比较复杂，具体可以参考<a href="https://clang.llvm.org/docs/ControlFlowIntegrityDesign.html">Control Flow Integrity Design Documentation</a>，我们这里只是非常粗略地讲。</p>
<p>在上述代码中，<code>baz</code>函数接收一个函数指针，然后调用了这个函数指针。这个函数指针的类型是，不接收参数，也没有返回值。而LLVM-CFI采用的策略则是，只要满足这个类型的函数，都被认为是可以被函数指针所指向的。反之，如果不满足，则被拒绝。也就是说，在这个代码中，<code>foo1</code>、<code>foo2</code>都是满足的，而<code>bar</code>函数，因为它接收一个<code>int</code>类型的参数，所以不满足。</p>
<p>那么，具体是怎么实现的呢？我们来看看它的LLVM IR代码，其一部分为：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@foo1</span>() <span class="variable">#0</span> <span class="title">!type</span> <span class="title">!9</span> <span class="title">!type</span> <span class="title">!10</span> &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@foo2</span>() <span class="variable">#0</span> <span class="title">!type</span> <span class="title">!9</span> <span class="title">!type</span> <span class="title">!10</span> &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@bar</span>(<span class="type">i32</span> noundef <span class="variable">%0</span>) <span class="variable">#0</span> <span class="title">!type</span> <span class="title">!11</span> <span class="title">!type</span> <span class="title">!12</span> &#123;</span><br><span class="line">  <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> ptr <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@baz</span>(ptr noundef <span class="variable">%0</span>) <span class="variable">#0</span> <span class="title">!type</span> <span class="title">!13</span> <span class="title">!type</span> <span class="title">!14</span> &#123;</span><br><span class="line">  <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">alloca</span> ptr<span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> ptr <span class="variable">%0</span><span class="punctuation">,</span> ptr <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">load</span> ptr<span class="punctuation">,</span> ptr <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%4</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i1</span> <span class="title">@llvm.type.test</span>(ptr <span class="variable">%3</span><span class="punctuation">,</span> metadata !<span class="string">&quot;_ZTSFvvE&quot;</span>)<span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%4</span><span class="punctuation">,</span> label <span class="variable">%6</span><span class="punctuation">,</span> label <span class="variable">%5</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>:                                                <span class="comment">; preds = %1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.ubsantrap</span>(<span class="type">i8</span> <span class="number">2</span>) <span class="variable">#3</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line">  <span class="keyword">unreachable</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>:                                                <span class="comment">; preds = %1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="variable">%3</span>()</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!9</span> <span class="operator">=</span> !&#123;<span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> !<span class="string">&quot;_ZTSFvvE&quot;</span>&#125;</span><br><span class="line"><span class="title">!10</span> <span class="operator">=</span> !&#123;<span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> !<span class="string">&quot;_ZTSFvvE.generalized&quot;</span>&#125;</span><br><span class="line"><span class="title">!11</span> <span class="operator">=</span> !&#123;<span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> !<span class="string">&quot;_ZTSFviE&quot;</span>&#125;</span><br><span class="line"><span class="title">!12</span> <span class="operator">=</span> !&#123;<span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> !<span class="string">&quot;_ZTSFviE.generalized&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在<code>baz</code>函数中，在调用这个函数指针，也就是<code>call void %3()</code>之前，被插入了一部分代码：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">  <span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">load</span> ptr<span class="punctuation">,</span> ptr <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%4</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i1</span> <span class="title">@llvm.type.test</span>(ptr <span class="variable">%3</span><span class="punctuation">,</span> metadata !<span class="string">&quot;_ZTSFvvE&quot;</span>)<span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%4</span><span class="punctuation">,</span> label <span class="variable">%6</span><span class="punctuation">,</span> label <span class="variable">%5</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line"><span class="number">5</span>:                                                <span class="comment">; preds = %1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.ubsantrap</span>(<span class="type">i8</span> <span class="number">2</span>) <span class="variable">#3</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line">  <span class="keyword">unreachable</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br></pre></td></tr></table></figure>

<p>在这里，首先调用了<code>llvm.type.test</code>这个内置函数。这个内置函数的作用是查看<code>ptr %3</code>这个函数的类型，是否是<code>!&quot;_ZTSFvvE&quot;</code>这个元数据所代表的类型，如果不是的话，就跳转，调用<code>llvm.ubsantrap</code>报告错误。而我们可以看到，<code>foo1</code>、<code>foo2</code>、<code>bar</code>都被附加了一些元数据，查看代码的下半部分，可以看到，<code>foo1</code>、<code>foo2</code>的元数据是<code>!&quot;_ZTSFvvE&quot;</code>，而<code>bar</code>的元数据是<code>!&quot;_ZTSFviE&quot;</code>。因此，如果攻击者想让这个间接调用前往<code>bar</code>函数，就会被拒绝，从而保护了控制流的完整性。</p>
]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>project</tag>
        <tag>Flang</tag>
      </tags>
  </entry>
  <entry>
    <title>2023年9月</title>
    <url>/2023/09/05/2023%E5%B9%B49%E6%9C%88/</url>
    <content><![CDATA[<h1 id="问题日志"><a href="#问题日志" class="headerlink" title="问题日志"></a>问题日志</h1><span id="more"></span>

<h2 id="Flang运行命令flang-function-f90-o-function-exe遇到问题："><a href="#Flang运行命令flang-function-f90-o-function-exe遇到问题：" class="headerlink" title="Flang运行命令flang function.f90 -o function.exe遇到问题："></a>Flang运行命令<code>flang function.f90 -o function.exe</code>遇到问题：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: cannot find -lflangmain</span><br><span class="line">/usr/bin/ld: cannot find -lflang</span><br><span class="line">/usr/bin/ld: cannot find -lflangrti</span><br><span class="line">/usr/bin/ld: cannot find -lpgmath</span><br><span class="line">clang-14: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure>

<p>解决办法：<a href="https://blog.51cto.com/crocodile/964277?articleABtest=1">解决&#x2F;usr&#x2F;bin&#x2F;ld: cannot find -lxxx_crocodile的记录空间的技术博客_51CTO博客</a></p>
<p>分析原因：编译Flang生成的动态库没有放到&#x2F;usr&#x2F;lib中，因此在使用时找不到该库。现在需要将这些文件放到系统指定查找的位置。</p>
<p>也就是将编译好的文件复制到默认查找的库的地址下去：<code>sudo cp -a lib* /usr/lib/</code>，这样就能解决问题了。</p>
<h2 id="linux下的so、a和o文件的区别"><a href="#linux下的so、a和o文件的区别" class="headerlink" title="linux下的so、a和o文件的区别"></a>linux下的so、a和o文件的区别</h2><p>如一个C程序，经过gcc编译后得到的依次是：.i,.s,.o。分别是预处理文件、汇编文件和二进制文件（单元编译的结果），将许多单元编译的.o文件链接成一个文件后，便是编译产物。</p>
<p>.o是中间文件，相当于windows系统下的.obj文件 。</p>
<p>.a为静态库，是好多个.o合在一起,用于静态链接， 相当于windows系统下的lib。</p>
<p>.so 为共享库，是shared object,用于动态链接的，相当于windows系统下的dll。</p>
<h2 id="gcc的编译过程"><a href="#gcc的编译过程" class="headerlink" title="gcc的编译过程"></a>gcc的编译过程</h2><p>编译过程的分步执行：<br>为了更好地理解gcc的工作过程，我们可以让在gcc工作的<strong>4个阶段</strong>中的任何一个阶段中停止下来。相关的参数有：<br><strong>-E</strong><br>预编译后停下来，生成后缀为 <strong>.i 的预编译文件</strong>。<br><strong>-c</strong><br>编译后停下来，生成后缀为 <strong>.o 的目标文件</strong>。<br><strong>-S</strong><br>汇编后停下来，生成后缀为 <strong>.s 的汇编源文件</strong>。</p>
<p>第一步：进行预编译，使用 -E 参数<br><code>gcc -E test.c -o test.i</code><br>查看 test.i 文件中的内容，会发现 stdio.h 的内容确实都插到文件里去了，而其他应当被预处理的宏定义也都做了相应的处理。<br>第二步：将 test.i 编译为目标代码，使用 -c 参数<br><code>gcc -c test.c -o test.o</code><br>第三步：生成汇编源文件<br><code>gcc -S test.c -o test.s</code><br>第四步：将生成的目标文件链接成可执行文件<br><code>gcc test.o - o test</code></p>
<p>对于稍微复杂的情况，比如有多个源代码文件、需要链接库或有其他比较特别的要求，就要给定适当的调用选项参数。</p>
<h2 id="解决Flang和IKOS适配问题的思路"><a href="#解决Flang和IKOS适配问题的思路" class="headerlink" title="解决Flang和IKOS适配问题的思路"></a>解决Flang和IKOS适配问题的思路</h2><p><img src="/paper_source/2023%E5%B9%B49%E6%9C%88/Flang%E4%B8%8EIKOS%E9%80%82%E9%85%8D%E6%80%9D%E8%B7%AF.jpg" alt="image-20230906101050110"></p>
<h2 id="pragma-once的使用规则"><a href="#pragma-once的使用规则" class="headerlink" title="pragma once的使用规则"></a>pragma once的使用规则</h2><p><code>#pragma once</code>是一个比较常用的C&#x2F;C++<a href="https://so.csdn.net/so/search?q=%E9%A2%84%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020">预处理</a>指令，只要在头文件的最开始加入这条预处理指令，就能够保证头文件只被编译一次，防止头文件被重复引用。</p>
<p><strong>“被重复引用”</strong>指<a href="https://so.csdn.net/so/search?q=%E5%A4%B4%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">头文件</a>在cpp文件中多次被include，include嵌套造可能现象造成头文件多次引用。</p>
<p>作用都是为了避免同一个被 #include 多次，或者避免头文件嵌套包含（参照前置声明的笔记）。需要特别注意的是：</p>
<ul>
<li><p>#pragma once 并不是C++的原生语法，而是编译器的一种支持，所以并不是所有的编译器都能够支持。#ifndef 则为C++的标准。</p>
</li>
<li><p>#ifndef 依赖于不重复的宏名称，保证了包含在 #endif 的内容不会被重复包含，这个内容可以是一个文件的所有内容，或者仅仅是一段代码。而 #pragma once 则是针对物理文件的一个标记，标记该文件不会被 #include 多次，不能只针对文件中某段代码进行标记。而且，#pragma once 不能保证多个文件的拷贝不会被重复包含，但这种错误更容易发现，且 #pragma once 大大提高了编译效率。</p>
</li>
<li><p>一般建议用 #pragma once，因为一个类声明和定义各占用一个物理文件，即使类声明之外的内容，也应该是和该类有关，比如非模板类中声明了模板接口，则需要在同一个文件定义该模板接口。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 自定义的宏名称</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 自定义的宏名称</span></span><br><span class="line">...整个文件的内容，或某段代码...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记当前物理文件只会被包含一次，但如果文件有多个拷贝，也会被重复包含</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once </span></span><br></pre></td></tr></table></figure>

<h2 id="namespace：命名空间的定义"><a href="#namespace：命名空间的定义" class="headerlink" title="namespace：命名空间的定义"></a>namespace：命名空间的定义</h2><p>在C语言中只有一个全局作用域：</p>
<ol>
<li>C语言中所有的全局标识符共享一个作用域</li>
<li>标识符之间可能发生冲突</li>
</ol>
<p>C++中提出了命名空间的概念：</p>
<ol>
<li>命名空间将全局作用域分成不同的部分</li>
<li>不同命名空间中的标识符可以同名而不会发生冲突</li>
<li>命名空间可以发生嵌套</li>
<li>全局作用域也叫默认命名空间</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Name</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">namespace</span> Internal</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*...*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++命名空间的使用：</p>
<ol>
<li>使用整个命名空间：<code>using namespace name;</code></li>
<li>使用命名空间中的变量：<code>using name::variable;</code></li>
<li>使用默认命名空间中的变量:  <code>::variable;</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> First </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> Second</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">namespace</span> Internal <span class="comment">//嵌套命名空间</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">P</span>  <span class="comment">//嵌套命名空间</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x;</span><br><span class="line">			<span class="type">int</span> y;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> First; <span class="comment">//使用整个命名空间</span></span><br><span class="line">	<span class="keyword">using</span> Second::Internal::P;  <span class="comment">//使用嵌套的命名空间</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;First::i = %d\n&quot;</span>, i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Second::i = %d\n&quot;</span>, Second::i);  <span class="comment">//使用命名空间中的变量</span></span><br><span class="line"> </span><br><span class="line">	P p = &#123; <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p.x = %d\n&quot;</span>, p.x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p.y = %d\n&quot;</span>, p.y);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unordered-map容器用法"><a href="#unordered-map容器用法" class="headerlink" title="unordered_map容器用法"></a>unordered_map容器用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap;</span><br><span class="line">    <span class="comment">//向 umap 容器添加新键值对</span></span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Java教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Linux教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出 umap 存储键值对的数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap size = &quot;</span> &lt;&lt; umap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//使用迭代器输出 umap 容器存储的所有键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体使用讲解见网址：<a href="http://c.biancheng.net/view/7231.html">C++ STL unordered_map容器用法详解 (biancheng.net)</a></p>
<h2 id="C-语法中explicit关键字的使用及示例"><a href="#C-语法中explicit关键字的使用及示例" class="headerlink" title="C++语法中explicit关键字的使用及示例"></a>C++语法中explicit关键字的使用及示例</h2><p><code>explicit</code> 是 C++ 语言中的一个关键字，它可以用来修饰单个参数的构造函数，表示该构造函数只能显式调用，禁止隐式转换。在 C++11 中，<code>explicit</code> 还可以用来修饰类型转换函数，表示只能显式进行类型转换。</p>
<p>下面是一个简单的示例，演示了 <code>explicit</code> 的使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : <span class="built_in">m_x</span>(x) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_x</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="type">int</span> x)</span> : m_x(x) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_x</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_x; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a.get_x() = &quot;</span> &lt;&lt; a.<span class="built_in">get_x</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b.get_x() = &quot;</span> &lt;&lt; b.<span class="built_in">get_x</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1 = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">funcA</span>(a1); <span class="comment">// 可以隐式转换</span></span><br><span class="line">    <span class="comment">// A a2 = &#x27;a&#x27;; // 错误：不允许隐式转换</span></span><br><span class="line"></span><br><span class="line">    B b1 = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// funcB(b1); // 错误：只能显式转换</span></span><br><span class="line">    <span class="built_in">funcB</span>(<span class="built_in">static_cast</span>&lt;B&gt;(<span class="number">3</span>)); <span class="comment">// 正确：显式转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详情见<a href="https://zhuanlan.zhihu.com/p/624294266">C++语法糖(explicit关键字)详解以及示例代码 - 知乎 (zhihu.com)</a></p>
<h2 id="C-中的noexcept关键字的用法"><a href="#C-中的noexcept关键字的用法" class="headerlink" title="C++中的noexcept关键字的用法"></a>C++中的noexcept关键字的用法</h2><p>在C++11标准中引入了<code>noexcept</code>关键字，它用于指示函数是否可能抛出异常。<code>noexcept</code>可以用于函数声明和函数定义中，如果将函数标记为<code>noexcept</code>，那么编译器就可以进行一些优化，从而提高程序性能。</p>
<p><code>noexcept</code>关键字可以放在函数声明和函数定义的括号后面，表示该函数不会抛出任何异常。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多细节请看[C++语法糖(noexcept关键字)详解以及示例代码 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/624737461#:~:text=%E5%9C%A8C%2B%2B11%E6%A0%87%E5%87%86%E4%B8%AD%E5%BC%95%E5%85%A5%E4%BA%86noexcept%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E5%AE%83%E7%94%A8%E4%BA%8E%E6%8C%87%E7%A4%BA%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E5%8F%AF%E8%83%BD%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E3%80%82,noexcept%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%B0%86%E5%87%BD%E6%95%B0%E6%A0%87%E8%AE%B0%E4%B8%BAnoexcept%EF%BC%8C%E9%82%A3%E4%B9%88%E7%BC%96%E8%AF%91%E5%99%A8%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%8C%E4%BB%8E%E8%80%8C%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E3%80%82">https://zhuanlan.zhihu.com/p/624737461#:~:text=在C%2B%2B11标准中引入了noexcept关键字，它用于指示函数是否可能抛出异常。,noexcept可以用于函数声明和函数定义中，如果将函数标记为noexcept，那么编译器就可以进行一些优化，从而提高程序性能。</a> noexcept关键字可以放在函数声明和函数定义的括号后面，表示该函数不会抛出任何异常。)</p>
<h2 id="C-中的const关键字使用"><a href="#C-中的const关键字使用" class="headerlink" title="C++中的const关键字使用"></a>C++中的const关键字使用</h2><p><strong>const修饰成员函数：常函数</strong></p>
<ul>
<li>成员函数后加<code>const</code>后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字<code>mutable</code>后，在常函数中依然可以修改</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		m_A = <span class="number">0</span>;</span><br><span class="line">		m_B = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">	<span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//const Type* const pointer;</span></span><br><span class="line">		<span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">		<span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line">		<span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//mA = 10000;</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">	person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象访问成员函数</span></span><br><span class="line">	person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节请看<a href="https://zhuanlan.zhihu.com/p/403182089">C++中const的5种用法总结 - 知乎 (zhihu.com)</a></p>
<h2 id="C-中的delete关键字使用"><a href="#C-中的delete关键字使用" class="headerlink" title="C++中的delete关键字使用"></a>C++中的delete关键字使用</h2><p><code>delete</code>有2个作用：</p>
<ol>
<li>释放<code>new</code>分配的动态内存；</li>
<li>阻止编译器自动合成函数；</li>
</ol>
<p><strong>释放new分配的动态内存</strong></p>
<p><code>delete</code>需要与<code>new</code>配对使用，其参数可以是指向一块内存首地址或空指针（<code>nullptr</code>）。不能对同一块内存多次delete，但是可以对空指针多次<code>delete</code>。</p>
<p>注意<code>delete</code>和<code>delete[] </code>的区别：</p>
<ul>
<li><code>delete p </code>释放<code>p</code>指向的（单个）内存，可用于释放单个内存对象；</li>
<li><code>delete []p </code>释放<code>p</code>指向的内存区块，可用于释放一组内存（数组）；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放基本类型内存</span></span><br><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">delete</span> pi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放类对象内存</span></span><br><span class="line"><span class="type">int</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> ps; <span class="comment">// 会调用string类析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放数组类型内存</span></span><br><span class="line"><span class="type">int</span> *pa = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> []pa;</span><br></pre></td></tr></table></figure>

<p><strong>阻止编译器合成函数</strong></p>
<p>适用于C++11以上版本。</p>
<p>如果没有为类编写<strong>构造函数、析构函数、拷贝构造函数、拷贝赋值运算符，以及移动拷贝函数、移动赋值运算符</strong>，编译器可能会为类合成默认的函数版本。显式使用<code>delete</code>，可以阻止编译器合成对应函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObj</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyObj</span>() = <span class="keyword">delete</span>; <span class="comment">// 阻止编译器合成构造函数，会导致类无法实例化</span></span><br><span class="line">  <span class="function">MyObj&amp; <span class="title">MyObj</span><span class="params">(<span class="type">const</span> MyObj &amp;)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 阻止编译器合成拷贝构造函数，会导致类无法拷贝构造，如std::cin, std::cout</span></span><br><span class="line">  MyObj&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyObj &amp;) = <span class="keyword">delete</span>; <span class="comment">// 阻止合成赋值运算符，会导致类无法拷贝，如cin, cout, cerr</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>与<code>delete</code>对应的是<code>default</code>，<code>default</code>显式告诉编译器使用编译器自动合成的函数。<br>合成的默认构造函数，只有基类子对象和类类型对象会被初始化，而其他所有的非静态成员（如整数，指针，数组等），都不会初始化，对他们进行初始化的应该是程序员，而非编译器。</p>
<p>如果类包含了需要动态创建对象的指针，就不能依靠合成的构造函数、拷贝构造函数、拷贝赋值运算符。</p>
<p>详情见<a href="https://www.cnblogs.com/fortunely/p/14554114.html">C++&gt; delete关键字初探 - 明明1109 - 博客园 (cnblogs.com)</a></p>
<h2 id="C-中的友元函数和友元类"><a href="#C-中的友元函数和友元类" class="headerlink" title="C++中的友元函数和友元类"></a>C++中的友元函数和友元类</h2><p>在 C++ 中，一个类中可以有 <code>public</code>、<code>protected</code>、<code>private </code>三种属性的成员，通过对象可以访问 <code>public </code>成员，只有本类中的函数可以访问本类的 private 成员。现在，我们来介绍一种例外情况——友元（friend）。借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。</p>
<p>friend 的意思是朋友，或者说是好友，与好友的关系显然要比一般人亲密一些。我们会对好朋友敞开心扉，倾诉自己的秘密，而对一般人会谨言慎行，潜意识里就自我保护。在 C++ 中，这种友好关系可以用<code>friend</code>关键字指明，中文多译为“友元”，借助友元可以访问与其有好友关系的类中的私有成员。如果你对“友元”这个名词不习惯，可以按原文 friend 理解为朋友。</p>
<p>友元函数<br>在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。</p>
<p><strong>友元函数可以访问当前类中的所有成员，包括 <code>public</code>、<code>protected</code>、<code>private</code> 属性的。</strong></p>
<p>细节请看<a href="https://blog.51cto.com/u_15080016/4567286">C++友元函数和友元类（C++ friend关键字）_51CTO博客_c++ 友元</a></p>
<h2 id="C-中智能指针unique-ptr使用"><a href="#C-中智能指针unique-ptr使用" class="headerlink" title="C++中智能指针unique_ptr使用"></a>C++中智能指针unique_ptr使用</h2><p>C++ 标准提供了 3 种智能指针，分别是 <code>shared_ptr</code>、<code>unique_ptr</code> 和 <code>weak_ptr</code>，本节我们给大家讲解 <code>unique_ptr</code> 智能指针的特性和用法。</p>
<blockquote>
<p>关于 shared_ptr 智能指针，可以阅读《<a href="http://c.biancheng.net/view/7898.html">C++11 shared_ptr智能指针</a>》一节；关于 weak_ptr 智能指针，可以阅读《<a href="http://c.biancheng.net/view/vip_8673.html">C++11 weak_ptr智能指针</a>》一节。</p>
</blockquote>
<p>作为智能指针的一种，<code>unique_ptr</code> 指针自然也具备“在适当时机自动释放堆内存空间”的能力。和 <code>shared_ptr </code>指针最大的不同之处在于，unique_ptr 指针指向的堆内存无法同其它 unique_ptr 共享，也就是说，每个 <code>unique_ptr </code>指针都独自拥有对其所指堆内存空间的所有权。</p>
<blockquote>
<p>这也就意味着，每个 unique_ptr 指针指向的堆内存空间的引用计数，都只能为 1，一旦该 unique_ptr 指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。</p>
</blockquote>
<p><code>unique_ptr </code>智能指针是以模板类的形式提供的，<code>unique_ptr&lt;T&gt;</code>（T 为指针所指数据的类型）定义在<code>&lt;memory&gt;</code>头文件，并位于 <code>std </code>命名空间中。因此，要想使用 <code>unique_ptr </code>类型指针，程序中应首先包含如下1条语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>unique_ptr智能指针的创建</strong></p>
<p>考虑到不同实际场景的需要，<code>unique_ptr&lt;T&gt;</code> 模板类提供了多个实用的构造函数，这里给读者列举了几种常用的构造<code>unique_ptr</code>智能指针的方式。</p>
<ol>
<li><p>通过以下 2 种方式，可以创建出空的 unique_ptr 指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code> unique_ptr</code> 指针的同时，也可以明确其指向。例如：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>基于<code> unique_ptr</code> 类型指针不共享各自拥有的堆内存，因此 C++11 标准中的 <code>unique_ptr</code> 模板类没有提供拷贝构造函数，只提供了移动构造函数。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(p4)</span></span>;<span class="comment">//错误，堆内存不共享</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>;<span class="comment">//正确，调用移动构造函数</span></span><br></pre></td></tr></table></figure>

<p>值得一提的是，对于调用移动构造函数的 p4 和 p5 来说，p5 将获取 p4 所指堆空间的所有权，而 p4 将变成空指针（<code>nullptr</code>）。默认情况下，<code>unique_ptr</code> 指针采用 <code>std::default_delete&lt;T&gt; </code>方法释放堆内存。当然，我们也可以自定义</p>
<ol start="4">
<li>符合实际场景的释放规则。值得一提的是，和 <code>shared_ptr</code> 指针不同，为 <code>unique_ptr</code> 自定义释放规则，只能采用函数对象的方式。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的释放规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myDel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>, myDel&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//std::unique_ptr&lt;int, myDel&gt; p6(new int, myDel());</span></span><br></pre></td></tr></table></figure>

<p>详细内容请见<a href="http://c.biancheng.net/view/7909.html">C++11 unique_ptr智能指针详解 (biancheng.net)</a>、<a href="https://zhuanlan.zhihu.com/p/404771979">C++内存管理——unique_ptr - 知乎 (zhihu.com)</a></p>
<h2 id="C-中的static关键字的使用"><a href="#C-中的static关键字的使用" class="headerlink" title="C++中的static关键字的使用"></a>C++中的static关键字的使用</h2><ol>
<li><p>全局静态变量，在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。<strong>内存中的位置：</strong> 静态存储区，在整个程序运行期间一直存在。<strong>初始化</strong>：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<strong>作用域</strong>：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
</li>
<li><p>局部静态变量，在局部变量之前加上关键字<code>static</code>，局部变量就成为一个局部静态变量。内存中的位置：静态存储区。初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>
</li>
<li><p>静态函数，在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是<code>extern</code>的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。函数的实现使用<code>static</code>修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；warning：不要再头文件中声明<code>static</code>的全局函数，不要在cpp内声明非<code>static</code>的全局函数，<br>如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；</p>
</li>
<li><p>类的静态成员，在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。</p>
</li>
<li><p>类的静态函数，静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。</p>
</li>
</ol>
<p>详情请查阅<a href="https://blog.csdn.net/u011718663/article/details/118218407">C++ Static关键字作用介绍_WhiteTian的博客-CSDN博客</a></p>
<h2 id="C-中的override的使用"><a href="#C-中的override的使用" class="headerlink" title="C++中的override的使用"></a>C++中的override的使用</h2><h3 id="virtual："><a href="#virtual：" class="headerlink" title="virtual："></a><code>virtual</code>：</h3><ul>
<li>放在函数的返回值前面，用于表示该成员函数为虚函数</li>
<li>父类虚函数前必须写；子类虚函数前可以省略（不管省不省略，该函数在子类中也是虚函数类型）</li>
<li>virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义</li>
</ul>
<h3 id="override："><a href="#override：" class="headerlink" title="override："></a><code>override</code>：</h3><ul>
<li>父类的虚函数不可使用</li>
<li>放在子类虚函数的参数列表后（如果函数有尾指返回类型，那么要放在尾指返回类型后），用来说明此函数为覆盖(重写)父类的虚函数。如果类方法在类外进行定义，那么override不能加</li>
<li>不一定强制要求子类声明这个关键字，但是建议使用</li>
<li>这是C++11标准填入的</li>
</ul>
<h3 id="final："><a href="#final：" class="headerlink" title="final："></a><code>final</code>：</h3><ul>
<li>如果我们定义的一个虚函数不想被派生类覆盖（重写），那么可以在虚函数之后添加一个final关键字，声明这个虚函数不可以被派生类所覆盖（重写）</li>
<li>如果函数有尾指返回类型，那么要放在尾指返回类型后</li>
</ul>
<p>细节见<a href="https://cloud.tencent.com/developer/article/1784495">C++:44—关键字virtual、override、final-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h2 id="C-中的static-cast怎么用"><a href="#C-中的static-cast怎么用" class="headerlink" title="C++中的static_cast怎么用"></a>C++中的<code>static_cast</code>怎么用</h2><p>仅根据表达式中存在的类型，将<code> expression</code> 转换为<code>type-id</code>类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static_cast</span> &lt;type-id&gt; ( expression )</span><br></pre></td></tr></table></figure>

<p>在标准 C++ 中，不进行运行时类型检查来帮助确保转换的安全。 在 C++&#x2F;CX 中，将执行编译时和运行时检查。 有关更多信息，请参见 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/casting?view=msvc-170">强制转换</a>中定义的接口的私有 C++ 特定实现。</p>
<p><code>static_cast</code> 运算符可用于将指向基类的指针转换为指向派生类的指针等操作。 此类转换并非始终安全。</p>
<p>通常使用 <code>static_cast</code> 转换数值数据类型，例如将枚举型转换为整型或将整型转换为浮点型，而且你能确定参与转换的数据类型。 <code>static_cast</code> 转换安全性不如 <code>dynamic_cast</code> 转换，因为 <code>static_cast</code> 不执行运行时类型检查，而 <code>dynamic_cast</code> 执行该检查。 对不明确的指针的 <code>dynamic_cast</code> 将失败，而 <code>static_cast</code>的返回结果看似没有问题；这是危险的。 尽管 <code>dynamic_cast</code>转换更加安全，但是 <code>dynamic_cast</code>*只适用于指针或引用，而且运行时类型检查也是一项开销。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/cpp/cpp/dynamic-cast-operator?view=msvc-170">dynamic_cast 运算符</a>。</p>
<p>详情请见<a href="https://learn.microsoft.com/zh-cn/cpp/cpp/static-cast-operator?view=msvc-170">static_cast 运算符 | Microsoft Learn</a></p>
<h2 id="C-中的-ifdef怎么用"><a href="#C-中的-ifdef怎么用" class="headerlink" title="C++中的# ifdef怎么用"></a>C++中的<code># ifdef</code>怎么用</h2><p>可以在任何可以使用 <code>#if</code> 的地方使用 <code>#ifdef</code>*和 <code>#ifndef</code>指令。 如果定义了 <code>identifier</code>，<code>#ifdef``identifier</code> 语句等效于 <code>#if 1</code>。 如果 <code>identifier</code> 尚未定义或未被 <code>#undef</code>指令定义，它等效于 <code>#if 0</code>。 这些指令只检查使用 <code>#define</code> 定义的标识符是否存在，而不检查在 C 或 C++ 源代码中声明的标识符。</p>
<p>提供这些指令只是为了实现与该语言的早期版本的兼容性。 首选与 <code>#if</code> 指令一起使用的 <code>defined(``identifier</code>)&#96; 常量表达式。</p>
<p><code>#ifndef</code> 指令检查与 <code>#ifdef</code>检查的条件相反的情况。 如果尚未定义标识符，或者如果它的定义已用 <code>#undef</code> 删除，则条件为 <code>true</code>（非零值）。 否则，条件为 <code>false </code>(0)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ifdef_ifndef.CPP</span></span><br><span class="line"><span class="comment">// compile with: /Dtest /c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> test</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> final</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="C-中的-if-elif-endif怎么用"><a href="#C-中的-if-elif-endif怎么用" class="headerlink" title="C++中的# if, # elif, # endif怎么用"></a>C++中的<code># if, # elif, # endif</code>怎么用</h2><p>源文件中的每个 <code>#if </code>指令必须与表示结束的<code> #endif</code> 指令匹配。 任意数量的 <code>#elif</code> 指令可以出现在 #if 和<code>#endif</code>指令之间，但最多允许一个<code>#else</code>指令。 <code>#else </code>指令（如果有）必须是<code>#endif</code>之前的最后一个指令。</p>
<p><code>#if、#elif、#else </code>和 <code>#endif </code>指令可以嵌套在其他<code>#if</code>指令的 text 部分中。 每个嵌套的 <code>#else、#elif 或 #endif </code>指令属于最靠近的前面的 #if 指令。</p>
<p>所有条件编译指令（如 #if 和 #ifdef）都必须在文件末尾之前匹配一个 #endif 关闭指令。 否则会生成错误消息。 当条件编译指令包含在包含文件中时，这些指令必须满足相同的条件：包含文件的末尾不能有未匹配的条件编译指令。</p>
<p>在 #elif 命令后面的行部分中执行宏替换，以便能够在 constant-expression 中使用宏调用。</p>
<p>预处理器选择 text 的给定匹配项之一以进行进一步处理。 text 中指定的块可以是文本的任意序列。 它可占用多个行。 通常，text 是对编译器或预处理器有意义的程序文本。</p>
<p>预处理器处理选定的 text，并将其传递给编译器。 如果 text 包含预处理器指令，则预处理器将执行这些指令。 仅编译预处理器所选的文本块。</p>
<p>预处理器通过计算每个 #if 或 #elif 指令后面的常量表达式来选择单个 text 项，直到找到实际（非零）常量表达式。 它选择所有文本（包括以 <strong>#</strong> 开头的其他预处理器指令），直到其关联的 #elif、#else 或 #endif。</p>
<p>如果 constant-expression 的所有匹配项都为 false，或者 #elif 指令未出现，则预处理器将选择 #else 子句后面的文本块。 如果没有 #else 子句，并且 #if 块中的 constant-expression 的所有实例都为 false，则不选择文本块。</p>
<p>constant-expression 是具有下列其他限制的整数常量表达式：</p>
<ul>
<li>表达式必须具有整型，并且只能包含整数常量、字符常量和 defined 运算符。</li>
<li>表达式不能使用 <strong><code>sizeof</code></strong> 或 type-cast 运算符。</li>
<li>目标环境无法表示整数的所有范围。</li>
<li>转换以与类型 <strong><code>long</code></strong> 相同的方式表示类型 **<code>int</code>**，并以与类型 <strong><code>unsigned long</code></strong> 相同的方式表示类型 **<code>unsigned int</code>**。</li>
<li>转换器可以将字符常量转换为与目标环境的集不同的代码值集。 若要确定目标环境的属性，请使用为该环境生成的应用程序来检查 LIMITS.H 宏的值。</li>
<li>该表达式不得查询环境，并且必须不受与目标计算机上的实现详细信息的影响。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CREDIT)</span></span><br><span class="line">    <span class="built_in">credit</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(DEBIT)</span></span><br><span class="line">    <span class="built_in">debit</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printerror</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> DLEVEL &gt; 5</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SIGNAL  1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> STACKUSE == 1</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> STACK   200</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> STACK   100</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SIGNAL  0</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> STACKUSE == 1</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> STACK   100</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> STACK   50</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DLEVEL == 0</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STACK 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DLEVEL == 1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STACK 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> DLEVEL &gt; 5</span></span><br><span class="line">    <span class="built_in">display</span>( debugptr );</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> STACK 200</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>具体请看<a href="https://learn.microsoft.com/zh-cn/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=msvc-170">#if、#elif、#else 和 #endif 指令 (C&#x2F;C++) | Microsoft Learn</a></p>
<h2 id="C-中的typename和class的区别"><a href="#C-中的typename和class的区别" class="headerlink" title="C++中的typename和class的区别"></a>C++中的<code>typename</code>和<code>class</code>的区别</h2><p>在 C++ Template 中很多地方都用到了 typename 与 class 这两个关键字，而且好像可以替换，是不是这两个关键字完全一样呢?</p>
<p>相信学习 C++ 的人对 class 这个关键字都非常明白，class 用于定义类，在模板引入 c++ 后，最初定义模板的方法为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;......</span><br></pre></td></tr></table></figure>

<p>这里 class 关键字表明T是一个类型，后来为了避免 class 在这两个地方的使用可能给人带来混淆，所以引入了 typename 这个关键字，它的作用同 class 一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;......</span><br></pre></td></tr></table></figure>

<p>在模板定义语法中关键字 class 与 typename 的作用完全一样。</p>
<p>typename 难道仅仅在模板定义中起作用吗？其实不是这样，typename 另外一个作用为：**使用嵌套依赖类型(nested depended name)**，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">public</span>：</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> LengthType;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyMethod</span><span class="params">( T myarr )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> T::LengthType LengthType; </span><br><span class="line">    LengthType length = myarr.GetLength; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候 typename 的作用就是告诉 c++ 编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有 typename，编译器没有任何办法知道 T::LengthType 是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。</p>
<h2 id="C-中的void-怎么用"><a href="#C-中的void-怎么用" class="headerlink" title="C++中的void*怎么用"></a>C++中的<code>void*</code>怎么用</h2><p>首先<code>void*</code>中的void代表一个任意的数据类型，”星号”代表一个指针，所以其就是一个任意数据类型的指针。</p>
<blockquote>
<p>对于指定数据类型的指针如<code>int* ，double*</code>等，他们的sizeof都是4个字节，因为都是一个指针，只是指针指向的数据类型不一致。</p>
</blockquote>
<p><strong>当函数传参时不确定数据类型时或者支持多种数据类型传递时。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">(<span class="type">int</span> type,<span class="type">void</span>* pArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span>* d = (<span class="type">double</span>*)pArgs;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span>* i = (<span class="type">int</span>*)pArgs;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数返回值不需要考虑类型，只关心返回的大小。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>

<p>代码使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span>* b = <span class="literal">nullptr</span>;</span><br><span class="line">b = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br></pre></td></tr></table></figure>

<p>可以看到<code>malloc</code>返回值类型为<code>void*</code>，其只返回分配内存的大小，不关心分配后的内存你是使用int还是double类型进行划分.</p>
<blockquote>
<p>注意：函数外部在接收到void*格式的返回值时，需要强转为自己的数据类型才能使用。</p>
</blockquote>
<p><strong>当void*作为函数的参数类型或者返回值类型时，说明该函数可以接收或者返回任意类型的指针。</strong></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* _say(<span class="type">void</span>* pArgs) &#123;</span><br><span class="line">    <span class="keyword">return</span> pArgs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> _a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">10.8</span>;</span><br><span class="line">    <span class="type">int</span>* _pi = &amp;_a;</span><br><span class="line">    <span class="type">float</span>* pf = &amp;f;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *(<span class="type">int</span>*)_say(_pi) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *(<span class="type">float</span>*)_say(pf) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10.8</span></span><br></pre></td></tr></table></figure>

<p>代码中可以看出参数<code>void* pArgs</code>可以使用任意类型的实参，返回值也可以返回任意类型的指针，但是最终需要转换为具体类型才能使用。</p>
<p><code>void*</code>在C++中的作用其实就是为了实现<strong>泛型编程</strong>，和Java中使用Object来表示是一样的，所以又称为通用指针和泛指针，不过<strong>C++中大部分情况下会使用模板编程来实现泛型</strong>。</p>
<h2 id="在项目中用doxygen写项目注释"><a href="#在项目中用doxygen写项目注释" class="headerlink" title="在项目中用doxygen写项目注释"></a>在项目中用doxygen写项目注释</h2><p><strong>Doxygen语法简介</strong></p>
<p>所谓<code>Doxygen</code>语法就是在写程序注视时候按照<code>Doxygen</code>语法规则来写注释。只有按照标准的注释规则来写注释，生成的文档才会非常漂亮，否则乱七八糟的。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>字段名</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>@file</td>
<td>文件名</td>
<td>file [&lt; name &gt;]</td>
</tr>
<tr>
<td>@brief</td>
<td>简介</td>
<td>brief { brief description }</td>
</tr>
<tr>
<td>@author</td>
<td>作者</td>
<td>author { list of authors }</td>
</tr>
<tr>
<td>@mainpage</td>
<td>主页信息</td>
<td>mainpage [(title)]</td>
</tr>
<tr>
<td>@date</td>
<td>年-月-日</td>
<td>date { date description }</td>
</tr>
<tr>
<td>@author</td>
<td>版本号</td>
<td>version { version number }</td>
</tr>
<tr>
<td>@copyright</td>
<td>版权</td>
<td>copyright { copyright description }</td>
</tr>
<tr>
<td>@param</td>
<td>参数</td>
<td>param [(dir)] &lt; parameter-name&gt; { parameter description }</td>
</tr>
<tr>
<td>@return</td>
<td>返回</td>
<td>return { description of the return value }</td>
</tr>
<tr>
<td>@retval</td>
<td>返回值</td>
<td>retval { description }</td>
</tr>
<tr>
<td>@bug</td>
<td>漏洞</td>
<td>bug { bug description }</td>
</tr>
<tr>
<td>@details</td>
<td>细节</td>
<td>details { detailed description }</td>
</tr>
<tr>
<td>@pre</td>
<td>前提条件</td>
<td>pre { description of the precondition }</td>
</tr>
<tr>
<td>@see</td>
<td>参考</td>
<td>see { references }</td>
</tr>
<tr>
<td>@link</td>
<td>连接(与@see类库，{@link <a href="https://link.zhihu.com/?target=http://www.google.com">http://www.google.com</a>})</td>
<td>link &lt; link-object&gt;</td>
</tr>
<tr>
<td>@throw</td>
<td>异常描述</td>
<td>throw &lt; exception-object&gt; { exception description }</td>
</tr>
<tr>
<td>@todo</td>
<td>待处理</td>
<td>todo { paragraph describing what is to be done }</td>
</tr>
<tr>
<td>@warning</td>
<td>警告信息</td>
<td>warning { warning message }</td>
</tr>
<tr>
<td>@deprecated</td>
<td>弃用说明。可用于描述替代方案，预期寿命等</td>
<td>deprecated { description }</td>
</tr>
<tr>
<td>@example</td>
<td>弃用说明。可用于描述替代方案，预期寿命等</td>
<td>deprecated { description }</td>
</tr>
</tbody></table>
<p><strong>文件注释</strong></p>
<p>一般放在文件开头</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @file 文件名</span><br><span class="line"> * @brief 简介</span><br><span class="line"> * @details 细节</span><br><span class="line"> * @author 作者</span><br><span class="line"> * @version 版本号</span><br><span class="line"> * @date 年-月-日</span><br><span class="line"> * @copyright 版权</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p><strong>函数注释</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * @brief 函数描述</span><br><span class="line">  * @param 参数描述</span><br><span class="line">  * @return 返回描述</span><br><span class="line">  * @retval 返回值描述</span><br><span class="line">  */</span><br></pre></td></tr></table></figure>

<p>细节请看<a href="https://zhuanlan.zhihu.com/p/510925324">干货|教你使用Doxygen制作漂亮的程序文档 - 知乎 (zhihu.com)</a></p>
<h2 id="C-中的this和-this的作用和区别"><a href="#C-中的this和-this的作用和区别" class="headerlink" title="C++中的this和*this的作用和区别"></a>C++中的<code>this</code>和<code>*this</code>的作用和区别</h2><p><code>return *this</code>返回的是当前对象的克隆或者本身（若返回类型为A， 则是克隆， 若返回类型为A&amp;， 则是本身 ）。<code>return this</code>返回当前对象的地址（指向当前对象的指针）。</p>
<p>具体请见<a href="https://blog.csdn.net/u011663005/article/details/106151786">C++中this与*this的区别_北海的星辰大海的博客-CSDN博客</a></p>
<h2 id="C-中的initializer-list类型的简单使用"><a href="#C-中的initializer-list类型的简单使用" class="headerlink" title="C++中的initializer_list类型的简单使用"></a>C++中的<code>initializer_list</code>类型的简单使用</h2><p><strong>initializer_list</strong>是C++11提供的新数据类型，和<code>vector</code>一样，<code>initializer_list</code>也是一种模板类型。可以使用<code>.begin(), .end()</code> 等方法。</p>
<p>因为C++11扩大了初始化列表的适用范围，使其可用于所有内置类型和用户定义的类型。使用初始化列表时，可添加&#x3D;等于号，也可不添加。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  a=&#123;<span class="number">0</span>&#125; ; </span><br><span class="line"><span class="type">int</span>  b&#123;<span class="number">0</span>&#125; ;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125; ;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; ;</span><br></pre></td></tr></table></figure>

<p>由此可见，<code>initializer_list</code> 还有一种用法是在构造函数或者其他函数中作为参数输入。能够简化一些操作。两个小例子：</p>
<p>第一个例子是在类中的构造函数中接收初始化列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumber</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyNumber</span>(<span class="type">const</span> std::initializer_list&lt;<span class="type">int</span>&gt; &amp;v) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> itm : v) &#123;</span><br><span class="line">            mVec.<span class="built_in">push_back</span>(itm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> itm : mVec) &#123;</span><br><span class="line">        std::cout &lt;&lt; itm &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; mVec;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyNumber m = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    m.<span class="built_in">print</span>();  <span class="comment">// 1 2 3 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个例子是在普通函数中接受初始化列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(initializer_list&lt;<span class="type">double</span>&gt; il)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">average</span><span class="params">(<span class="type">const</span> initializer_list&lt;<span class="type">double</span>&gt; &amp;ril)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum</span><span class="params">(initializer_list&lt;<span class="type">double</span>&gt; il)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> tmp : il) sum += tmp;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">average</span><span class="params">(<span class="type">const</span> initializer_list&lt;<span class="type">double</span>&gt; &amp;ril)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ril.<span class="built_in">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> tmp : ril) sum += tmp;</span><br><span class="line">		<span class="keyword">return</span> sum / ril.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum:&quot;</span> &lt;&lt; <span class="built_in">sum</span>(&#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;) &lt;&lt; <span class="string">&quot;, ave:&quot;</span> &lt;&lt; <span class="built_in">average</span>(&#123; <span class="number">2.0</span>, <span class="number">3</span>, <span class="number">4</span> &#125;) &lt;&lt; endl;</span><br><span class="line">	initializer_list&lt;<span class="type">double</span>&gt; dl = &#123; <span class="number">1.5</span>, <span class="number">2.5</span>, <span class="number">3.5</span>, <span class="number">4.5</span>, <span class="number">5.5</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum:&quot;</span> &lt;&lt; <span class="built_in">sum</span>(dl) &lt;&lt; <span class="string">&quot;, ave:&quot;</span> &lt;&lt; <span class="built_in">average</span>(dl) &lt;&lt; endl;</span><br><span class="line">	dl = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sum:&quot;</span> &lt;&lt; <span class="built_in">sum</span>(dl) &lt;&lt; <span class="string">&quot;, ave:&quot;</span> &lt;&lt; <span class="built_in">average</span>(dl) &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>log</category>
        <category>learn</category>
      </categories>
      <tags>
        <tag>project</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>clion的使用</title>
    <url>/2023/09/05/clion%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="将Clion作为编程工具"><a href="#将Clion作为编程工具" class="headerlink" title="将Clion作为编程工具"></a>将Clion作为编程工具</h2><span id="more"></span>

<p>首先将Clion中的一些快捷指令快速记录，以备后续之需。目前的工作主要是将Clion作为C++语言的开发工具，加上在ubuntu上使用十分方便。</p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li>ALT+1：显示隐藏工程栏</li>
<li>CTRL+&#x2F;：注释or解注释光标所在行</li>
<li>CTRL+SHIFT+&#x2F;：注释or解注释选中的多行代码</li>
<li>在某个函数的上面一行输入&#x2F;**+ENTER：快速生成某种格式的注释（for 大型项目）</li>
<li>CTRL+D：快速复制光标所在行</li>
<li>CTRL+X：快速剪切光标所在行</li>
<li>CTRL+W：实现某个字符、某个字符串、某段代码的扩选（智能扩选）</li>
<li>ALT+SHIFT+INSERT：按以下此组合建，在选中代码，可以实现多行某段代码的选中</li>
<li>CTRL+ALT+ “-” or “+” ：展开or折叠光标所在的花括号</li>
<li>CTRL+SHIFT+ “-” or “+” ：展开or折叠所有花括号</li>
<li>CTRL+鼠标左键：由函数声明跳转到函数定义 or 由函数定义跳转回函数声明</li>
<li>CTRL+ALT+R：重新格式化代码</li>
<li>ALT+ENTER：智能提示代码错误与解决方案</li>
<li>CTRL+F：匹配查找代码</li>
<li>CTRL+Z：返回编辑前</li>
<li>SHIFT+CTRL+Z：返回编辑后信息</li>
<li>CTRL+F：查找</li>
<li>CTRL+R：替换</li>
<li>CTRL+L：向后查找</li>
<li>CTRL+Shift+L：向前查找</li>
<li>CTRL+ALT+S：设置</li>
<li>Shift+F10：运行</li>
<li>Shift+F9：调试</li>
</ul>
<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><ul>
<li>单步运行（不跳转至其他标签，仅在本程序内）</li>
<li>单步运行（可调转到自己编写的库or头文件）</li>
<li>单步运行（可强制跳转到第三方库or头文件）</li>
<li>从第三方库跳回源文件</li>
<li>监测选中的变量</li>
</ul>
]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>IKOS</tag>
        <tag>Project</tag>
      </tags>
  </entry>
  <entry>
    <title>和符老师讨论</title>
    <url>/2023/07/14/%E5%92%8C%E7%AC%A6%E8%80%81%E5%B8%88%E8%AE%A8%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="2023-8-22讨论"><a href="#2023-8-22讨论" class="headerlink" title="2023-8-22讨论"></a>2023-8-22讨论</h2><span id="more"></span>

<p>哪些地方可以做？</p>
<p>陈：之前的想法：</p>
<p><img src="C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20230822101758868.png" alt="image-20230822101758868"></p>
<p>陈：需要考虑哪些效果预期比现在效果更好？</p>
<p>陈：利用已有前端IKOS（不变式生成能力比Clam好），先实现简单的例子，基于已有工作（博士论文，发在群里）、IC3（没听清楚）。</p>
<p>符：考虑现在比较好的方法，过程间结合图论的方法（不同的上下文调用到同一个图上，在图的算法上解决？已有很多工作做这个内容）。</p>
<p>陈：发文章需要带点新的内容，传统程序分析可能比较难，如现在流行的部分程序分析（partial），&#x3D;&#x3D;增量式程序分析（代码演化、变更时，未变更部分不用重新分析，只分析已修改部分）&#x3D;&#x3D;。</p>
<p>陈：过程间分析的瓶颈：代码量大需过程间时，在大规模和精度之间平衡？怎么找到平衡？韩国学者工作：selective上下文敏感。</p>
<p><img src="C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20230822101813289.png" alt="image-20230822101813289"></p>
<p>符：抽象解释解决嵌套循环问题困难，约束求解相对较好？</p>
<p>陈：应用场景的结合：数组（约束求解做过相关工作，但比较初级）、浮点（未做过相关工作，有待考虑）、过程间？</p>
<p>符：数组，自动分段，10年左右提出，进展较少。</p>
<p>符：浮点，基于约束的方法，相比于数组创新力更强。</p>
<p>陈：增量式程序分析：约束求解和抽象解释能否结合？（incremental）</p>
]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>chat</tag>
      </tags>
  </entry>
  <entry>
    <title>ikos的使用</title>
    <url>/2023/09/05/ikos%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="IKOS-Analyzer"><a href="#IKOS-Analyzer" class="headerlink" title="IKOS Analyzer"></a>IKOS Analyzer</h1><span id="more"></span>

<p>This folder contains the implementation of the analyzer.</p>
<h2 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h2><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#installation">Installation</a><ul>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#build-and-install">Build and Install</a></li>
<li><a href="#tests">Tests</a></li>
<li><a href="#documentation">Documentation</a></li>
</ul>
</li>
<li><a href="#how-to-run-ikos">How to run IKOS</a></li>
<li><a href="#analyze-a-whole-project-with-ikos-scan">Analyze a whole project with ikos-scan</a></li>
<li><a href="#examine-a-report-with-ikos-view">Examine a report with ikos-view</a></li>
<li><a href="#analysis-options">Analysis Options</a><ul>
<li><a href="#checks">Checks</a></li>
<li><a href="#numerical-abstract-domains">Numerical abstract domains</a></li>
<li><a href="#entry-points">Entry points</a></li>
<li><a href="#multi-threading">Multi-threading</a></li>
<li><a href="#optimization-level">Optimization level</a></li>
<li><a href="#inter-procedural-vs-intra-procedural">Inter-procedural vs Intra-procedural</a></li>
<li><a href="#fixpoint-engine-parameters">Fixpoint engine parameters</a></li>
<li><a href="#partitioning">Partitioning</a></li>
<li><a href="#hardware-addresses">Hardware addresses</a></li>
<li><a href="#other-analysis-options">Other analysis options</a></li>
</ul>
</li>
<li><a href="#report-options">Report Options</a><ul>
<li><a href="#format">Format</a></li>
<li><a href="#file">File</a></li>
<li><a href="#status-filter">Status Filter</a></li>
<li><a href="#analysis-filter">Analysis Filter</a></li>
<li><a href="#verbosity">Verbosity</a></li>
<li><a href="#other-report-options">Other report options</a></li>
</ul>
</li>
<li><a href="#apron-support">APRON Support</a></li>
<li><a href="#analysis-assumptions">Analysis Assumptions</a></li>
<li><a href="#analyze-an-embedded-software-requiring-a-cross-compiler">Analyze an embedded software requiring a cross-compiler</a></li>
<li><a href="#model-library-functions-to-reduce-warnings">Model library functions to reduce warnings</a></li>
<li><a href="#overview-of-the-source-code">Overview of the source code</a></li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The IKOS Analyzer is an abstract interpretation-based static analyzer that aims at proving the absence of runtime errors in C and C++ programs.</p>
<p>See <a href="#checks">Checks</a> for the full list of available checks.</p>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>IKOS Analyzer can be installed independently from the other components, but we recommend to build the analyzer from the root directory. To do so, follow the instructions in the root <a href="../README.md">README.md</a>.</p>
<h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><p>To build and run the analyzer, you will need the following dependencies:</p>
<ul>
<li>A C++ compiler that supports C++14 (gcc &gt;&#x3D; 4.9.2 or clang &gt;&#x3D; 3.4)</li>
<li>CMake &gt;&#x3D; 3.4.3</li>
<li>GMP &gt;&#x3D; 4.3.1</li>
<li>Boost &gt;&#x3D; 1.55</li>
<li>Python 2 &gt;&#x3D; 2.7.3 or Python 3 &gt;&#x3D; 3.3</li>
<li>SQLite &gt;&#x3D; 3.6.20</li>
<li>TBB &gt;&#x3D; 2</li>
<li>LLVM and Clang 14.0.x</li>
<li>(Optional) APRON &gt;&#x3D; 0.9.10</li>
<li>(Optional) Pygments</li>
<li>IKOS Core</li>
<li>IKOS AR</li>
<li>IKOS LLVM Frontend</li>
</ul>
<h3 id="Build-and-Install"><a href="#Build-and-Install" class="headerlink" title="Build and Install"></a>Build and Install</h3><p>To build and install the analyzer, run the following commands in the <code>analyzer</code> directory:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake \</span><br><span class="line">    -DCMAKE_INSTALL_PREFIX=/path/to/analyzer-install-directory \</span><br><span class="line">    -DLLVM_CONFIG_EXECUTABLE=/path/to/llvm/bin/llvm-config \</span><br><span class="line">    -DCORE_ROOT=/path/to/core-install-directory \</span><br><span class="line">    -DAR_ROOT=/path/to/ar-install-directory \</span><br><span class="line">    -DFRONTEND_LLVM_ROOT=/path/to/frontend-llvm-install-directory \</span><br><span class="line">    ..</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>

<h3 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h3><p>To build and run the tests, simply type:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make check</span><br></pre></td></tr></table></figure>

<h3 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h3><p>To build the documentation, you will need <a href="http://www.doxygen.org/">Doxygen</a>.</p>
<p>Then, simply type:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make doc</span><br><span class="line">$ open doc/html/index.html</span><br></pre></td></tr></table></figure>

<h2 id="How-to-run-IKOS"><a href="#How-to-run-IKOS" class="headerlink" title="How to run IKOS"></a>How to run IKOS</h2><p>Suppose we want to analyze the following C program in a file, called <em>loop.c</em>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>: <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span>: <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"> <span class="number">3</span>: <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"> <span class="number">4</span>:     <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="number">5</span>:     <span class="keyword">for</span> (;i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"> <span class="number">6</span>:         a[i] = i;</span><br><span class="line"> <span class="number">7</span>:     &#125;</span><br><span class="line"> <span class="number">8</span>:     a[i] = i;</span><br><span class="line"> <span class="number">9</span>:     <span class="built_in">printf</span>(<span class="string">&quot;%i&quot;</span>, a[i]);</span><br><span class="line"><span class="number">10</span>: &#125;</span><br></pre></td></tr></table></figure>

<p>To analyze this program with IKOS, simply run:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos loop.c</span><br></pre></td></tr></table></figure>

<p>You shall see the following output. IKOS reports two occurrences of buffer overflow at line 8 and 9.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] Compiling loop.c</span><br><span class="line">[*] Running ikos preprocessor</span><br><span class="line">[*] Running ikos analyzer</span><br><span class="line">[*] Translating LLVM bitcode to AR</span><br><span class="line">[*] Running liveness analysis</span><br><span class="line">[*] Running widening hint analysis</span><br><span class="line">[*] Running interprocedural value analysis</span><br><span class="line">[*] Analyzing entry point &#x27;main&#x27;</span><br><span class="line">[*] Checking properties for entry point &#x27;main&#x27;</span><br><span class="line"></span><br><span class="line"># Time stats:</span><br><span class="line">clang        : 0.037 sec</span><br><span class="line">ikos-analyzer: 0.023 sec</span><br><span class="line">ikos-pp      : 0.007 sec</span><br><span class="line"></span><br><span class="line"># Summary:</span><br><span class="line">Total number of checks                : 7</span><br><span class="line">Total number of unreachable checks    : 0</span><br><span class="line">Total number of safe checks           : 5</span><br><span class="line">Total number of definite unsafe checks: 2</span><br><span class="line">Total number of warnings              : 0</span><br><span class="line"></span><br><span class="line">The program is definitely UNSAFE</span><br><span class="line"></span><br><span class="line"># Results</span><br><span class="line">loop.c: In function &#x27;main&#x27;:</span><br><span class="line">loop.c:8:10: error: buffer overflow, trying to access index 10 of global variable &#x27;a&#x27; of 10 elements</span><br><span class="line">    a[i] = i;</span><br><span class="line">         ^</span><br><span class="line">loop.c: In function &#x27;main&#x27;:</span><br><span class="line">loop.c:9:18: error: buffer overflow, trying to access index 10 of global variable &#x27;a&#x27; of 10 elements</span><br><span class="line">    printf(&quot;%i&quot;, a[i]);</span><br><span class="line">                 ^</span><br></pre></td></tr></table></figure>

<p>The <code>ikos</code> command takes a source file (<code>.c</code>, <code>.cpp</code>) or a LLVM bitcode file (<code>.bc</code>) as input, analyzes it to find runtime errors (also called undefined behaviors), creates a result database <code>output.db</code> in the current working directory and prints a report.</p>
<p>In the report, each line has one of the following status:</p>
<ul>
<li><strong>safe</strong>: the statement is proven safe;</li>
<li><strong>error</strong>: the statement always results into an error (or is unreachable);</li>
<li><strong>unreachable</strong>: the statement is never executed;</li>
<li><strong>warning</strong> may mean three things:<ol>
<li>the statement results into an error for some executions, or</li>
<li>the static analyzer did not have enough information to conclude (check dependent on an external input, for instance), or</li>
<li>the static analyzer was not powerful enough to prove the absence of errors;</li>
</ol>
</li>
</ul>
<p>By default, ikos shows warnings and errors directly in your terminal, like a compiler would do.</p>
<p>If the analysis report is too big, you shall use:</p>
<ul>
<li><code>ikos-report output.db</code> to examine the report in your terminal</li>
<li><code>ikos-view output.db</code> to examine the report in a web interface</li>
</ul>
<h2 id="Analyze-a-whole-project-with-ikos-scan"><a href="#Analyze-a-whole-project-with-ikos-scan" class="headerlink" title="Analyze a whole project with ikos-scan"></a>Analyze a whole project with ikos-scan</h2><p>To run IKOS on a large project, you shall use ikos-scan.</p>
<p>ikos-scan is a command line utility that runs the static analyzer over a codebase after performing a regular build.</p>
<p>The ikos-scan command works by overriding the environment variables <code>CC</code> and <code>CXX</code> to intercept the compiler commands. Behind the scene, it builds the original program as well as the LLVM bitcode file that is necessary to run the analyzer.</p>
<p>To use ikos-scan, just prefix your build commands with <code>ikos-scan</code>. For instance, to analyze pkg-config:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tar xf pkg-config-0.29.2.tar.gz</span><br><span class="line">$ cd pkg-config-0.29.2</span><br><span class="line">$ ikos-scan ./configure</span><br><span class="line">[...]</span><br><span class="line">$ ikos-scan make</span><br><span class="line">[...]</span><br><span class="line">Analyze pkg-config? [Y/n]</span><br></pre></td></tr></table></figure>

<p>ikos-scan will produce a <code>.bc</code> file for each executable in your project. You can analyze them with specific options using <code>ikos [options] program.bc</code>.</p>
<h2 id="Examine-a-report-with-ikos-view"><a href="#Examine-a-report-with-ikos-view" class="headerlink" title="Examine a report with ikos-view"></a>Examine a report with ikos-view</h2><p>ikos-view provides a web interface to examine IKOS results. It is available directly in the analyzer.</p>
<p>The web interface shows the source code with syntax highlighting, and allows you to filter the warnings by checks.</p>
<p>To use ikos-view, first run the analyzer on your project to generate a result database <code>output.db</code>, then simply run:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos-view output.db</span><br></pre></td></tr></table></figure>

<p>It will start a web server. You can then launch your favorite web browser and visit <a href="http://localhost:8080/">http://localhost:8080</a></p>
<p>Note that if you want syntax highlighting, you will need to install <a href="http://pygments.org/">Pygments</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pip install --user pygments</span><br></pre></td></tr></table></figure>

<h2 id="Analysis-Options"><a href="#Analysis-Options" class="headerlink" title="Analysis Options"></a>Analysis Options</h2><p>This section describes the most relevant options of the analyzer.</p>
<h3 id="Checks"><a href="#Checks" class="headerlink" title="Checks"></a>Checks</h3><p>The list of available checks are:</p>
<ul>
<li><strong>buffer overflow analysis</strong>, <code>-a=boa</code>: checks for buffer overflows and out-of-bound array accesses.</li>
<li><strong>division by zero analysis</strong>, <code>-a=dbz</code>: checks for integer divisions by zero.</li>
<li><strong>null pointer analysis</strong>, <code>-a=nullity</code>: checks for null pointer dereferences.</li>
<li><strong>assertion prover</strong>, <code>-a=prover</code>: prove user-defined properties, using <code>__ikos_assert(condition)</code>.</li>
<li><strong>unaligned pointer analysis</strong>, <code>-a=upav</code>: checks for unaligned pointer dereferences.</li>
<li><strong>uninitialized variable analysis</strong>, <code>-a=uva</code>: checks for read of uninitialized variables.</li>
<li><strong>signed integer overflow analysis</strong>, <code>-a=sio</code>: checks for signed integer overflows.</li>
<li><strong>unsigned integer overflow analysis</strong>, <code>-a=uio</code>: checks for unsigned integer overflows.</li>
<li><strong>shift count analysis</strong>, <code>-a=shc</code>: checks for invalid shifts, where the amount shifted is greater or equal to the bit-width of the left operand, or less than zero.</li>
<li><strong>pointer overflow analysis</strong>, <code>-a=poa</code>: checks for pointer arithmetic overflows.</li>
<li><strong>pointer comparison analysis</strong>, <code>-a=pcmp</code>: checks for pointer comparisons between pointers referring to different objects.</li>
<li><strong>soundness analysis</strong>, <code>-a=sound</code>: checks for instructions that could make the analysis unsound, i.e miss bugs.</li>
<li><strong>function call analysis</strong>, <code>-a=fca</code>: checks for function calls through function pointers of the wrong type.</li>
<li><strong>dead code analysis</strong>, <code>-a=dca</code>: checks for unreachable statements.</li>
<li><strong>double free analysis</strong>, <code>-a=dfa</code>: checks for double free, invalid free, use after free and use after return.</li>
<li><strong>debugger</strong>, <code>-a=dbg</code>: prints debug information, using <code>__ikos_print_values(&quot;desc&quot;, x)</code> and <code>__ikos_print_invariant()</code>.</li>
<li><strong>memory watcher</strong>, <code>-a=watch</code>: prints memory writes at a given memory location, using <code>__ikos_watch_mem(ptr, size)</code>.</li>
</ul>
<p>By default, all the checks are enabled except:</p>
<ul>
<li><strong>unaligned pointer analysis</strong>, because it needs a congruence domain to generate meaningful results. See <a href="#numerical-abstract-domains">Numerical abstract domains</a>.</li>
<li><strong>unsigned integer overflow analysis</strong>, because it is not an undefined behavior according to the C standard.</li>
<li><strong>pointer overflow analysis</strong>, because it is redundant with the buffer overflow analysis.</li>
<li><strong>memory watcher</strong>, because it is slow.</li>
</ul>
<p>If you want to run specific checks, use the <code>-a</code> parameter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos -a=boa,nullity test.c</span><br></pre></td></tr></table></figure>

<p>Note that you can use the wildcard character <code>*</code>, <code>+</code> and <code>-</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos -a=&#x27;*,-sio&#x27; test.c</span><br></pre></td></tr></table></figure>

<p>In this example, all the checks are enabled except signed integer overflow checks.</p>
<h3 id="Numerical-abstract-domains"><a href="#Numerical-abstract-domains" class="headerlink" title="Numerical abstract domains"></a>Numerical abstract domains</h3><p>IKOS is based on the theory of <a href="https://www.di.ens.fr/~cousot/AI/IntroAbsInt.html">Abstract Interpretation</a>. The analysis uses a numerical abstract domain internally to model integer variables.</p>
<p>The list of available numerical abstract domains are:</p>
<ul>
<li><code>-d=interval</code>: The interval domain, see <a href="https://www.di.ens.fr/~cousot/COUSOTpapers/publications.www/CousotCousot-POPL-77-ACM-p238--252-1977.pdf">CC77</a>.</li>
<li><code>-d=congruence</code>: The congruence domain, see <a href="http://www.tandfonline.com/doi/abs/10.1080/00207168908803778">Gra89</a>.</li>
<li><code>-d=interval-congruence</code>: The reduced product of interval and congruence.</li>
<li><code>-d=dbm</code>: The Difference-Bound Matrices domain, see <a href="https://www-apr.lip6.fr/~mine/publi/article-mine-padoII.pdf">PADO01</a>.</li>
<li><code>-d=var-pack-dbm</code>: The Difference-Bound Matrices domain with variable packing, see <a href="https://seahorn.github.io/papers/vmcai16.pdf">VMCAI16</a>.</li>
<li><code>-d=var-pack-dbm-congruence</code>: The reduced product of DBM with variable packing and congruence.</li>
<li><code>-d=gauge</code>: The gauge domain, see <a href="https://ti.arc.nasa.gov/publications/4767/download/">CAV12</a>.</li>
<li><code>-d=gauge-interval-congruence</code>: The reduced product of gauge, interval and congruence.</li>
<li><code>-d=apron-interval</code>: The APRON interval domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_21.html#SEC54">Box</a>.</li>
<li><code>-d=apron-octagon</code>: The APRON octagon domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/oct_doc.html">Oct</a>.</li>
<li><code>-d=apron-polka-polyhedra</code>: The APRON polka polyhedra domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_25.html#SEC58">NewPolka</a>.</li>
<li><code>-d=apron-polka-linear-equalities</code>: The APRON polka linear equalities domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_25.html#SEC58">NewPolka</a>.</li>
<li><code>-d=apron-ppl-polyhedra</code>: The APRON PPL polyhedra domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_29.html#SEC65">PPL</a>.</li>
<li><code>-d=apron-ppl-linear-congruences</code>: The APRON PPL linear congruences domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_29.html#SEC65">PPL</a>.</li>
<li><code>-d=apron-pkgrid-polyhedra-lin-cong</code>: The APRON Pkgrid polyhedra and linear congruences domain, see <a href="http://apron.cri.ensmp.fr/library/0.9.10/apron/apron_33.html#SEC69">Pkgrid</a>.</li>
<li><code>-d=var-pack-apron-octagon</code>: The APRON octagon domain with variable packing.</li>
<li><code>-d=var-pack-apron-polka-polyhedra</code>: The APRON Polka polyhedra domain with variable packing.</li>
<li><code>-d=var-pack-apron-polka-linear-equalities</code>: The APRON Polka linear equalities domain with variable packing.</li>
<li><code>-d=var-pack-apron-ppl-polyhedra</code>: The APRON PPL polyhedra domain with variable packing.</li>
<li><code>-d=var-pack-apron-ppl-linear-congruences</code>: The APRON PPL linear congruences domain with variable packing.</li>
<li><code>-d=var-pack-apron-pkgrid-polyhedra-lin-cong</code>: The APRON Pkgrid polyhedra and linear congruences domain with variable packing.</li>
</ul>
<p>By default, IKOS uses the fastest and least precise numerical domain, the <strong>interval</strong> domain. If you want to run the analysis with a specific domain, use the <code>-d</code> parameter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos -d=var-pack-dbm test.c</span><br></pre></td></tr></table></figure>

<p>For most users, we recommend to analyze your project with the fastest and least precise domain (i.e, interval) first, and then try slower but more precise domains until the analysis is too long for you. This is the best way to reach a low rate of false positives (i.e, warnings).</p>
<p>Here is a list of numerical domains, sorted from the fastest and least precise to the slowest and most precise:</p>
<ul>
<li><code>-d=interval</code></li>
<li><code>-d=gauge-interval-congruence</code></li>
<li><code>-d=var-pack-dbm</code></li>
<li><code>-d=var-pack-apron-octagon</code></li>
<li><code>-d=var-pack-apron-ppl-polyhedra</code></li>
<li><code>-d=dbm</code></li>
<li><code>-d=apron-octagon</code></li>
<li><code>-d=apron-ppl-polyhedra</code></li>
</ul>
<p>You should consider running different analyses in this specific order.</p>
<p>Please also note that:</p>
<ul>
<li>Floating point variables are safely ignored.</li>
<li>In order to use the <strong>APRON</strong> abstract domain, you need to build IKOS with APRON first. See <a href="#apron-support">APRON Support</a>.</li>
</ul>
<h3 id="Entry-points"><a href="#Entry-points" class="headerlink" title="Entry points"></a>Entry points</h3><p>By default, the analyzer assumes the entry point of the program is <code>main</code>. You can specify a list of entry points using the <code>--entry-points</code> parameter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos --entry-points=foo,bar test.c</span><br></pre></td></tr></table></figure>

<p>IKOS analyses each entry point independently, as if they were running in different processes.</p>
<h3 id="Multi-threading"><a href="#Multi-threading" class="headerlink" title="Multi-threading"></a>Multi-threading</h3><p>The analyzer can use multi-threading to speed up the analysis. You can specify the number of threads to use with the <code>--jobs</code> or <code>-j</code> parameter:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos --jobs=4 test.c</span><br></pre></td></tr></table></figure>

<p>Use <code>-j</code> to use all available threads. By default, the analyzer only uses one thread.</p>
<p><strong>Warning:</strong> APRON numerical abstract domains are currently NOT thread-safe and might cause crashes.</p>
<h3 id="Optimization-level"><a href="#Optimization-level" class="headerlink" title="Optimization level"></a>Optimization level</h3><p>The parameter <code>--opt</code> allows you to set the optimization level. Optimizations are performed by running a set of LLVM passes on the analyzed code.</p>
<p>Available levels are:</p>
<ul>
<li><strong>none</strong>: Disable all optimizations.</li>
<li><strong>basic</strong>: Basic set of optimizations (similar to <code>-O1</code>). This is the default value.</li>
<li><strong>aggressive</strong>: Aggressive optimizations (similar to <code>-O3</code>). This is not recommended since it might hide errors. The translation from LLVM to AR might fail because of unsupported instructions.</li>
</ul>
<h3 id="Inter-procedural-vs-Intra-procedural"><a href="#Inter-procedural-vs-Intra-procedural" class="headerlink" title="Inter-procedural vs Intra-procedural"></a>Inter-procedural vs Intra-procedural</h3><p>An <strong>inter-procedural</strong> analysis analyzes a function considering its call stack while an <strong>intra-procedural</strong> analysis ignores it. The former produces more precise results than the latter but it is often much more expensive.</p>
<p>By default, IKOS performs an inter-procedural analysis. Use <code>--proc=intra</code> to perform an intra-procedural analysis.</p>
<h3 id="Fixpoint-engine-parameters"><a href="#Fixpoint-engine-parameters" class="headerlink" title="Fixpoint engine parameters"></a>Fixpoint engine parameters</h3><p>The analyzer uses the theory of Abstract Interpretation to compute a fixpoint of the semantic of the program. The fixpoint engine can be tuned using several parameters.</p>
<p>When visiting a loop, the engine will first compute a fixed number of iterations, then use a widening strategy periodically to approximate the behavior of the loop, until convergence.</p>
<p>The fixed number of iterations performed before the widening strategy can be set using <code>--widening-delay</code>. By default, it is 1.</p>
<p>The period of the widening strategy can be set using <code>--widening-period</code>. By default, it is 1, thus the widening strategy is always applied.</p>
<p>The widening strategy can be set using <code>--widening-strategy=</code>:</p>
<ul>
<li><strong>widen</strong>: Use the widening operator to approximate the behavior of the loop (default)</li>
<li><strong>join</strong>: Use the join operator, effectively computing all iterations (very slow)</li>
</ul>
<p>After reaching a fixpoint, the engine will perform extra iterations to regain precision using a narrowing strategy, until convergence.</p>
<p>The narrowing strategy can be set using <code>--narrowing-strategy=</code>:</p>
<ul>
<li><strong>narrow</strong>: Use the narrowing operator, ensuring a fast convergence</li>
<li><strong>meet</strong>: Use the meet operator, convergence can be slow</li>
<li><strong>auto</strong>: Use the narrowing operator if available for the numerical abstract domain. Otherwise, perform 2 iterations using the meet operator (default)</li>
</ul>
<p>You can specify a fixed number of narrowing iterations to perform using <code>--narrowing-iterations</code>.</p>
<p>You can specify the widening delay for a given function using <code>--widening-delay-functions</code>. For instance, <code>--widening-delay-functions=&quot;main:10, f:32&quot;</code>.</p>
<h3 id="Partitioning"><a href="#Partitioning" class="headerlink" title="Partitioning"></a>Partitioning</h3><p>The analyzer can use abstract domain partitioning based on integer variables using the <code>--partitioning</code> option.</p>
<p>Using <code>--partitioning=return</code>, the analyzer will split the states at the end of a function according to the function return codes.</p>
<p>This can be used to improve the precision of the analysis on the following code pattern:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> status = xxx();</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Error in xxx</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = yyy();</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">// Error in yyy</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    zzz();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Instead of performing the abstract union and lose precision, the analyzer will keep 3 invariants for each outcome of the <code>init</code> function.</p>
<p>Using <code>--partitioning=manual</code>, the analyzer will split the states according to the values of a given integer variable, set with <code>__ikos_partitioning_var_int(x)</code>.</p>
<p>By default, partitioning is disabled.</p>
<h3 id="Hardware-addresses"><a href="#Hardware-addresses" class="headerlink" title="Hardware addresses"></a>Hardware addresses</h3><p>In C code for embedded systems, it is usual to read or write at specific addresses to communicate with the hardware. By default, IKOS treats memory accesses at specific addresses as errors.</p>
<p>You can provide the <code>--hardware-addresses</code> parameter to specify a range of valid memory addresses:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos --hardware-addresses=0x20-0x40 project.bc</span><br></pre></td></tr></table></figure>

<p>During the analysis, IKOS will assume that memory accesses in the range <code>[0x20, 0x40]</code> (in bytes, inclusive) are safe.</p>
<h3 id="Other-analysis-options"><a href="#Other-analysis-options" class="headerlink" title="Other analysis options"></a>Other analysis options</h3><ul>
<li><code>--globals-init</code>: use the given strategy for initialization of global variables.</li>
<li><code>--no-init-globals</code>: disable global variable initialization for the given entry points.</li>
<li><code>--no-liveness</code>: disable the liveness analysis.</li>
<li><code>--no-pointer</code>: disable the pointer analysis.</li>
<li><code>--no-widening-hints</code>: disable the detection of widening hints.</li>
<li><code>--no-fixpoint-cache</code>: disable the cache of fixpoint for called functions.</li>
<li><code>--no-checks</code>: disable all the checks</li>
<li><code>--argc</code>: specify the value of <code>argc</code> for the analysis.</li>
<li><code>--no-libc</code>: do not use libc intrinsics. Useful for bare metal programming.</li>
</ul>
<p>See <code>ikos --help</code> for more information.</p>
<h2 id="Report-Options"><a href="#Report-Options" class="headerlink" title="Report Options"></a>Report Options</h2><p>This section describes the most relevant report options supported by <code>ikos</code> and <code>ikos-report</code>.</p>
<h3 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h3><p>You can specify the format of the report using the <code>--format</code> (or <code>-f</code>) parameter.</p>
<p>Available formats are:</p>
<ul>
<li><strong>text</strong>: Text format, convenient for the terminal;</li>
<li><strong>csv</strong>: CSV format, convenient for spreadsheet import;</li>
<li><strong>json</strong>: JSON format, convenient for developers.</li>
<li><strong>web</strong>: Web interface, using ikos-view.</li>
<li><strong>no</strong>: Disable the report.</li>
</ul>
<p>By default, if the report has less than 15 entries, it will be printed out using the text format.</p>
<p>We recommend to use <a href="#examine-a-report-with-ikos-view">ikos-view</a> to examine reports of large projects.</p>
<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>By default, the report is generated on the standard output. You can write it into a file using <code>--report-file=/path/to/report</code></p>
<h3 id="Status-Filter"><a href="#Status-Filter" class="headerlink" title="Status Filter"></a>Status Filter</h3><p>Use <code>--status-filter</code> to filter unwanted checks.</p>
<p>Possible values are: <strong>error</strong>, <strong>warning</strong>, <strong>safe</strong>, <strong>unreachable</strong>.</p>
<p>Note that you can use the wildcard character <code>*</code>, <code>+</code> and <code>-</code>.</p>
<h3 id="Analysis-Filter"><a href="#Analysis-Filter" class="headerlink" title="Analysis Filter"></a>Analysis Filter</h3><p>Use <code>--analyses-filter</code> to filter unwanted checks.</p>
<p>Possible values are described in <a href="#checks">Checks</a>.</p>
<p>Note that you can use the wildcard character <code>*</code>, <code>+</code> and <code>-</code>. For instance:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ikos-report --analyses-filter=&#x27;*,-boa&#x27; output.db</span><br></pre></td></tr></table></figure>

<p>This will generate a report with all the checks, except buffer overflows.</p>
<h3 id="Verbosity"><a href="#Verbosity" class="headerlink" title="Verbosity"></a>Verbosity</h3><p>Use <code>--report-verbosity [1-4]</code> to specify the verbosity. A verbosity of one will give you very short messages, where a verbosity of 4 will provide you with all the information the analyzer has.</p>
<h4 id="Other-report-options"><a href="#Other-report-options" class="headerlink" title="Other report options"></a>Other report options</h4><p>See <code>ikos-report --help</code> for more information.</p>
<h2 id="APRON-Support"><a href="#APRON-Support" class="headerlink" title="APRON Support"></a>APRON Support</h2><p><a href="http://apron.cri.ensmp.fr/library/">APRON</a> is a C library for static analysis using Abstract Interpretation. It implements several complex abstract domains, such as the Polyhedra domain.</p>
<p>IKOS provides a wrapper for APRON, allowing you to use any APRON abstract domain in the analyzer.</p>
<p>To use APRON, first download, build and install it. Consider using the svn trunk. You will also need to build APRON with <a href="http://bugseng.com/products/ppl/">Parma Polyhedra Library</a> enabled. Set <code>HAS_PPL = 1</code> and define <code>PPL_PREFIX</code> in your <code>Makefile.config</code></p>
<p>Now, to build IKOS with APRON support, just provide the option <code>-DAPRON_ROOT=/path/to/apron-install</code> when running cmake. For instance:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake \</span><br><span class="line">    -DCMAKE_INSTALL_PREFIX=/path/to/ikos-install \</span><br><span class="line">    -DAPRON_ROOT=/path/to/apron-install \</span><br><span class="line">    ..</span><br></pre></td></tr></table></figure>

<p>See <a href="#numerical-abstract-domains">Numerical abstract domains</a> for the list of numerical abstract domains.</p>
<h2 id="Analysis-Assumptions"><a href="#Analysis-Assumptions" class="headerlink" title="Analysis Assumptions"></a>Analysis Assumptions</h2><p>This section describes the assumptions made by the analyzer about the code.</p>
<p>First, the analyzed code is compiled with the <strong>Clang</strong> compiler using the host target. Thus, Clang is responsible for specifying the data model (size of types), the data layout (alignments), the endianness, the signedness of <code>char</code>, the semantic of floating points, etc. depending on the host target. The analyzer uses the generated LLVM bitcode from Clang. This means that you can get different results depending on your host target.</p>
<p>During the analysis, the analyzer will make the following assumptions:</p>
<ul>
<li>The program is single-threaded.</li>
<li>The program does not receive signals.</li>
<li>The program does not receive interrupts.</li>
<li>Extern functions (without implementation) do not update global variables.</li>
<li>Extern functions can write on their pointer parameters, but only with one level of indirection:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>** p)</span>; <span class="comment">// Assume to write on *p but not **p</span></span><br></pre></td></tr></table></figure></li>
<li>Extern functions do not call user-defined functions (no callbacks).</li>
<li>Extern functions can throw exceptions.</li>
<li>Extern functions return well-initialized values.</li>
<li>Recursive function calls can update any value in memory.</li>
<li>Recursive function calls can throw exceptions.</li>
<li>Recursive function calls return well-initialized values.</li>
<li>Assembly codes are treated as extern function calls.</li>
<li>C standard library functions do not throw exceptions.</li>
</ul>
<h2 id="Analyze-an-embedded-software-requiring-a-cross-compiler"><a href="#Analyze-an-embedded-software-requiring-a-cross-compiler" class="headerlink" title="Analyze an embedded software requiring a cross-compiler"></a>Analyze an embedded software requiring a cross-compiler</h2><p>Running the analyzer on an embedded software that requires a cross-compiler can be challenging.</p>
<p>You should try to use <a href="#analyze-a-whole-project-with-ikos-scan">ikos-scan</a> first, but this will probably fail with compiler errors.</p>
<p>To solve this issue, you will need to create an alternative build file that compiles everything to LLVM bitcode. For instance, if you use <code>make</code>, you could create <code>Makefile.llvm</code> based on <code>Makefile</code>.</p>
<p>In the alternative build file:</p>
<ul>
<li>Locate the build rules that generate intermediate object files (<code>.o</code>).</li>
<li>In these rules, add the flag <code>-save-temps=obj</code> to the cross-compiler commands. This will generate a preprocessed file <code>.i</code> in addition to the <code>.o</code>.</li>
<li>At the end of these rules, add a command to compile the preprocessed file <code>.i</code> to LLVM bitcode <code>.bc</code> using: <code>clang -c -emit-llvm -D_FORTIFY_SOURCE=0 -D__IKOS__ -g -O0 -Xclang -disable-O0-optnone &lt;file.i&gt; -o &lt;file.bc&gt;</code>.</li>
<li>Locate the build rules that link the intermediate object files into binaries or shared libraries.</li>
<li>At the end of these rules, link the LLVM bitcodes <code>.bc</code> together using <code>llvm-link</code>.</li>
</ul>
<p>For instance, in <code>Makefile.llvm</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%.o: %.c</span><br><span class="line">	$(CC) -c $(CPPFLAGS) $(CFLAGS) -save-temps=obj $&lt; -o $@</span><br><span class="line">	clang -c -emit-llvm -D_FORTIFY_SOURCE=0 -D__IKOS__ -g -O0 -Xclang -disable-O0-optnone $(subst .o,.i,$@) -o $(subst .o,.bc,$@)</span><br><span class="line"></span><br><span class="line">program: a.o b.o</span><br><span class="line">	$(CC) $(CPPFLAGS) $(CFLAGS) a.o b.o -o $@</span><br><span class="line">	llvm-link a.bc b.bc -o $@.bc</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -f *.o *.i *.s *.bc</span><br></pre></td></tr></table></figure>

<p>Then, run your build tool using the alternative build file to generate the LLVM bitcode (e.g, <code>make -f Makefile.llvm</code>).</p>
<p>You can finally analyze your program by running ikos on the generated LLVM bitcode file (e.g, <code>ikos program.bc</code>).</p>
<h2 id="Model-library-functions-to-reduce-warnings"><a href="#Model-library-functions-to-reduce-warnings" class="headerlink" title="Model library functions to reduce warnings"></a>Model library functions to reduce warnings</h2><p>The analyzer doesn’t require the libraries used by your program. It will consider library functions as unknown extern functions and make some <a href="#analysis-assumptions">assumptions</a> about them.</p>
<p>The analyzer will produce a warning for each call to an unknown function. You can use <code>ikos-report --analyses-filter=sound output.db</code> to list these warnings, or filter the “ignored call side effect” in ikos-view.</p>
<p>You can model library functions to improve the precision of the analysis and reduce the number of warnings. To model a library function, simply write a small implementation for it and link it in your program. This is usually called a “stub”.</p>
<p>For instance, a stub for <code>fgets</code> could be:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ikos/analyzer/intrinsic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">fgets</span><span class="params">(<span class="type">char</span>* <span class="keyword">restrict</span> str, <span class="type">int</span> size, FILE* <span class="keyword">restrict</span> stream)</span> &#123;</span><br><span class="line">    __ikos_assert(size &gt;= <span class="number">0</span>);</span><br><span class="line">    __ikos_forget_mem(stream, <span class="keyword">sizeof</span>(FILE));</span><br><span class="line">    __ikos_abstract_mem(str, size);</span><br><span class="line">    <span class="keyword">return</span> __ikos_nondet_int() ? str : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The analyzer provides helper functions to implement these stubs, see <a href="include/ikos/analyzer/intrinsic.h">include&#x2F;ikos&#x2F;analyzer&#x2F;intrinsic.h</a></p>
<p>Note that most functions of the C standard library are already modeled, but not all of them.</p>
<h2 id="Overview-of-the-source-code"><a href="#Overview-of-the-source-code" class="headerlink" title="Overview of the source code"></a>Overview of the source code</h2><p>The following illustrates the directory structure of this folder:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── doc</span><br><span class="line">│   └── doxygen</span><br><span class="line">│       └── latex</span><br><span class="line">├── include</span><br><span class="line">│   └── ikos</span><br><span class="line">│       └── analyzer</span><br><span class="line">│           ├── analysis</span><br><span class="line">│           │   ├── execution_engine</span><br><span class="line">│           │   ├── pointer</span><br><span class="line">│           │   └── value</span><br><span class="line">│           ├── checker</span><br><span class="line">│           ├── database</span><br><span class="line">│           │   └── table</span><br><span class="line">│           ├── json</span><br><span class="line">│           ├── support</span><br><span class="line">│           └── util</span><br><span class="line">├── python</span><br><span class="line">│   └── ikos</span><br><span class="line">│       └── view</span><br><span class="line">│           ├── static</span><br><span class="line">│           │   ├── css</span><br><span class="line">│           │   └── js</span><br><span class="line">│           └── template</span><br><span class="line">├── script</span><br><span class="line">├── src</span><br><span class="line">│   ├── analysis</span><br><span class="line">│   │   ├── pointer</span><br><span class="line">│   │   └── value</span><br><span class="line">│   │       └── machine_int_domain</span><br><span class="line">│   ├── checker</span><br><span class="line">│   ├── database</span><br><span class="line">│   │   └── table</span><br><span class="line">│   ├── json</span><br><span class="line">│   └── util</span><br><span class="line">└── test</span><br><span class="line">    └── regression</span><br></pre></td></tr></table></figure>

<h4 id="doc-x2F"><a href="#doc-x2F" class="headerlink" title="doc&#x2F;"></a>doc&#x2F;</h4><p>Contains Doxygen files.</p>
<h4 id="include-x2F"><a href="#include-x2F" class="headerlink" title="include&#x2F;"></a>include&#x2F;</h4><ul>
<li><a href="include/ikos/analyzer/intrinsic.h">include&#x2F;ikos&#x2F;analyzer&#x2F;intrinsic.h</a> contains definition of IKOS intrinsics that can be used in analyzed source code.</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-analysis"><a href="#include-x2F-ikos-x2F-analyzer-x2F-analysis" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;analysis"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;analysis</h5><ul>
<li><p><a href="include/ikos/analyzer/analysis/call_context.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;call_context.hpp</a> contains definition of a call context and the call context factory.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/context.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;context.hpp</a> contains definition of the global context of the analyzer.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/literal.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;literal.hpp</a> contains definition of the literal factory. It converts an AR operand to an AR-independent format.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/liveness.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;liveness.hpp</a> contains definition of the liveness analysis. It computes the set of live and dead variables for all functions.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/memory_location.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;memory_location.hpp</a> contains definition of symbolic memory locations (global, stack, heap-allocated, etc), and the memory location factory.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/option.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;option.hpp</a> contains definition of analysis options.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/variable.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;variable.hpp</a> contains definition of variables (local, global, etc), and the variable factory.</p>
</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-execution-engine"><a href="#include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-execution-engine" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine</h5><ul>
<li><p><a href="include/ikos/analyzer/analysis/execution_engine/context_insensitive.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine&#x2F;context_insensitive.hpp</a> contains definition of <code>ContextInsensitiveCallExecutionEngine</code>, a call execution engine for context-insensitive analyses.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/execution_engine/engine.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine&#x2F;engine.hpp</a> contains definition of base classes for execution engines. It defines an API to execute AR statements.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/execution_engine/inliner.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine&#x2F;inliner.hpp</a> contains definition of <code>InlineCallExecutionEngine</code>, a call execution engine performing dynamic inlining.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/execution_engine/numerical.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;execution_engine&#x2F;numerical.hpp</a> contains definition of <code>NumericalExecutionEngine</code>, the main execution engine of the analyzer. It executes AR statements on an abstract domain.</p>
</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-pointer"><a href="#include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-pointer" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer</h5><ul>
<li><p><a href="include/ikos/analyzer/analysis/pointer/constraint.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer&#x2F;constraint.hpp</a> contains definition of <code>PointerConstraintsGenerator</code>, a generator of pointer constraints given an AR function or global variable.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/pointer/function.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer&#x2F;function.hpp</a> contains definition of a function pointer analysis.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/pointer/pointer.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;pointer&#x2F;pointer.hpp</a> contains definition of a pointer analysis.</p>
</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-value"><a href="#include-x2F-ikos-x2F-analyzer-x2F-analysis-x2F-value" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value</h5><ul>
<li><p><a href="include/ikos/analyzer/analysis/value/abstract_domain.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value&#x2F;abstract_domain.hpp</a> contains definition the abstract domain used during the value analysis.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/value/interprocedural.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value&#x2F;interprocedural.hpp</a> contains definition the interprocedural value analysis.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/value/intraprocedural.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value&#x2F;intraprocedural.hpp</a> contains definition the intraprocedural value analysis.</p>
</li>
<li><p><a href="include/ikos/analyzer/analysis/value/machine_int_domain.hpp">include&#x2F;ikos&#x2F;analyzer&#x2F;analysis&#x2F;value&#x2F;machine_int_domain.hpp</a> contains definition the machine integer abstract domain used during the value analysis.</p>
</li>
</ul>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-checker"><a href="#include-x2F-ikos-x2F-analyzer-x2F-checker" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;checker"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;checker</h5><p>Contains definition of the different checks on the code (buffer overflow, division by zero, etc.), given the result of an analysis.</p>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-database-x2F-table"><a href="#include-x2F-ikos-x2F-analyzer-x2F-database-x2F-table" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;database&#x2F;table"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;database&#x2F;table</h5><p>Contains definition of the different output database tables.</p>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-json"><a href="#include-x2F-ikos-x2F-analyzer-x2F-json" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;json"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;json</h5><p>Contains definition of a JSON library.</p>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-support"><a href="#include-x2F-ikos-x2F-analyzer-x2F-support" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;support"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;support</h5><p>Contains various helpers, e.g, assertions.</p>
<h5 id="include-x2F-ikos-x2F-analyzer-x2F-util"><a href="#include-x2F-ikos-x2F-analyzer-x2F-util" class="headerlink" title="include&#x2F;ikos&#x2F;analyzer&#x2F;util"></a>include&#x2F;ikos&#x2F;analyzer&#x2F;util</h5><p>Contains definition of utilities for the analyzer, e.g, logging, colors, timers, etc.</p>
<h4 id="python-x2F"><a href="#python-x2F" class="headerlink" title="python&#x2F;"></a>python&#x2F;</h4><ul>
<li><p><a href="python/ikos/analyzer.py">python&#x2F;ikos&#x2F;analyzer.py</a> contains implementation of the <code>ikos</code> command line tool.</p>
</li>
<li><p><a href="python/ikos/report.py">python&#x2F;ikos&#x2F;report.py</a> contains implementation of the <code>ikos-report</code> command line tool.</p>
</li>
<li><p><a href="python/ikos/settings.py.in">python&#x2F;ikos&#x2F;settings.py.in</a> contains implementation of the <code>ikos-config</code> command line tool.</p>
</li>
<li><p><a href="python/ikos/view.py">python&#x2F;ikos&#x2F;view.py</a> contains implementation of the <code>ikos-view</code> command line tool.</p>
</li>
</ul>
<h5 id="python-x2F-ikos-x2F-analyzer-x2F-view"><a href="#python-x2F-ikos-x2F-analyzer-x2F-view" class="headerlink" title="python&#x2F;ikos&#x2F;analyzer&#x2F;view"></a>python&#x2F;ikos&#x2F;analyzer&#x2F;view</h5><p>Contains the web resources for ikos-view. It includes HTML, CSS and JS code.</p>
<h4 id="script-x2F"><a href="#script-x2F" class="headerlink" title="script&#x2F;"></a>script&#x2F;</h4><p>Contains python entry points for the command line tools.</p>
<h4 id="src-x2F"><a href="#src-x2F" class="headerlink" title="src&#x2F;"></a>src&#x2F;</h4><p>Contains implementation files, following the structure of <code>include/ikos/analyzer</code>.</p>
<ul>
<li><a href="src/ikos_analyzer.cpp">src&#x2F;ikos_analyzer.cpp</a> contains the implementation of <code>ikos-analyzer</code>. This is the entry point for all analyses.</li>
</ul>
]]></content>
      <categories>
        <category>ikos</category>
      </categories>
      <tags>
        <tag>ikos</tag>
      </tags>
  </entry>
  <entry>
    <title>读IKOS文档</title>
    <url>/2023/09/06/%E8%AF%BBIKOS%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="读IKOS文档"><a href="#读IKOS文档" class="headerlink" title="读IKOS文档"></a>读IKOS文档</h2><span id="more"></span>

<p>主要记录IKOS文档的信息，以备自己之后做更改时，可以更好地回忆。</p>
<h3 id="前端工作部分"><a href="#前端工作部分" class="headerlink" title="前端工作部分"></a>前端工作部分</h3><p><img src="/paper_source/%E8%AF%BBIKOS%E6%96%87%E6%A1%A3/%E5%89%8D%E7%AB%AF%E4%BF%AE%E6%94%B9LLVM2AR.jpg" alt="image-20230906195706369"></p>
<p>前端的工作主要是在两个地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include/ikos/frontend/llvm/import contains definition of the translation from LLVM to AR.</span><br><span class="line">src/import contains implementation of the translation from LLVM to AR.</span><br></pre></td></tr></table></figure>

<p>这是肯定要做修改的部分，后续可能需要修改下游的一些关联数据。但是目前设计的思路是先将原来进行的转换部分先读懂。如果按照原来的思路能进行便按照最简单的方法进行，否则全部重新设计工作量太大。</p>
]]></content>
      <categories>
        <category>ikos</category>
        <category>learn</category>
      </categories>
      <tags>
        <tag>project</tag>
        <tag>ikos</tag>
      </tags>
  </entry>
  <entry>
    <title>LLVMIR2AR</title>
    <url>/2023/09/06/LLVMIR2AR%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="IKOS-LLVM-Frontend"><a href="#IKOS-LLVM-Frontend" class="headerlink" title="IKOS LLVM Frontend"></a>IKOS LLVM Frontend</h1><span id="more"></span>

<p>This folder contains implementation of the LLVM frontend for IKOS.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The LLVM frontend implements:</p>
<ul>
<li><code>ikos-pp</code>, a LLVM bitcode pre-processor for static analysis</li>
<li><code>llvm-to-ar</code>, a library to translate LLVM bitcode to Abstract Representation (AR)</li>
<li><code>ikos-import</code>, a translator from LLVM bitcode to AR, used for debugging purpose.</li>
</ul>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>IKOS LLVM Frontend contains a C++ library and executables. It can be installed independently from the other components.</p>
<h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><p>To build IKOS LLVM Frontend, you will need the following dependencies:</p>
<ul>
<li>A C++ compiler that supports C++14 (gcc &gt;&#x3D; 4.9.2 or clang &gt;&#x3D; 3.4)</li>
<li>CMake &gt;&#x3D; 3.4.3</li>
<li>GMP &gt;&#x3D; 4.3.1</li>
<li>Boost &gt;&#x3D; 1.55</li>
<li>LLVM 14.0.x</li>
<li>IKOS Core</li>
<li>IKOS AR</li>
</ul>
<h3 id="Build-and-Install"><a href="#Build-and-Install" class="headerlink" title="Build and Install"></a>Build and Install</h3><p>To build and install IKOS LLVM Frontend, run the following commands in the <code>frontend/llvm</code> directory:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake \</span><br><span class="line">    -DCMAKE_INSTALL_PREFIX=/path/to/frontend-llvm-install-directory \</span><br><span class="line">    -DLLVM_CONFIG_EXECUTABLE=/path/to/llvm/bin/llvm-config \</span><br><span class="line">    -DCORE_ROOT=/path/to/core-install-directory \</span><br><span class="line">    -DAR_ROOT=/path/to/ar-install-directory \</span><br><span class="line">    ..</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br></pre></td></tr></table></figure>

<h3 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h3><p>To build and run the tests, simply type:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make check</span><br></pre></td></tr></table></figure>

<h2 id="Running-the-LLVM-Frontend-Tools"><a href="#Running-the-LLVM-Frontend-Tools" class="headerlink" title="Running the LLVM Frontend Tools"></a>Running the LLVM Frontend Tools</h2><h3 id="lib-x2F-libikos-llvm-to-ar-a"><a href="#lib-x2F-libikos-llvm-to-ar-a" class="headerlink" title="lib&#x2F;libikos-llvm-to-ar.a"></a>lib&#x2F;libikos-llvm-to-ar.a</h3><p><code>llvm-to-ar</code> is a library to translate LLVM bitcode to AR, used by the analyzer and <code>ikos-import</code>.</p>
<h3 id="ikos-pp"><a href="#ikos-pp" class="headerlink" title="ikos-pp"></a>ikos-pp</h3><p><code>ikos-pp</code> is a LLVM bitcode pre-processor for static analysis.</p>
<p>It is similar to the LLVM <code>opt</code> command, see <a href="https://llvm.org/docs/CommandGuide/opt.html">https://llvm.org/docs/CommandGuide/opt.html</a></p>
<p>See <code>ikos-pp -help</code> for more information.</p>
<h3 id="ikos-import"><a href="#ikos-import" class="headerlink" title="ikos-import"></a>ikos-import</h3><p><code>ikos-import</code> is a translator from LLVM bitcode to AR, used for debugging purpose.</p>
<p>See <code>ikos-import -help</code> for more information.</p>
<h2 id="Overview-of-the-source-code"><a href="#Overview-of-the-source-code" class="headerlink" title="Overview of the source code"></a>Overview of the source code</h2><p>The following illustrates the directory structure of this folder:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── ikos</span><br><span class="line">│       └── frontend</span><br><span class="line">│           └── llvm</span><br><span class="line">│               └── import</span><br><span class="line">├── src</span><br><span class="line">│   ├── import</span><br><span class="line">│   └── pass</span><br><span class="line">└── test</span><br><span class="line">    └── regression</span><br><span class="line">        ├── import</span><br><span class="line">        │   ├── aggressive_optimization</span><br><span class="line">        │   ├── basic_optimization</span><br><span class="line">        │   └── no_optimization</span><br><span class="line">        └── pass</span><br><span class="line">            ├── lower_cst_expr</span><br><span class="line">            ├── lower_select</span><br><span class="line">            ├── remove_printf_calls</span><br><span class="line">            └── remove_unreachable_blocks</span><br></pre></td></tr></table></figure>

<h4 id="include-x2F"><a href="#include-x2F" class="headerlink" title="include&#x2F;"></a>include&#x2F;</h4><ul>
<li><p><a href="include/ikos/frontend/llvm/import">include&#x2F;ikos&#x2F;frontend&#x2F;llvm&#x2F;import</a> contains definition of the translation from LLVM to AR.</p>
</li>
<li><p><a href="include/ikos/frontend/llvm/pass.hpp">include&#x2F;ikos&#x2F;frontend&#x2F;llvm&#x2F;pass.hpp</a> contains definition of LLVM passes for helping static analysis.</p>
</li>
</ul>
<h4 id="src-x2F"><a href="#src-x2F" class="headerlink" title="src&#x2F;"></a>src&#x2F;</h4><ul>
<li><p><a href="src/ikos_import.cpp">src&#x2F;ikos_import.cpp</a> contains implementation of <code>ikos-import</code>.</p>
</li>
<li><p><a href="src/ikos_pp.cpp">src&#x2F;ikos_pp.cpp</a> contains implementation of <code>ikos-pp</code>.</p>
</li>
<li><p><a href="src/import">src&#x2F;import</a> contains implementation of the translation from LLVM to AR.</p>
</li>
<li><p><a href="src/pass">src&#x2F;pass</a> contains implementation of LLVM passes for helping static analysis.</p>
</li>
</ul>
<h4 id="test-x2F"><a href="#test-x2F" class="headerlink" title="test&#x2F;"></a>test&#x2F;</h4><p>Contains regression tests.</p>
]]></content>
      <categories>
        <category>ikos</category>
      </categories>
      <tags>
        <tag>ikos</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类核心知识</title>
    <url>/2023/09/08/C-%E7%B1%BB%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="C-类部分的核心知识"><a href="#C-类部分的核心知识" class="headerlink" title="C++类部分的核心知识"></a>C++类部分的核心知识</h1><span id="more"></span>

<h2 id="类模板的定义"><a href="#类模板的定义" class="headerlink" title="类模板的定义"></a>类模板的定义</h2><p>可以像定义函数模板一样定义类模板。</p>
<p>由于类模板包含类型参数，因此又称为参数化的类。如果说类是对象的抽象，对象是类的实例，则类模板是类的抽象，类是类模板的实例。利用类模板可以建立支持各种数据类型的类。</p>
<p>类模板在表示数组、向量、列表、队列、栈、矩阵等数据结构时显得特别重要，因为这些数据结构的表示和算法的选择不受其所包含的元素的类型的影响</p>
]]></content>
      <categories>
        <category>learn</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
