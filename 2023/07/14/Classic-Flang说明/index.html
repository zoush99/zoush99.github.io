<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zoush99.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Flang的使用情况">
<meta property="og:type" content="article">
<meta property="og:title" content="Classic-Flang说明">
<meta property="og:url" content="https://zoush99.github.io/2023/07/14/Classic-Flang%E8%AF%B4%E6%98%8E/index.html">
<meta property="og:site_name" content="zoush99&#39;s blog">
<meta property="og:description" content="Flang的使用情况">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zoush99.github.io/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/%E5%AE%89%E8%A3%85Flang.jpg">
<meta property="og:image" content="https://zoush99.github.io/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/Center.jpg">
<meta property="og:image" content="https://zoush99.github.io/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/cfg.jpg">
<meta property="og:image" content="https://zoush99.github.io/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/callCFG.jpg">
<meta property="article:published_time" content="2023-07-14T02:38:24.000Z">
<meta property="article:modified_time" content="2023-09-07T13:28:20.269Z">
<meta property="article:author" content="zoush99">
<meta property="article:tag" content="project">
<meta property="article:tag" content="Flang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zoush99.github.io/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/%E5%AE%89%E8%A3%85Flang.jpg">


<link rel="canonical" href="https://zoush99.github.io/2023/07/14/Classic-Flang%E8%AF%B4%E6%98%8E/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://zoush99.github.io/2023/07/14/Classic-Flang%E8%AF%B4%E6%98%8E/","path":"2023/07/14/Classic-Flang说明/","title":"Classic-Flang说明"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Classic-Flang说明 | zoush99's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">zoush99's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Flang%E7%9A%84%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-number">1.</span> <span class="nav-text">Flang的使用情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85Flang"><span class="nav-number">2.</span> <span class="nav-text">安装Flang</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Flang"><span class="nav-number">3.</span> <span class="nav-text">使用Flang</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flang%E8%BD%AC%E6%8D%A2%E6%88%90-ll%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-number">4.</span> <span class="nav-text">Flang转换成.ll的结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LLVM-IR%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">LLVM IR生成文件过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LLVM-IR%E8%AF%AD%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">6.</span> <span class="nav-text">LLVM IR语法的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">6.1.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="nav-number">6.2.</span> <span class="nav-text">主程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E6%95%B0%E6%8D%AE%E5%B8%83%E5%B1%80"><span class="nav-number">6.3.</span> <span class="nav-text">目标数据布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">6.4.</span> <span class="nav-text">C的例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E6%A0%88"><span class="nav-number">7.</span> <span class="nav-text">寄存器和栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">8.</span> <span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">9.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E6%A0%88%E4%B8%8A%E5%8F%98%E9%87%8F%E7%9A%86%E6%8C%87%E9%92%88"><span class="nav-number">9.1.</span> <span class="nav-text">全局变量和栈上变量皆指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSA"><span class="nav-number">9.2.</span> <span class="nav-text">SSA</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="nav-number">10.</span> <span class="nav-text">类型系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.1.</span> <span class="nav-text">基本的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7"><span class="nav-number">10.2.</span> <span class="nav-text">符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="nav-number">10.3.</span> <span class="nav-text">转换指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">11.</span> <span class="nav-text">指针类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">12.</span> <span class="nav-text">聚合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#getelementptr"><span class="nav-number">12.1.</span> <span class="nav-text">getelementptr</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%AD%97%E6%AE%B5"><span class="nav-number">12.1.1.</span> <span class="nav-text">访问数组元素字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8C%87%E9%92%88%E5%AD%97%E6%AE%B5"><span class="nav-number">12.1.2.</span> <span class="nav-text">访问指针字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A7%E8%81%94%E8%AE%BF%E9%97%AE"><span class="nav-number">12.1.3.</span> <span class="nav-text">级联访问</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extractvalue%E5%92%8Cinsertvalue"><span class="nav-number">13.</span> <span class="nav-text">extractvalue和insertvalue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">14.</span> <span class="nav-text">标签类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">15.</span> <span class="nav-text">元数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-number">16.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">17.</span> <span class="nav-text">控制流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E5%B1%82%E9%9D%A2%E7%9A%84%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">18.</span> <span class="nav-text">汇编层面的控制语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if-else"><span class="nav-number">18.1.</span> <span class="nav-text">if .. else</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for"><span class="nav-number">18.2.</span> <span class="nav-text">for</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LLVM-IR%E5%B1%82%E9%9D%A2%E7%9A%84%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">19.</span> <span class="nav-text">LLVM IR层面的控制语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE"><span class="nav-number">19.1.</span> <span class="nav-text">标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4"><span class="nav-number">19.2.</span> <span class="nav-text">比较指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC"><span class="nav-number">19.3.</span> <span class="nav-text">条件跳转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC"><span class="nav-number">19.4.</span> <span class="nav-text">无条件跳转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Basic-block"><span class="nav-number">19.5.</span> <span class="nav-text">Basic block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch"><span class="nav-number">19.6.</span> <span class="nav-text">switch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select"><span class="nav-number">19.7.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#phi"><span class="nav-number">19.8.</span> <span class="nav-text">phi</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">20.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E"><span class="nav-number">21.</span> <span class="nav-text">定义与声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="nav-number">21.1.</span> <span class="nav-text">函数定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7-1"><span class="nav-number">21.1.1.</span> <span class="nav-text">属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">21.2.</span> <span class="nav-text">函数声明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">22.</span> <span class="nav-text">函数的调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="nav-number">22.1.</span> <span class="nav-text">执行函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E4%B8%8E%E8%8E%B7%E5%BE%97%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">22.2.</span> <span class="nav-text">传递参数与获得返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="nav-number">22.2.1.</span> <span class="nav-text">C调用约定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fastcc"><span class="nav-number">22.2.2.</span> <span class="nav-text">fastcc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="nav-number">23.</span> <span class="nav-text">可视化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E3%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">24.</span> <span class="nav-text">内置函数、属性和元数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="nav-number">25.</span> <span class="nav-text">内置函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#memcpy"><span class="nav-number">25.1.</span> <span class="nav-text">memcpy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B"><span class="nav-number">25.2.</span> <span class="nav-text">静态分支预测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7-2"><span class="nav-number">26.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94"><span class="nav-number">26.1.</span> <span class="nav-text">内联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A7%E6%8C%87%E9%92%88%E6%B8%85%E9%99%A4%E4%BC%98%E5%8C%96"><span class="nav-number">26.2.</span> <span class="nav-text">帧指针清除优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">27.</span> <span class="nav-text">元数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF"><span class="nav-number">27.1.</span> <span class="nav-text">调试信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="nav-number">27.2.</span> <span class="nav-text">控制流完整性</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zoush99"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">zoush99</p>
  <div class="site-description" itemprop="description">Record some notes on work and study</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zoush99?tab=repositories" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zoush99?tab&#x3D;repositories" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:victory_z_s@163.com" title="E-Mail → mailto:victory_z_s@163.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zoush99.github.io/2023/07/14/Classic-Flang%E8%AF%B4%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="zoush99">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zoush99's blog">
      <meta itemprop="description" content="Record some notes on work and study">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Classic-Flang说明 | zoush99's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Classic-Flang说明
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-07-14 10:38:24" itemprop="dateCreated datePublished" datetime="2023-07-14T10:38:24+08:00">2023-07-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-07 21:28:20" itemprop="dateModified" datetime="2023-09-07T21:28:20+08:00">2023-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/learn/" itemprop="url" rel="index"><span itemprop="name">learn</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>42k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1:16</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="Flang的使用情况"><a href="#Flang的使用情况" class="headerlink" title="Flang的使用情况"></a>Flang的使用情况</h2><span id="more"></span>

<p>之前搞了那么久，现在终于得开始了解这个工具了。先慢慢使用，看看它的能力以及学习一下转换而来的LLVM IR的语法。</p>
<h2 id="安装Flang"><a href="#安装Flang" class="headerlink" title="安装Flang"></a>安装Flang</h2><p><img src="/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/%E5%AE%89%E8%A3%85Flang.jpg"></p>
<p>我安装的是github网站上的flang-compiler项目的legacy版本<a target="_blank" rel="noopener" href="https://github.com/flang-compiler/flang/tree/legacy">flang-compiler&#x2F;flang at legacy (github.com)</a>。使用的安装脚本是根据网站上提供的安装脚本，并稍作修改：改进了下载版本等信息，总体而言没有做太大改进。为了保证开源包的安全性（可用性），fork到个人目录下：<a target="_blank" rel="noopener" href="https://github.com/zoush99/flang/tree/legacy">zoush99&#x2F;flang at legacy (github.com)</a>。</p>
<p>为了让自己养成良好习惯，在这里记录一下安装的步骤。</p>
<p>安装LLVM需要一系列现代编译链：build-essensial和CMake的版本不低于3.3，并且应该到LLVM的网站满足所需要的依赖，才能进行安装步骤。推荐链接：<a target="_blank" rel="noopener" href="http://llvm.org/docs/GettingStarted.html#host-c-toolchain-both-compiler-and-standard-library">Getting started with LLVM</a>和<a target="_blank" rel="noopener" href="http://llvm.org/docs/CMake.html">CMake llvm</a>。</p>
<p>安装需要依赖后，直接安装其提供的LLVM14版本。其中的一些细节不做讨论。一些解释详见<a target="_blank" rel="noopener" href="https://github.com/flang-compiler/flang/wiki/Building-Flang">Building Flang · flang-compiler&#x2F;flang Wiki (github.com)</a></p>
<p>我们这里需要直接将安装脚本罗列下来，并且依次执行即可。</p>
<p>首先是安装的初始化脚本：将CMake的命令进行初始设置，一定要提前执行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSTALL_PREFIX=`<span class="built_in">pwd</span>`/install</span><br><span class="line"></span><br><span class="line"><span class="comment"># Targets to build should be one of: X86 PowerPC AArch64</span></span><br><span class="line">CMAKE_OPTIONS=<span class="string">&quot;-DCMAKE_INSTALL_PREFIX=<span class="variable">$INSTALL_PREFIX</span> \</span></span><br><span class="line"><span class="string">    -DLLVM_CONFIG=<span class="variable">$INSTALL_PREFIX</span>/bin/llvm-config \</span></span><br><span class="line"><span class="string">    -DCMAKE_CXX_COMPILER=<span class="variable">$INSTALL_PREFIX</span>/bin/clang++ \</span></span><br><span class="line"><span class="string">    -DCMAKE_C_COMPILER=<span class="variable">$INSTALL_PREFIX</span>/bin/clang \</span></span><br><span class="line"><span class="string">    -DCMAKE_Fortran_COMPILER=<span class="variable">$INSTALL_PREFIX</span>/bin/flang </span></span><br><span class="line"><span class="string">    -DCMAKE_Fortran_COMPILER_ID=Flang \</span></span><br><span class="line"><span class="string">    -DLLVM_TARGETS_TO_BUILD=X86&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后是安装llvm14的脚本，直接执行即可。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">. setup.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -d classic-flang-llvm-project ]]; <span class="keyword">then</span></span><br><span class="line">    git <span class="built_in">clone</span> -b release_14x https://github.com/zoush99/classic-flang-llvm-project.git</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> classic-flang-llvm-project</span><br><span class="line"><span class="built_in">mkdir</span> -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake <span class="variable">$CMAKE_OPTIONS</span> -DCMAKE_C_COMPILER=/usr/bin/gcc -DCMAKE_CXX_COMPILER=/usr/bin/g++ -DLLVM_ENABLE_CLASSIC_FLANG=ON -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang;openmp&quot;</span> -DCMAKE_BUILD_TYPE=Release ../llvm</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>将classic-flang-llvm-project&#x2F;build&#x2F;bin目录加入到环境变量，或install&#x2F;bin加入到环境变量。测试Clang命令是否正确执行，这时发现也会存在Flang的命令，但只是将Flang链接到Clang命令，之后安装Flang才会对Fortran程序起作用。</p>
<p>然后安装Flang的legacy版本，这个版本最近更新是在8个月前，因为要适配IKOS&#x2F;Clam，所以需要llvm14版本。目前Flang已经更新到15或更高版本。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">. setup.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ ! -d flang ]]; <span class="keyword">then</span></span><br><span class="line">    git <span class="built_in">clone</span> -b legacy https://github.com/zoush99/flang.git</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">cd</span> flang/runtime/libpgmath</span><br><span class="line"> <span class="built_in">mkdir</span> -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line"> cmake <span class="variable">$CMAKE_OPTIONS</span> ..</span><br><span class="line"> make -j4</span><br><span class="line"> sudo make install)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> flang</span><br><span class="line"><span class="built_in">mkdir</span> -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake <span class="variable">$CMAKE_OPTIONS</span> -DFLANG_LLVM_EXTENSIONS=ON ..</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>这样就把Flang安装成功，之后若使用IKOS还需要安装一个14版本的llvm，但二者相互不影响，因为他们针对不同的处理模块。等安装IKOS时需要将原有的（安装Flang所需）Clang从环境变量中移除（加注释），而安装新的llvm从而加入到环境变量中。之后需要编译IKOS时应该使用官方llvm。</p>
<p>之后所作更改时（Flang和IKOS各自）应该记住这点，因为所使用的llvm版本相同但内容不同，且不冲突。</p>
<p>安装完成后，我还需要将编译得到的一些动态或静态库复制到系统默认查询位置中<code>/usr/lib</code>或<code>/usr/local</code>。这样才算完全没问题。</p>
<h2 id="使用Flang"><a href="#使用Flang" class="headerlink" title="使用Flang"></a>使用Flang</h2><p>使用命令：</p>
<p><code> flang -help</code></p>
<p>来查找它所接受的命令，Flang本身支持所有的Clang的命令，而且支持针对Fortran特定的命令。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">OVERVIEW: clang LLVM compiler</span><br><span class="line"></span><br><span class="line">USAGE: clang-14 [options] file...</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -<span class="comment">###                    Print (but do not run) the commands to run for this compilation</span></span><br><span class="line">  -cpp                    Enable predefined and <span class="built_in">command</span> line preprocessor macros</span><br><span class="line">  -c                      Only run preprocess, compile, and assemble steps</span><br><span class="line">  -D &lt;macro&gt;=&lt;value&gt;      Define &lt;macro&gt; to &lt;value&gt; (or 1 <span class="keyword">if</span> &lt;value&gt; omitted)</span><br><span class="line">  -E                      Only run the preprocessor</span><br><span class="line">  -falternative-parameter-statement</span><br><span class="line">                          Enable the old style PARAMETER statement</span><br><span class="line">  -fbackslash             Specify that backslash <span class="keyword">in</span> string introduces an escape character</span><br><span class="line">  -fcolor-diagnostics     Enable colors <span class="keyword">in</span> diagnostics</span><br><span class="line">  -fdefault-double-8      Set the default double precision kind to an 8 byte wide <span class="built_in">type</span></span><br><span class="line">  -fdefault-integer-8     Set the default <span class="built_in">integer</span> kind to an 8 byte wide <span class="built_in">type</span></span><br><span class="line">  -fdefault-real-8        Set the default real kind to an 8 byte wide <span class="built_in">type</span></span><br><span class="line">  -ffixed-form            Process <span class="built_in">source</span> files <span class="keyword">in</span> fixed form</span><br><span class="line">  -ffixed-line-length-&lt;value&gt;</span><br><span class="line">                          Set line length <span class="keyword">in</span> fixed-form format Fortran, current supporting only 72 and 132 characters</span><br><span class="line">  -ffree-form             Process <span class="built_in">source</span> files <span class="keyword">in</span> free form</span><br><span class="line">  -finput-charset=&lt;value&gt; Specify the default character <span class="built_in">set</span> <span class="keyword">for</span> <span class="built_in">source</span> files</span><br><span class="line">  -fintrinsic-modules-path &lt;<span class="built_in">dir</span>&gt;</span><br><span class="line">                          Specify <span class="built_in">where</span> to find the compiled intrinsic modules</span><br><span class="line">  -flarge-sizes           Use INTEGER(KIND=8) <span class="keyword">for</span> the result <span class="built_in">type</span> <span class="keyword">in</span> size-related intrinsics</span><br><span class="line">  -fno-color-diagnostics  Disable colors <span class="keyword">in</span> diagnostics</span><br><span class="line">  -fno-fixed-form         Disable fixed-form format <span class="keyword">for</span> Fortran</span><br><span class="line">  -fno-free-form          Disable free-form format <span class="keyword">for</span> Fortran</span><br><span class="line">  -fopenacc               Enable OpenACC</span><br><span class="line">  -fopenmp                Parse OpenMP pragmas and generate parallel code.</span><br><span class="line">  -<span class="built_in">help</span>                   Display available options</span><br><span class="line">  -I &lt;<span class="built_in">dir</span>&gt;                Add directory to the end of the list of include search paths</span><br><span class="line">  -module-dir &lt;<span class="built_in">dir</span>&gt;       Put MODULE files <span class="keyword">in</span> &lt;<span class="built_in">dir</span>&gt;</span><br><span class="line">  -nocpp                  Disable predefined and <span class="built_in">command</span> line preprocessor macros</span><br><span class="line">  -o &lt;file&gt;               Write output to &lt;file&gt;</span><br><span class="line">  -pedantic               Warn on language extensions</span><br><span class="line">  -P                      Disable linemarker output <span class="keyword">in</span> -E mode</span><br><span class="line">  -std=&lt;value&gt;            Language standard to compile <span class="keyword">for</span></span><br><span class="line">  -U &lt;macro&gt;              Undefine macro &lt;macro&gt;</span><br><span class="line">  --version               Print version information</span><br><span class="line">  -W&lt;warning&gt;             Enable the specified warning</span><br><span class="line">  -Xflang &lt;arg&gt;           Pass &lt;arg&gt; to the flang compiler</span><br></pre></td></tr></table></figure>

<p>因为我们要用的只是将Fortran转成IR，而且不涉及并行程序（OpenMP），所以只用传统的一些命令行转化即可。</p>
<p>下面列举出一些可以使用的组合命令，以及它们的功能。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">flang -emit-llvm test.f90 -S -c -o test.ll</span><br><span class="line"><span class="comment"># 传统的clang命令生成llvm IR，且是可读版本.ll：汇编文件</span></span><br><span class="line">flang -emit-llvm test.f90 -c -o test.bc</span><br><span class="line"><span class="comment"># 从源码转换成机器码.bc：位码文件</span></span><br><span class="line">llvm-as test.ll -o test.bc</span><br><span class="line"><span class="comment"># 将.ll转换成.bc</span></span><br><span class="line">llvm-dis test.bc -o test.ll</span><br><span class="line"><span class="comment"># 将.bc转换成.ll</span></span><br><span class="line">lli test.bc</span><br><span class="line"><span class="comment"># 直接执行.bc文件</span></span><br><span class="line">llvm-extract --func=foo test.bc -o test-func.bc	<span class="comment"># 用test.ll也可以</span></span><br><span class="line"><span class="comment"># 从位码文件中抽取函数名为foo的函数，除了抽取函数，还可以抽取别名和全局变量</span></span><br></pre></td></tr></table></figure>

<p>一般来说，只用生成汇编文件或位码文件即可，汇编文件用来人为阅读，位码文件直接输入到IKOS中进行分析。</p>
<p>列出Clang的一些命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. .c -&gt; .i</span></span><br><span class="line">clang -E -c test.c -o test.i</span><br><span class="line"><span class="comment"># 2. .c -&gt; .bc</span></span><br><span class="line">clang -emit-llvm test.c -c -o test.bc</span><br><span class="line"><span class="comment"># 3. .c -&gt; .ll</span></span><br><span class="line">clang -emit-llvm test.c -S -o test.ll</span><br><span class="line"><span class="comment"># 4. .i -&gt; .bc</span></span><br><span class="line">clang -emit-llvm test.i -c -o test.bc</span><br><span class="line"><span class="comment"># 5. .i -&gt; .ll</span></span><br><span class="line">clang -emit-llvm test.i -S -o test.ll</span><br><span class="line"><span class="comment"># 6. .bc -&gt; .ll</span></span><br><span class="line">llvm-dis test.bc -o test.ll</span><br><span class="line"><span class="comment"># 7. .ll -&gt; .bc</span></span><br><span class="line">llvm-as test.ll -o test.bc</span><br><span class="line"><span class="comment"># 8. 多 bc 合并为一个 bc</span></span><br><span class="line">llvm-link test1.bc test2.bc -o test.bc</span><br></pre></td></tr></table></figure>

<p><img src="/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/Center.jpg" alt="img"></p>
<h2 id="Flang转换成-ll的结果"><a href="#Flang转换成-ll的结果" class="headerlink" title="Flang转换成.ll的结果"></a>Flang转换成.ll的结果</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">source_filename = <span class="string">&quot;/path/to/source.c&quot;</span></span><br><span class="line"><span class="comment"># 这里描述了源文件的名称和所在路径</span></span><br><span class="line">target datalayout = <span class="string">&quot;layout specification&quot;</span></span><br><span class="line"><span class="comment"># 这里描述了目标机器中数据的内存布局方式，包括字节序、类型以及对齐方式</span></span><br><span class="line"><span class="comment"># 这个参数对理解LLVM关系不大</span></span><br><span class="line">target triple = <span class="string">&quot;ARCHITECTURE-VENDOR-OPERATIONG_SYSTEM&quot;</span></span><br><span class="line">target triple = <span class="string">&quot;ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT&quot;</span></span><br><span class="line"><span class="comment"># 描述了目标机器是什么，从而指示后端生成相应的目标代码</span></span><br><span class="line">Identifiers</span><br><span class="line"><span class="comment"># 标识符分为：全局标识符和局部标识符。全局标识符以@开头，如全局函数、全局变量。局部标识符以%开头，类似于汇编语言中的寄存器</span></span><br><span class="line"><span class="comment"># 标识符有3种形式：</span></span><br><span class="line"><span class="comment">## 有名称的值，表示带有前缀（@或%）的字符串。如：%Val, @name</span></span><br><span class="line"><span class="comment">## 无名称的值，表示带前缀（@或%）的无符号数值。如%0, %1, @2</span></span><br><span class="line"><span class="comment">## 常量</span></span><br><span class="line">Functions</span><br><span class="line"><span class="comment"># define用于定义一个函数</span></span><br><span class="line">define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]</span><br><span class="line">       [cconv] [ret attrs]</span><br><span class="line">       &lt;ResultType&gt; @&lt;FunctionName&gt; ([argument list])</span><br><span class="line">       [(unnamed_addr|local_unnamed_addr)] [AddrSpace] [fn Attrs]</span><br><span class="line">       [section <span class="string">&quot;name&quot;</span>] [comdat [(<span class="variable">$name</span>)]] [align N] [gc] [prefix Constant]</span><br><span class="line">       [prologue Constant] [personality Constant] (!name !N)* &#123; ... &#125;</span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">define dso_local void @foo(i32 %x) <span class="comment">#0 &#123;</span></span><br><span class="line">  ; 省略 ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># define void @foo(i32 %x) &#123; ... &#125;，表示定义一个函数。其函数名称为foo，返回值的数据类型为void，参数（用%x表示）的数据类型为 i32（占用4字节的整型）</span></span><br><span class="line"><span class="comment"># #0，用于修饰函数时表示一组函数属性。这些属性定义在文件末尾</span></span><br><span class="line">  7 define weak dso_local void @foo(i32 %x) <span class="comment">#0 &#123;</span></span><br><span class="line">  8 entry:</span><br><span class="line">  9   %x.addr = alloca i32, align 4</span><br><span class="line"> 10   %y = alloca i32, align 4</span><br><span class="line"> 11   %z = alloca i32, align 4</span><br><span class="line"> 12   store i32 %x, i32* %x.addr, align 4</span><br><span class="line"> 13   %0 = load i32, i32* %x.addr, align 4</span><br><span class="line"> 14   %cmp = icmp eq i32 %0, 0</span><br><span class="line"> 15   br i1 %cmp, label %if.then, label %if.end</span><br><span class="line"> 16 </span><br><span class="line"> 17 if.then:                                          ; preds = %entry</span><br><span class="line"> 18   store i32 5, i32* %y, align 4</span><br><span class="line"> 19   br label %if.end</span><br><span class="line"> 20 </span><br><span class="line"> 21 if.end:                                           ; preds = %if.then, %entry</span><br><span class="line"> 22   %1 = load i32, i32* %x.addr, align 4</span><br><span class="line"> 23   %tobool = icmp ne i32 %1, 0</span><br><span class="line"> 24   br i1 %tobool, label %if.end2, label %if.then1</span><br><span class="line"> 25 </span><br><span class="line"> 26 if.then1:                                         ; preds = %if.end</span><br><span class="line"> 27   store i32 6, i32* %z, align 4</span><br><span class="line"> 28   br label %if.end2</span><br><span class="line"> 29 </span><br><span class="line"> 30 if.end2:                                          ; preds = %if.then1, %if.end</span><br><span class="line"> 31   ret void</span><br><span class="line"> 32 &#125;</span><br><span class="line"><span class="comment"># LLVM IR中，函数体是由基本块构成的。基本块是由一系列顺序执行的语句构成的，并（可选地）以标签作为起始。不同的标签代表不同的基本块</span></span><br><span class="line"><span class="comment"># 基本块的特点如下：</span></span><br><span class="line"><span class="comment">## 仅有一个入口，即基本块中的第一条指令</span></span><br><span class="line"><span class="comment">## 仅有一个出口，即基本块中的最后一条指令（被称为terminator instruction）。该指令要么跳转到其他基本块（不包括入口基本块），要买从函数返回</span></span><br><span class="line"><span class="comment">## 函数体中第一个出现的基本块，称为入口基本块（Entry Basic Block）。它是一个特殊的基本块，在进入函数时立即执行该基本块，并且不允许作为其他基本块的跳转目标（即不允许该基本块有前继结点）</span></span><br></pre></td></tr></table></figure>

<h2 id="LLVM-IR生成文件过程"><a href="#LLVM-IR生成文件过程" class="headerlink" title="LLVM IR生成文件过程"></a>LLVM IR生成文件过程</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.c --frontend--&gt; AST --frontend--&gt; LLVM IR --LLVM opt--&gt; LLVM IR --LLVM llc--&gt; .s Assembly --OS Assembler--&gt; .o --OS Linker--&gt; executable</span><br></pre></td></tr></table></figure>

<h2 id="LLVM-IR语法的基本概念"><a href="#LLVM-IR语法的基本概念" class="headerlink" title="LLVM IR语法的基本概念"></a>LLVM IR语法的基本概念</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>以<code>;</code>开头并一直延申到行尾，作为注释行。</p>
<h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><p>主程序是可执行程序执行的入口点，所以任何可执行程序都需要<code>main</code>函数才能运行。</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是主程序，在<code>@main()</code>之后的就是函数的函数体，<code>ret i32 0</code>就代表C语言中的<code>return 0;</code>。因此，如果要增加代码，就只需要在大括号内，<code>ret i32 0</code>前增加代码即可。</p>
<h3 id="目标数据布局"><a href="#目标数据布局" class="headerlink" title="目标数据布局"></a>目标数据布局</h3><p>LLVM也支持我们手动定制这样的数据布局，例如，我们可以在LLVM IR的源代码中写：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target</span> <span class="keyword">datalayout</span> <span class="operator">=</span> <span class="string">&quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br></pre></td></tr></table></figure>

<p>这一长串文字就定义了目标的数据布局。具体而言：</p>
<ul>
<li><code>e</code>: 小端序</li>
<li><code>m:e</code>: 符号表中使用ELF格式的命名修饰</li>
<li><code>p270:32:32-p271:32:32-p272:64:64</code>: 与地址空间有关</li>
<li><code>i64:64</code>: 将<code>i64</code>类型的变量采用64位的ABI对齐</li>
<li><code>f80:128</code>: 将<code>long double</code>类型的变量采用128位的ABI对齐</li>
<li><code>n8:16:32:64</code>: 目标CPU的原生整型包含8位、16位、32位和64位</li>
<li><code>S128</code>: 栈以128位自然对齐</li>
</ul>
<h3 id="C的例子"><a href="#C的例子" class="headerlink" title="C的例子"></a>C的例子</h3><p>关于符号和符号表，这些还是挺抽象的，我们不如用一个具体的C语言的例子来看看效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> b;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> c;</span><br><span class="line"><span class="type">void</span> <span class="title function_">d</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">e</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们先理解一下这个C语言代码各个符号的含义：</p>
<ul>
<li><p><code>a</code></p>
<p> 定义在<strong>当前文件中的全局变量</strong>，别的文件也可以使用这个符号</p>
</li>
<li><p><code>b</code></p>
<p> 定义在<strong>别的文件中的全局变量</strong>，当前文件需要使用这个符号</p>
</li>
<li><p><code>c</code></p>
<p> 定义在<strong>当前文件中的全局变量，别的文件不可以使用这个符号</strong></p>
</li>
<li><p><code>d</code></p>
<p> 定义在<strong>别的文件中的函数，当前文件需要使用这个符号</strong></p>
</li>
<li><p><code>e</code></p>
<p> 定义在<strong>当前文件中的函数，别的文件也可以使用这个符号</strong></p>
</li>
<li><p><code>f</code></p>
<p> 定义在<strong>当前文件中的函数，别的文件不可以使用这个符号</strong></p>
</li>
</ul>
<p>以上六种，是我们在C语言编程中最常见的符号形式。</p>
<p>我们使用Clang将其编译为LLVM IR，是什么样子的呢？</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">@a</span> <span class="operator">=</span> dso_local <span class="keyword">global</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line"><span class="title">@b</span> <span class="operator">=</span> <span class="keyword">external</span> <span class="keyword">global</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line"><span class="title">@c</span> <span class="operator">=</span> <span class="keyword">internal</span> <span class="keyword">global</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@d</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@e</span>() &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="keyword">internal</span> void <span class="title">@f</span>() &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现几件事（在默认的编译选项下）：</p>
<ul>
<li>C语言中的<code>static</code>，也就是当前文件中定义，别的文件不可以用的，都会加上<code>internal</code>修饰符</li>
<li>C语言中的<code>extern</code>，也就是别的文件中定义的，全局变量会加上<code>external</code>修饰符，函数会使用<code>declare</code></li>
<li>C语言中定义的，可以给别的文件使用的全局变量或函数，不会加上链接类型修饰符，并且会加上<code>dso_local</code>保证不会被抢占</li>
</ul>
<h2 id="寄存器和栈"><a href="#寄存器和栈" class="headerlink" title="寄存器和栈"></a>寄存器和栈</h2><p>这两种数据我选择放在一起讲。我们知道，大多数对数据的操作，如加减乘除、比大小等，都需要操作的是<strong>寄存器</strong>内的数据。那么，我们为什么需要把数据放在<strong>栈</strong>上呢？主要有两个原因：</p>
<ul>
<li>寄存器数量不够</li>
<li>需要操作内存地址</li>
</ul>
<p>如果我们一个函数内有三四十个局部变量，但是家用型CPU最多也就十几个通用寄存器，所以我们不可能把所有变量都放在寄存器中。因此我们需要把一部分数据放在内存中，栈就是一个很好的存储数据的地方；此外，有时候我们需要直接操作内存地址，但是寄存器并没有通用的地址表示，所以只能把数据放在栈上来完成对地址的操作。</p>
<p>因此，<strong>在不操作内存地址的前提下，栈只是寄存器的一个替代品。</strong>如果寄存器的数量足够，并且代码中没有需要操作内存地址的时候，寄存器是足够胜任的，并且更加高效的。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>正因为如此，LLVM IR引入了虚拟寄存器的概念。在LLVM IR中，一个函数的局部变量可以是寄存器或者栈上的变量。对于寄存器而言，我们只需要像普通的赋值语句一样操作，但需要注意名字必须以<code>%</code>开头：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%local_variable</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>此时，<code>%local_variable</code>这个变量就代表一个寄存器，它此时的值就是<code>1</code>和<code>2</code>相加的结果。我们可以写一个简单的程序验证这一点：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; register_test.ll</span></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="variable">%local_variable</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%local_variable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们查看其编译出的汇编代码，其主函数为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">main:</span></span><br><span class="line">    movl    <span class="number">$2</span>, %eax</span><br><span class="line">    addl    <span class="number">$1</span>, %eax</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>

<p>确实这个局部变量<code>%local_variable</code>变成了寄存器<code>eax</code>。</p>
<p>关于寄存器，我们还需了解一点。在不同的ABI下，会有一些callee-saved register和caller-saved register。简单来说，就是在函数内部，某些寄存器的值不能改变。或者说，在函数返回时，某些寄存器的值要和进入函数前相同。比如，在System V的ABI下，<code>rbp</code>, <code>rbx</code>, <code>r12</code>, <code>r13</code>, <code>r14</code>, <code>r15</code>都需要满足这一条件。由于LLVM IR是面向多平台的，所以我们需要一份代码适用于多种ABI。因此，<strong>LLVM IR内部自动帮我们做了这些事。如果我们把所有没有被保留的寄存器都用光了，那么LLVM IR会帮我们把这些被保留的寄存器放在栈上，然后继续使用这些被保留寄存器。当函数退出时，会帮我们自动从栈上获取到相应的值放回寄存器内。</strong></p>
<p>那么，如果所有通用寄存器都用光了，该怎么办？LLVM IR会帮我们把剩余的值放在栈上，但是对我们用户而言，<em>实际上都是虚拟寄存器，用户是感觉不到差别的。</em></p>
<p>因此，我们可以粗略地理解LLVM IR对寄存器的使用：</p>
<ul>
<li>当所需寄存器数量较少时，直接使用callee-saved register，即不需要保留的寄存器</li>
<li>当callee-saved register不够时，将caller-saved register原本的值压栈，然后使用caller-saved register</li>
<li>当寄存器用光以后，就把多的虚拟寄存器的值压栈</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>我们之前说过，当不需要操作地址并且寄存器数量足够时，我们可以直接使用寄存器。而LLVM IR的策略保证了我们可以<strong>使用无数的虚拟寄存器</strong>。那么，<em>在需要操作地址以及需要可变变量时，我们就需要使用栈。</em></p>
<p>LLVM IR对栈的使用十分简单，直接使用<code>alloca</code>指令即可。如：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%local_variable</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br></pre></td></tr></table></figure>

<p>就可以声明一个在栈上的变量了。关于栈上变量的操作，我会在之后提到，目前我们对栈上变量的了解只需这么多。</p>
<p>###数据的使用</p>
<p>在之前的两篇文章中，我们解释了LLVM中是如何对应数据区、寄存器和栈上的数据的。那么，这些数据定义了以后，该如何使用呢？</p>
<h3 id="全局变量和栈上变量皆指针"><a href="#全局变量和栈上变量皆指针" class="headerlink" title="全局变量和栈上变量皆指针"></a>全局变量和栈上变量皆指针</h3><p>下面，我们就需要讲怎样使用<em>全局变量和栈上的变量</em>。这两种变量实际上是类似的，LLVM IR把它们都看作指针。也就是说，对于全局变量：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">@global_variable</span> <span class="operator">=</span> <span class="keyword">global</span> <span class="type">i32</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>和栈上变量</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%local_variable</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br></pre></td></tr></table></figure>

<p>这两个变量实际上都是<code>ptr</code>指针，指向它们所处的一个<code>i32</code>大小的内存区域。所以，我们不能这样：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="title">@global_variable</span> <span class="comment">; Wrong!</span></span><br></pre></td></tr></table></figure>

<p>因为<code>@global_variable</code>只是一个指针。</p>
<p>如果要操作这些值，必须使用<code>load</code>和<code>store</code>这两个命令。如果我们要获取<code>@global_variable</code>的值，就需要</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="title">@global_variable</span></span><br></pre></td></tr></table></figure>

<p>这个指令的意思是，把一个<code>ptr</code>指针<code>@global_variable</code>的<code>i32</code>类型的值赋给虚拟寄存器<code>%1</code>，然后我们就能愉快地</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="variable">%1</span></span><br></pre></td></tr></table></figure>

<p>这样了。</p>
<p>类似地，如果我们要将值存储到全局变量或栈上变量里，会需要<code>store</code>命令：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> ptr <span class="title">@global_variable</span></span><br></pre></td></tr></table></figure>

<p>这个代表将<code>i32</code>类型的值<code>1</code>赋给<code>ptr</code>类型的全局变量<code>@global_variable</code>所指的内存区域中。</p>
<h3 id="SSA"><a href="#SSA" class="headerlink" title="SSA"></a>SSA</h3><p>LLVM IR是一个严格遵守SSA(Static Single Assignment)策略的语言。SSA的要求很简单：每个变量只被赋值一次。也就是说，你不能</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>对<code>%1</code>同时赋值两次是不被允许的。</p>
<p>SSA作为一个历史悠久的概念，已经有了相当成熟的相关技术。通过使用SSA，编译器可以进行更好的优化，应用更成熟的算法，得到更好的结果。这里因为个人能力有限，就不再多对SSA进行介绍。我们只需要知道，通过约束每个变量只被赋值一次，可以让LLVM更好地优化。</p>
<p>上面这个例子好做，直接把3加4的结果赋值给一个新的虚拟寄存器就好了。但是，并非所有的情况都这么简单。在一些复杂情况下，将值存储在栈上再取出来，或者使用<code>phi</code>指令，也是一个更好的选择。</p>
<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>我们知道，汇编语言是弱类型的，我们操作汇编语言的时候，实际上考虑的是一些二进制序列。但是，LLVM IR却是强类型的，在LLVM IR中所有变量都必须有类型。这是因为，我们在使用高级语言编程的时候，往往都会使用强类型的语言，弱类型的语言无必要性，也不利于维护。因此，使用强类型语言，LLVM IR可以更好地进行优化。</p>
<h3 id="基本的数据类型"><a href="#基本的数据类型" class="headerlink" title="基本的数据类型"></a>基本的数据类型</h3><p>LLVM IR中比较基本的数据类型包括：</p>
<ul>
<li>空类型（<code>void</code>）</li>
<li>整型（<code>iN</code>）</li>
<li>浮点型（<code>float</code>、<code>double</code>等）</li>
</ul>
<p>空类型一般是作为不返回值的函数的返回类型，没有特别的含义，就代表「什么都没有」。</p>
<p>整型是指<code>i1</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>这类的数据类型。这里<code>iN</code>的<code>N</code>可以是任意正整数，可以是<code>i3</code>，<code>i1942652</code>。但最常用，最符合常理的就是<code>i1</code>以及8的整数倍。<code>i1</code>有两个值：<code>true</code>和<code>false</code>。也就是说，下面的代码可以正确编译：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%boolean_variable</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i1</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i1</span> <span class="keyword">true</span><span class="punctuation">,</span> ptr <span class="variable">%boolean_variable</span></span><br></pre></td></tr></table></figure>

<p>对于大于1位的整型，也就是如<code>i8</code>, <code>i16</code>等类型，我们可以直接用数字字面量赋值：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%integer_variable</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">128</span><span class="punctuation">,</span> ptr <span class="variable">%integer_variable</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">-128</span><span class="punctuation">,</span> ptr <span class="variable">%integer_variable</span></span><br></pre></td></tr></table></figure>

<h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><p>有一点需要注意的是，在LLVM IR中，整型默认是有符号整型，也就是说我们可以直接将<code>-128</code>以补码形式赋值给<code>i32</code>类型的变量。在LLVM IR中，整型的有无符号是<strong>体现在操作指令而非类型上</strong>的，比方说，对于两个整型变量的除法，LLVM IR分别提供了<code>udiv</code>和<code>sdiv</code>指令分别适用于无符号整型除法和有符号整型除法：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">udiv</span> <span class="type">i8</span> <span class="number">-6</span><span class="punctuation">,</span> <span class="number">2</span>    <span class="comment">; Get (256 - 6) / 2 = 125</span></span><br><span class="line"><span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">sdiv</span> <span class="type">i8</span> <span class="number">-6</span><span class="punctuation">,</span> <span class="number">2</span>    <span class="comment">; Get (-6) / 2 = -3</span></span><br></pre></td></tr></table></figure>

<p>我们可以用这样一个简单的程序验证：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; div_test.ll</span></span><br><span class="line"><span class="keyword">define</span> <span class="type">i8</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">udiv</span> <span class="type">i8</span> <span class="number">-6</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line">    <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">sdiv</span> <span class="type">i8</span> <span class="number">-6</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i8</span> <span class="variable">%1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别将<code>ret</code>语句的参数换成<code>%1</code>和<code>%2</code>以后，将代码编译成可执行文件，在终端下运行并查看返回值即可。</p>
<p>总结一下就是，LLVM IR中的<em>整型默认按有符号补码存储</em>，但一个变量究竟是否要被看作有无符号数需要看其参与的指令。</p>
<h3 id="转换指令"><a href="#转换指令" class="headerlink" title="转换指令"></a>转换指令</h3><p>与整型密切相关的就是转换指令，比如说，将<code>i8</code>类型的数<code>-127</code>转换成<code>i32</code>类型的数，将<code>i32</code>类型的数<code>257</code>转换成<code>i8</code>类型的数等。总的来说，LLVM IR中提供三种指令：<code>trunc</code> .. <code>to</code>指令，<code>zext</code> .. <code>to</code>指令和<code>sext</code> .. <code>to</code>指令。</p>
<p>将长的整型转换成短的整型很简单，直接把多余的高位去掉就行，LLVM IR提供的是<code>trunc</code> .. <code>to</code>指令：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%trunc_integer</span> <span class="operator">=</span> <span class="keyword">trunc</span> <span class="type">i32</span> <span class="number">257</span> <span class="keyword">to</span> <span class="type">i8</span> <span class="comment">; Trunc 32 bit 100000001 to 8 bit, get 1</span></span><br></pre></td></tr></table></figure>

<p>将短的整型变成长的整型则相对比较复杂。这是因为，在补码中最高位是符号位，并不表示实际的数值。因此，如果单纯地在更高位补<code>0</code>，那么<code>i8</code>类型的<code>-1</code>（补码为<code>11111111</code>）就会变成<code>i32</code>的<code>255</code>。这虽然符合道理，但有时候我们需要<code>i8</code>类型的<code>-1</code>扩展到<code>i32</code>时仍然是<code>-1</code>。LLVM IR为我们提供了两种指令：零扩展的<code>zext</code> .. <code>to</code>指令和符号扩展的<code>sext</code> .. <code>to</code>指令。</p>
<p>零扩展就是最简单的，直接在高位补<code>0</code>，而符号扩展则是用原数的符号位来填充。也就是说我们如下的代码：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%zext_integer</span> <span class="operator">=</span> <span class="keyword">zext</span> <span class="type">i8</span> <span class="number">-1</span> <span class="keyword">to</span> <span class="type">i32</span> <span class="comment">; Extend 8 bit 0xFF to 32 bit 0x000000FF, get 255</span></span><br><span class="line"><span class="variable">%sext_integer</span> <span class="operator">=</span> <span class="keyword">sext</span> <span class="type">i8</span> <span class="number">-1</span> <span class="keyword">to</span> <span class="type">i32</span> <span class="comment">; Extend 8 bit 0xFF to 32 bit 0xFFFFFFFF, get -1</span></span><br></pre></td></tr></table></figure>

<p>类似地，浮点型的数和整型的数也可以相互转换，使用<code>fptoui</code> .. <code>to</code>, <code>fptosi</code> .. <code>to</code>, <code>uitofp</code> .. <code>to</code>, <code>sitofp</code> .. <code>to</code>可以分别将浮点数转换为无符号、有符号整型，将无符号、有符号整型转换为浮点数。不过有一点要注意的是，如果将大数转换为小的数，那么并不保证截断，如将浮点型的<code>257.1</code>转换成<code>i8</code>（上限为<code>128</code>），那么就会产生未定义行为。所以，在浮点型和整型相互转换的时候，需要在高级语言层面做一些调整，如使用饱和转换等。</p>
<h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><p>LLVM IR中的指针类型就是<code>ptr</code>。与C语言不同，LLVM IR中的指针不含有其指向内容的类型，也就是说，类似于C语言中的<code>void *</code>。我们之前提到，LLVM IR中的全局变量和栈上分配的变量都是指针，所以其类型都是指针类型。</p>
<p>在高级语言中，直接操作裸指针的机会都比较少，除非在性能极其敏感的场景下，由最厉害的大佬才能操作裸指针。这是因为，裸指针极其危险，稍有不慎就会出现段错误等致命错误，所以我们使用指针时应该慎之又慎。</p>
<p>LLVM IR为大佬们提供了操作裸指针的一些指令。在C语言中，我们会遇到这种场景：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">size_t</span> address_of_x = (<span class="type">size_t</span>)&amp;x;</span><br><span class="line"><span class="type">size_t</span> address_of_y = address_of_x - <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> also_y = *(<span class="type">int</span> *)address_of_y;</span><br></pre></td></tr></table></figure>

<p>这种场景比较无脑，但确实是合理的，需要将指针看作一个具体的数值进行加减。到x86_64的汇编语言层次，取地址就变成了<code>lea</code>命令，解引用倒是比较正常，就是一个简单的<code>mov</code>。</p>
<p>在LLVM IR层次，为了使指针能像整型一样加减，提供了<code>ptrtoint</code> .. <code>to</code>指令和<code>inttoptr</code> .. <code>to</code>指令，分别解决将指针转换为整型，和将整型转换为指针的功能。也就是说，我们可以粗略地将上面的程序转写为</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%x</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span> <span class="comment">; %x is of type ptr, which is the address of variable x</span></span><br><span class="line"><span class="variable">%y</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span> <span class="comment">; %y is of type ptr, which is the address of variable y</span></span><br><span class="line"><span class="variable">%address_of_x</span> <span class="operator">=</span> <span class="keyword">ptrtoint</span> ptr <span class="variable">%x</span> <span class="keyword">to</span> <span class="type">i64</span></span><br><span class="line"><span class="variable">%address_of_y</span> <span class="operator">=</span> <span class="keyword">sub</span> <span class="type">i64</span> <span class="variable">%address_of_x</span><span class="punctuation">,</span> <span class="number">4</span></span><br><span class="line"><span class="variable">%also_y</span> <span class="operator">=</span> <span class="keyword">inttoptr</span> <span class="type">i64</span> <span class="variable">%address_of_y</span> <span class="keyword">to</span> ptr <span class="comment">; %also_y is of type ptr, which is the address of variable y</span></span><br></pre></td></tr></table></figure>

<h2 id="聚合类型"><a href="#聚合类型" class="headerlink" title="聚合类型"></a>聚合类型</h2><p>比起指针类型而言，更重要的是<strong>聚合类型</strong>。我们在C语言中常见的聚合类型有数组和结构体，LLVM IR也为我们提供了相应的支持。</p>
<p>数组类型很简单，我们要声明一个类似C语言中的<code>int a[4]</code>，只需要</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%a</span> <span class="operator">=</span> <span class="keyword">alloca</span> [<span class="number">4</span> <span class="keyword">x</span> <span class="type">i32</span>]</span><br></pre></td></tr></table></figure>

<p>也就是说，C语言中的<code>int[4]</code>类型在LLVM IR中可以写成<code>[4 x i32]</code>。注意，**这里面是个<code>x</code>不是<code>*</code>**。</p>
<p>我们也可以使用类似地语法进行初始化：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">@global_array</span> <span class="operator">=</span> <span class="keyword">global</span> [<span class="number">4</span> <span class="keyword">x</span> <span class="type">i32</span>] [<span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>特别地，我们知道，字符串在底层可以看作字符组成的数组，所以LLVM IR为我们提供了语法糖：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">@global_string</span> <span class="operator">=</span> <span class="keyword">global</span> [<span class="number">12</span> <span class="keyword">x</span> <span class="type">i8</span>] <span class="keyword">c</span><span class="string">&quot;Hello world<span class="char escape_">\00</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>在字符串中，转义字符必须以<code>\xy</code>的形式出现，其中<code>xy</code>是这个转义字符的ASCII码。比如说，字符串的结尾，C语言中的<code>\0</code>，在LLVM IR中就表现为<code>\00</code>。</p>
<p>结构体的类型也相对比较简单，在C语言中的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">char</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在LLVM IR中就成了</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123;</span><br><span class="line">    <span class="type">i32</span><span class="punctuation">,</span></span><br><span class="line">    <span class="type">i8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们初始化一个结构体也很简单：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">@global_structure</span> <span class="operator">=</span> <span class="keyword">global</span> <span class="variable">%MyStruct</span> &#123; <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i8</span> <span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">; or</span></span><br><span class="line"><span class="title">@global_structure</span> <span class="operator">=</span> <span class="keyword">global</span> &#123; <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i8</span> &#125; &#123; <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i8</span> <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，无论是数组还是结构体，其作为全局变量或栈上变量，依然是指针，也就是说，<code>@global_array</code>的类型是<code>ptr</code>, <code>@global_structure</code>的类型也是<code>ptr</code>。接下来的问题就是，我们如何对聚合类型进行操作呢？</p>
<p>在LLVM IR中，<em>如果我们想对一个聚合类型的某些字段进行操作，需要区分这个聚合类型是指针形式的</em>，也就是以全局变量或者栈形式存储，还是值形式的，也就是以寄存器形式存储。</p>
<h3 id="getelementptr"><a href="#getelementptr" class="headerlink" title="getelementptr"></a><code>getelementptr</code></h3><p>首先，我们将介绍以指针形式存储的聚合类型，该如何访问其字段。</p>
<h4 id="访问数组元素字段"><a href="#访问数组元素字段" class="headerlink" title="访问数组元素字段"></a>访问数组元素字段</h4><p>我们先来看一个最直观的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="keyword">struct</span> MyStruct *my_structs_ptr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> my_y = my_structs_ptr[<span class="number">2</span>].y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有一个<code>foo</code>函数，其接收了一个参数<code>my_structs_ptr</code>。从函数体的语义可知，这里这个参数，实际上指向了一个数组，我们要取这个数组的第三个元素的<code>y</code>字段。</p>
<p>我们先直接看结论，用LLVM IR来表示为</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123; <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(ptr <span class="variable">%my_structs_ptr</span>) &#123;</span><br><span class="line">    <span class="variable">%my_y_in_stack</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%my_y_ptr</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="variable">%MyStruct</span><span class="punctuation">,</span> ptr <span class="variable">%my_structs_ptr</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line">    <span class="variable">%my_y_val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%my_y_ptr</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%my_y_val</span><span class="punctuation">,</span> ptr <span class="variable">%my_y_in_stack</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以注意到，最核心的就是<code>getelementptr</code>指令了。它的四个参数的语义分别为<code>%MyStruct, ptr %my_structs_ptr, i64 2, i32 1</code></p>
<p>我们要取地址的指针，它指向区域的类型为<code>%MyStruct</code></p>
<ul>
<li><p><code>ptr %my_structs_ptr</code></p>
<p> 我们要操作的指针，是<code>ptr %my_structs_ptr</code></p>
</li>
<li><p><code>i64 2</code></p>
<p> 取偏移量为2的那个元素，也就是<code>my_structs_ptr[2]</code></p>
</li>
<li><p><code>i32 1</code></p>
<p> 对于获得到的那个元素，取索引为1的字段，也就是<code>my_structs_ptr[2].y</code></p>
</li>
</ul>
<p>通过这个指令，我们获得了<code>my_structs_ptr[2].y</code>的地址，随后的LLVM IR指令就是将这个地址的值放到了局部变量中。</p>
<h4 id="访问指针字段"><a href="#访问指针字段" class="headerlink" title="访问指针字段"></a>访问指针字段</h4><p>接下来，我们看这样一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="keyword">struct</span> MyStruct *my_structs_ptr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> my_y = my_structs_ptr-&gt;y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其对应的LLVM IR为</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123; <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(ptr <span class="variable">%my_structs_ptr</span>) &#123;</span><br><span class="line">    <span class="variable">%my_y_in_stack</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%my_y_ptr</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="variable">%MyStruct</span><span class="punctuation">,</span> ptr <span class="variable">%my_structs_ptr</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line">    <span class="variable">%my_y_val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%my_y_ptr</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%my_y_val</span><span class="punctuation">,</span> ptr <span class="variable">%my_y_in_stack</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唯一的改动，就是将之前的偏移量<code>i64 2</code>改为<code>i64 0</code>。</p>
<p>这看上去挺符合直觉的。等等，符合直觉吗？</p>
<p>我们发现，即使是将<code>my_structs_ptr</code>看作是指向结构体的指针，而非指向数组的指针，仍然要加一个偏移量<code>0</code>。这是因为，C语言中，对于一个数组<code>array</code>，<code>&amp;array[0]</code>和指向首元素的<code>array_ptr</code>是同一个东西。为了兼容C语言这个特性，LLVM IR在<code>getelementptr</code>中，将所有的指针都看作一个指向数组首地址的指针。因此，我们需要额外加一个<code>i64 0</code>的偏移量来解决这个问题。</p>
<h4 id="级联访问"><a href="#级联访问" class="headerlink" title="级联访问"></a>级联访问</h4><p>此外，<code>getelementptr</code>还可以接多个参数，类似于级联调用。我们有C程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> <span class="title">my_structs</span>[4];</span></span><br></pre></td></tr></table></figure>

<p>那么如果我们想获得<code>my_structs[2].y[3]</code>的地址，只需要</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123;</span><br><span class="line">    <span class="type">i32</span><span class="punctuation">,</span></span><br><span class="line">    [<span class="number">5</span> <span class="keyword">x</span> <span class="type">i32</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">%my_structs</span> <span class="operator">=</span> <span class="keyword">alloca</span> [<span class="number">4</span> <span class="keyword">x</span> <span class="variable">%MyStruct</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">4</span> <span class="keyword">x</span> <span class="variable">%MyStruct</span>]<span class="punctuation">,</span> ptr <span class="variable">%my_structs</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>我们可以查看官方提供的<a target="_blank" rel="noopener" href="http://llvm.org/docs/GetElementPtr.html">The Often Misunderstood GEP Instruction</a>指南更多地了解<code>getelementptr</code>的机理。</p>
<h2 id="extractvalue和insertvalue"><a href="#extractvalue和insertvalue" class="headerlink" title="extractvalue和insertvalue"></a><code>extractvalue</code>和<code>insertvalue</code></h2><p>除了我们上面讲的这种情况，也就是把结构体分配在栈或者全局变量，然后操作其指针以外，还有什么情况呢？我们考虑这种情况：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; extract_insert_value.ll</span></span><br><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123;</span><br><span class="line">    <span class="type">i32</span><span class="punctuation">,</span></span><br><span class="line">    <span class="type">i32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title">@my_struct</span> <span class="operator">=</span> <span class="keyword">global</span> <span class="variable">%MyStruct</span> &#123; <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="variable">%MyStruct</span><span class="punctuation">,</span> ptr <span class="title">@my_struct</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，我们的结构体是直接放在虚拟寄存器<code>%1</code>里，<code>%1</code>并不是存储<code>@my_struct</code>的指针，而是直接存储这个结构体的值。这时，我们并不能用<code>getelementptr</code>来操作<code>%1</code>，因为这个指令需要的是一个指针。因此，LLVM IR提供了<code>extractvalue</code>和<code>insertvalue</code>指令。</p>
<p>因此，如果要获得<code>@my_struct</code>第二个字段的值，我们需要</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">extractvalue</span> <span class="variable">%MyStruct</span> <span class="variable">%1</span><span class="punctuation">,</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>1</code>就代表第二个字段（从<code>0</code>开始）。</p>
<p>类似地，如果要将<code>%1</code>的第二个字段赋值为<code>233</code>，只需要</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">insertvalue</span> <span class="variable">%MyStruct</span> <span class="variable">%1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">233</span><span class="punctuation">,</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>然后<code>%3</code>就会是<code>%1</code>将第二个字段赋值为<code>233</code>后的值。</p>
<p><code>extractvalue</code>和<code>insertvalue</code>并不只适用于结构体，也同样适用于<strong>存储在虚拟寄存器中的数组</strong>，这里不再赘述。</p>
<h2 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a>标签类型</h2><p>在汇编语言中，一切的控制语句、函数调用都是由标签来控制的，在LLVM IR中，控制语句也是需要标签来完成。其具体的内容我会在之后专门有一篇控制语句的文章来解释。</p>
<h2 id="元数据类型"><a href="#元数据类型" class="headerlink" title="元数据类型"></a>元数据类型</h2><p>在我们使用Clang将C语言程序输出成LLVM IR时，会发现代码的最后几行有</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">!llvm.module.flags</span> <span class="operator">=</span> !&#123;<span class="title">!0</span><span class="punctuation">,</span> <span class="title">!1</span><span class="punctuation">,</span> <span class="title">!2</span><span class="punctuation">,</span> <span class="title">!3</span>&#125;</span><br><span class="line"><span class="title">!llvm.ident</span> <span class="operator">=</span> !&#123;<span class="title">!4</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!0</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> !<span class="string">&quot;wchar_size&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">4</span>&#125;</span><br><span class="line"><span class="title">!1</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">8</span><span class="punctuation">,</span> !<span class="string">&quot;PIC Level&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span>&#125;</span><br><span class="line"><span class="title">!2</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">7</span><span class="punctuation">,</span> !<span class="string">&quot;PIE Level&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span>&#125;</span><br><span class="line"><span class="title">!3</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">7</span><span class="punctuation">,</span> !<span class="string">&quot;uwtable&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span>&#125;</span><br><span class="line"><span class="title">!4</span> <span class="operator">=</span> !&#123;!<span class="string">&quot;Homebrew clang version 16.0.6&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>类似于这样的东西。</p>
<p>在LLVM IR中，以<code>!</code>开头的标识符为<strong>元数据</strong>。元数据是为了<em>将额外的信息附加在程序中传递给LLVM后端，使后端能够好地优化或生成代码。</em>用于Debug的信息就是通过元数据形式传递的。我们可以使用<code>-g</code>选项：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -emit-llvm -g test.c</span><br></pre></td></tr></table></figure>

<p>来在LLVM IR中附加额外的Debug信息。关于元数据，在后续的章节里会有更具体的介绍。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>最后，还有一种叫做属性的概念。属性并不是类型，其一般用于函数。比如说，告诉编译器这个函数不会抛出错误，不需要某些优化等等。我们可以看到</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>() <span class="keyword">nounwind</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>nounwind</code>就是一个属性。</p>
<p>有时候，一个函数的属性会特别特别多，并且有多个函数都有相同的属性。那么，就会有大量重复的篇幅用来给每一个函数说明属性。因此，<strong>LLVM IR引入了属性组的概念</strong>，我们在将一个简单的C程序编译成LLVM IR时，会发现代码中有</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; <span class="keyword">noinline</span> <span class="keyword">nounwind</span> <span class="keyword">optnone</span> <span class="keyword">ssp</span> <span class="keyword">uwtable</span> <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;darwin-stkchk-strong-link&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span><span class="operator">=</span><span class="string">&quot;0&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;probe-stack&quot;</span><span class="operator">=</span><span class="string">&quot;___chkstk_darwin&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span><span class="operator">=</span><span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;penryn&quot;</span> <span class="string">&quot;target-features&quot;</span><span class="operator">=</span><span class="string">&quot;+cx16,+cx8,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这种一大长串的，就是属性组。属性组总是以<code>#</code>开头。当我们函数需要它的时候，只需要</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span> <span class="variable">#0</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接使用<code>#0</code>即可。关于属性，后续也会有专门的章节进行介绍。</p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>在程序分析领域，往往会强调一对概念：<strong>数据流与控制流</strong>。所谓数据流，就是指一个程序中的数据，从硬盘到内存，从内存到寄存器，等等一系列的数据搬运、处理的过程。这一过程，在之前的文章中已经详细地介绍了。</p>
<p>而控制流，则是指程序执行指令的顺序。最简单地，我们的程序在除了顺序执行指令，还可以通过<code>if</code>语句进行条件跳转，通过<code>for</code>、<code>while</code>语句进行循环，还可以通过函数调用进入到别的函数。凡此种种，都是程序控制流的变化。</p>
<p>在使用LLVM作为编译器的时候，控制流往往就意味着更多的优化可能，如分支布局、函数内联。在使用LLVM作为静态分析工具的过程中，控制流也意味着更高的复杂度，如间接跳转、间接调用的识别和恢复。</p>
<p>因此，我们需要仔细了解LLVM中的控制流。</p>
<h2 id="汇编层面的控制语句"><a href="#汇编层面的控制语句" class="headerlink" title="汇编层面的控制语句"></a>汇编层面的控制语句</h2><p>在大多数语言中，常见的控制语句主要有四种：</p>
<ul>
<li><code>if</code> .. <code>else</code></li>
<li><code>for</code></li>
<li><code>while</code></li>
<li><code>switch</code></li>
</ul>
<p>在汇编语言层面，控制语句则被分解为两种核心的指令：条件跳转与无条件跳转（<code>switch</code>其实还有一些工作，之后会提到）。我们下面分别来看看在汇编层面是怎样实现控制语句的。</p>
<h3 id="if-else"><a href="#if-else" class="headerlink" title="if .. else"></a><code>if</code> .. <code>else</code></h3><p>我们有以下C代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="comment">// Do something A</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Do something B</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Do something C</span></span><br></pre></td></tr></table></figure>

<p>为了将这个指令改写成汇编指令，我们同时需要条件跳转与无条件跳转。我们用伪代码表示其汇编指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    Compare a and b</span><br><span class="line">    Jump to label B if comparison is a is not greater than b // conditional jump</span><br><span class="line">label A:</span><br><span class="line">    Do something A</span><br><span class="line">    Jump to label C // unconditional jump</span><br><span class="line">label B:</span><br><span class="line">    Do something B</span><br><span class="line">label C:</span><br><span class="line">    Do something C</span><br></pre></td></tr></table></figure>

<p>汇编语言通过条件跳转、无条件跳转和三个标签（<code>label A</code>标签实际上没有作用，只不过让代码更加清晰）实现了高级语言层面的<code>if</code> .. <code>else</code>语句。</p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a><code>for</code></h3><p>我们有以下C代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// Do something A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Do something B</span></span><br></pre></td></tr></table></figure>

<p>为了将这个指令改写为汇编指令，我们同样地需要条件跳转与无条件跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    int i = 0</span><br><span class="line">label start:</span><br><span class="line">    Compare i and 4</span><br><span class="line">    Jump to label B if comparison is i is not less than 4 // conditional jump</span><br><span class="line">label A:</span><br><span class="line">    Do something A</span><br><span class="line">    i++</span><br><span class="line">    Jump to label start // unconditional jump</span><br><span class="line">label B:</span><br><span class="line">    Do something B</span><br></pre></td></tr></table></figure>

<p>而<code>while</code>与<code>for</code>则极其类似，只不过少了初始化与自增的操作，这里不再赘述。</p>
<p>根据我们在汇编语言中积累的经验，我们得出，要实现大多数高级语言的控制语句，我们需要四个东西：</p>
<ul>
<li>标签</li>
<li>无条件跳转</li>
<li>比较大小的指令</li>
<li>条件跳转</li>
</ul>
<h2 id="LLVM-IR层面的控制语句"><a href="#LLVM-IR层面的控制语句" class="headerlink" title="LLVM IR层面的控制语句"></a>LLVM IR层面的控制语句</h2><p>下面就以我们上面的<code>for</code>循环的C语言版本为例，解释如何写其对应的LLVM IR语句。</p>
<p>首先，我们对应的LLVM IR的基本框架为</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                       <span class="comment">; int i = ...</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                   <span class="comment">; ... = 0</span></span><br><span class="line"><span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line"><span class="comment">; Do something A</span></span><br><span class="line"><span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>              <span class="comment">; ... = i + 1</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                  <span class="comment">; i = ...</span></span><br><span class="line"><span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<p>这个程序缺少了一些必要的步骤，而我们之后会将其慢慢补上。</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>在LLVM IR中，标签与汇编语言的标签一致，也是以<code>:</code>结尾作标记。我们依照之前写的汇编语言的伪代码，给这个程序加上标签：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                  <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>              <span class="comment">; ... = 0</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>         <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>             <span class="comment">; i = ...</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><p>LLVM IR提供的比较指令为<code>icmp</code>。其接受三个参数：比较方案以及两个比较参数。这样讲比较抽象，我们就来看一下一个最简单的比较指令的例子：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">uge</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="variable">%b</span></span><br></pre></td></tr></table></figure>

<p>这个例子转化为C++语言就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> comparison_result = ((<span class="type">unsigned</span> <span class="type">int</span>)a &gt;= (<span class="type">unsigned</span> <span class="type">int</span>)b);</span><br></pre></td></tr></table></figure>

<p>这里，<code>uge</code>是比较方案，<code>%a</code>和<code>%b</code>就是用来比较的两个数，而<code>icmp</code>则返回一个<code>i1</code>类型的值，也就是C++中的<code>bool</code>值，用来表示结果是否为真。</p>
<p><code>icmp</code>支持的比较方案很广泛：</p>
<ul>
<li>首先，最简单的是<code>eq</code>与<code>ne</code>，分别代表相等或不相等。</li>
<li>然后，是无符号的比较<code>ugt</code>, <code>uge</code>, <code>ult</code>, <code>ule</code>，分别代表大于、大于等于、小于、小于等于。我们之前在数的表示中提到，LLVM IR中一个整型变量本身的符号是没有意义的，而是需要看在其参与的指令中被看作是什么符号。这里每个方案的<code>u</code>就代表以无符号的形式进行比较。</li>
<li>最后，是有符号的比较<code>sgt</code>, <code>sge</code>, <code>slt</code>, <code>sle</code>，分别是其无符号版本的有符号对应。</li>
</ul>
<p>我们来看加上比较指令之后，我们的例子就变成了：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                               <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                           <span class="comment">; ... = 0</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">    <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">slt</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">4</span> <span class="comment">; Test if i &lt; 4</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>                      <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                          <span class="comment">; i = ...</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<h3 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h3><p>在比较完之后，我们需要条件跳转。我们来看一下我们此刻的目的：若<code>%comparison_result</code>是<code>true</code>，那么跳转到<code>A</code>，否则跳转到<code>B</code>。</p>
<p>LLVM IR为我们提供的条件跳转指令是<code>br</code>，其接受三个参数，第一个参数是<code>i1</code>类型的值，用于作判断；第二和第三个参数分别是值为<code>true</code>和<code>false</code>时需要跳转到的标签。比方说，在我们的例子中，就应该是</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br></pre></td></tr></table></figure>

<p>我们把它加入我们的例子：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                               <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                           <span class="comment">; ... = 0</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">    <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">slt</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">4</span> <span class="comment">; Test if i &lt; 4</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>                      <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                          <span class="comment">; i = ...</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<h3 id="无条件跳转"><a href="#无条件跳转" class="headerlink" title="无条件跳转"></a>无条件跳转</h3><p>无条件跳转更好理解，直接跳转到某一标签处。在LLVM IR中，我们同样可以使用<code>br</code>进行条件跳转。如，如果要直接跳转到<code>start</code>标签处，则可以</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">br</span> label <span class="variable">%start</span></span><br></pre></td></tr></table></figure>

<p>我们也把这加入我们的例子：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                               <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                           <span class="comment">; ... = 0</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">    <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">slt</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">4</span> <span class="comment">; Test if i &lt; 4</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>                      <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                          <span class="comment">; i = ...</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%start</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<p>这样看上去就结束了，然而如果大家把这个代码交给<code>llc</code>的话，并不能编译通过，这是为什么呢？</p>
<h3 id="Basic-block"><a href="#Basic-block" class="headerlink" title="Basic block"></a>Basic block</h3><p>首先，我们来摘录一下LLVM IR的参考指南中<a target="_blank" rel="noopener" href="http://llvm.org/docs/LangRef.html#functions">Functions</a>节的一段话：</p>
<blockquote>
<p>A function definition contains a list of basic blocks, forming the CFG (Control Flow Graph) for the function. Each basic block may optionally start with a label (giving the basic block a symbol table entry), contains a list of instructions, and ends with a terminator instruction (such as a branch or function return). If an explicit label name is not provided, a block is assigned an implicit numbered label, using the next value from the same counter as used for unnamed temporaries (see above).</p>
</blockquote>
<p>这段话的大意有几个：</p>
<ul>
<li>一个函数由许多基本块(Basic block)组成</li>
<li>每个基本块包含：<ul>
<li>开头的标签（可省略）</li>
<li>一系列指令</li>
<li>结尾是终结指令</li>
</ul>
</li>
<li>一个基本块没有标签时，会自动赋给它一个标签</li>
</ul>
<p>所谓终结指令，就是指改变执行顺序的指令，如跳转、返回等。</p>
<p>我们来看看我们之前写好的程序是不是符合这个规定。<code>start</code>开头的基本块，在一系列指令后，以</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br></pre></td></tr></table></figure>

<p>结尾，是一个终结指令。<code>A</code>开头的基本块，在一系列指令后，以</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">br</span> label <span class="variable">%start</span></span><br></pre></td></tr></table></figure>

<p>结尾，也是一个终结指令。<code>B</code>开头的基本块，在最后总归是需要函数返回的（这里为了篇幅省略了），所以也一定会带有一个终结指令。</p>
<p>看上去都很符合呀，那为什么编译不通过呢？我们来仔细想一下，我们考虑了所有基本块了吗？要注意到，一个基本块是可以没有名字的，所以，实际上还有一个基本块没有考虑到，就是函数开头的：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>          <span class="comment">; int i = ...</span></span><br><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>      <span class="comment">; ... = 0</span></span><br></pre></td></tr></table></figure>

<p>这个基本块。它并没有以终结指令结尾！</p>
<p>所以，我们把一个终结指令补充在这个基本块的结尾：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="variable">%i</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span>                               <span class="comment">; int i = ...</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                           <span class="comment">; ... = 0</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%start</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line">    <span class="variable">%i_value</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%i</span></span><br><span class="line">    <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">slt</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">4</span> <span class="comment">; Test if i &lt; 4</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%A</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="variable">%i_value</span><span class="punctuation">,</span> <span class="number">1</span>                      <span class="comment">; ... = i + 1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%i</span>                          <span class="comment">; i = ...</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%start</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br></pre></td></tr></table></figure>

<p>这样就完成了我们的例子。</p>
<p>LLVM的工具链甚至为我们提供了可视化控制语句的方法。我们使用之前提到的LLVM工具链中用于优化的<code>opt</code>工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt -p dot-cfg for.ll</span><br></pre></td></tr></table></figure>

<p>然后会生成一个<code>.main.dot</code>的文件。如果我们在计算机上装有<a target="_blank" rel="noopener" href="http://www.graphviz.org/">Graphviz</a>，那么就可以用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dot .main.dot -Tpng -o for.png</span><br></pre></td></tr></table></figure>

<p>生成其可视化的控制流图（CFG）：</p>
<p><img src="/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/cfg.jpg"></p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a><code>switch</code></h3><p>下面我们来讲讲<code>switch</code>语句。我们有以下C语言程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// do something A</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// do something B</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// do something C</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do something else</span></span><br></pre></td></tr></table></figure>

<p>我们先直接来看其转换成LLVM IR是什么样子的：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="type">i32</span> <span class="variable">%x</span><span class="punctuation">,</span> label <span class="variable">%C</span> [</span><br><span class="line">    <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> label <span class="variable">%A</span></span><br><span class="line">    <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> label <span class="variable">%B</span></span><br><span class="line">]</span><br><span class="line">A:</span><br><span class="line">    <span class="comment">; Do something A</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line">B:</span><br><span class="line">    <span class="comment">; Do something B</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line">C:</span><br><span class="line">    <span class="comment">; Do something C</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">    <span class="comment">; Do something else</span></span><br></pre></td></tr></table></figure>

<p>其核心就是第一行的<code>switch</code>指令。其第一个参数<code>i32 %x</code>是用来判断的，也就是我们C语言中的<code>x</code>。第二个参数<code>label %C</code>是C语言中的<code>default</code>分支，这是必须要有的参数。也就是说，我们的<code>switch</code>必须要有<code>default</code>来处理。接下来是一个数组，其意义已经很显然了，如果<code>%x</code>值是<code>0</code>，就去<code>label %A</code>，如果值是<code>1</code>，就去<code>label %B</code>。</p>
<p>LLVM后端对<code>switch</code>语句具体到汇编层面的实现则通常有两种方案：用一系列条件语句或跳转表。</p>
<p>一系列条件语句的实现方式最简单，用伪代码来表示的话就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (x == 0) &#123;</span><br><span class="line">    Jump to label %A</span><br><span class="line">&#125; else if (x == 1) &#123;</span><br><span class="line">    Jump to label %B</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Jump to label %C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是十分符合常理的。然而，我们需要注意到，如果这个<code>switch</code>语句一共有n个分支，那么其查找效率实际上是O(n)。那么，这种实现方案下的<code>switch</code>语句仅仅是<code>if</code> .. <code>else</code>的语法糖，除了增加可维护性，并不会优化什么性能。</p>
<p>跳转表则是一个可以优化性能的<code>switch</code>语句实现方案，其伪代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">labels = [label %A, label %B]</span><br><span class="line">if (x &lt; 0 || x &gt; 1) &#123;</span><br><span class="line">    Jump to label %C</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Jump to labels[x]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这只是一个极其粗糙的近似的实现，我们需要的是理解其基本思想。<strong>跳转表的思想就是利用内存中数组的索引是O(1)复杂度的</strong>，所以我们可以根据目前的<code>x</code>值去查找应该跳转到哪一个地址，这就是跳转表的基本思想。</p>
<p>根据目标平台和<code>switch</code>语句的分支数，LLVM后端会自动选择不同的实现方式去实现<code>switch</code>语句。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a><code>select</code></h3><p>我们经常会遇到一种情况，某一变量的值需要根据条件进行赋值，比如说以下C语言的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        y = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Do something with y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>x</code>大于<code>0</code>，则<code>y</code>为<code>1</code>，否则<code>y</code>为<code>2</code>。这一情况很常见，然而在C语言中，如果要实现这种功能，<code>y</code>需要被实现为可变变量，但实际上无论<code>x</code>如何取值，<code>y</code>只会被赋值一次，并不应该是可变的。</p>
<p>我们知道，LLVM IR中，由于SSA的限制，局部可变变量都必须分配在栈上，虽然LLVM后端最终会进行一定的优化，但写起代码来还需要冗长的<code>alloca</code>, <code>load</code>, <code>store</code>等语句。如果我们按照C语言的思路来写LLVM IR，那么就会是：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%x</span>) &#123;</span><br><span class="line">    <span class="variable">%y</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">sgt</span> <span class="type">i32</span> <span class="variable">%x</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%1</span><span class="punctuation">,</span> label <span class="variable">%btrue</span><span class="punctuation">,</span> label <span class="variable">%bfalse</span></span><br><span class="line"><span class="symbol">btrue:</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> ptr <span class="variable">%y</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">bfalse:</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> ptr <span class="variable">%y</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">    <span class="comment">; do something with %y</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看其编译出的汇编语言是怎样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo:</span><br><span class="line"># %bb.0:</span><br><span class="line">	cmpl	$0, %edi</span><br><span class="line">	jle	.LBB0_2</span><br><span class="line"># %bb.1:                                # %btrue</span><br><span class="line">	movl	$1, -4(%rsp)</span><br><span class="line">	jmp	.LBB0_3</span><br><span class="line">.LBB0_2:                                # %bfalse</span><br><span class="line">	movl	$2, -4(%rsp)</span><br><span class="line">.LBB0_3:                                # %end</span><br><span class="line">	retq</span><br></pre></td></tr></table></figure>

<p>算上注释，C语言代码9行，汇编语言代码11行，LLVM IR代码14行。这LLVM IR同时比低层次和高层次的代码都长，而且这种模式在真实的代码中出现的次数会非常多，这显然是不可以接受的。究其原因，就是这里把<code>y</code>看成了可变变量。那么，有没有什么办法让<code>y</code>不可变但仍然能实现这个功能呢？</p>
<p>首先，我们来看看同样区分可变变量与不可变变量的Rust是怎么做的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn foo(x: i32) &#123;</span><br><span class="line">    let y = if x &gt; 0 &#123; 1 &#125; else &#123; 2 &#125;;</span><br><span class="line">    // Do something with y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让代码简短的方式很简单，把<code>y</code>看作不可变变量，但同时需要语言支持把<code>if</code>语句视作表达式，当<code>x</code>大于<code>0</code>时，这个表达式返回<code>1</code>，否则返回<code>2</code>。这样，就很简单地实现了我们的需求。</p>
<p>LLVM IR中同样也有这样的指令，那就是<code>select</code>，我们来把上面的例子用<code>select</code>改写：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%x</span>) &#123;</span><br><span class="line">    <span class="variable">%result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">sgt</span> <span class="type">i32</span> <span class="variable">%x</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">    <span class="variable">%y</span> <span class="operator">=</span> <span class="keyword">select</span> <span class="type">i1</span> <span class="variable">%result</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span></span><br><span class="line">    <span class="comment">; Do something with %y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>select</code>指令接受三个参数。第一个参数是用来判断的布尔值，也就是<code>i1</code>类型的<code>icmp</code>判断的结果，如果其为<code>true</code>，则返回第二个参数，否则返回第三个参数。极其合理。</p>
<p><code>select</code>不仅可以简化LLVM代码，也可以优化生成的二进制程序。在大部分情况下，在AMD64架构中，LLVM会将<code>select</code>指令编译为<a target="_blank" rel="noopener" href="https://www.felixcloutier.com/x86/cmovcc"><code>CMOV</code>cc</a>指令，也就是条件赋值，从而优化了生成的二进制代码。</p>
<h3 id="phi"><a href="#phi" class="headerlink" title="phi"></a><code>phi</code></h3><p><code>select</code>只能支持两个选择，<code>true</code>选择一个分支，<code>false</code>选择另一个分支，我们是不是可以有支持多种选择的类似<code>switch</code>的版本呢？同时，我们也可以换个角度思考，<code>select</code>是根据<code>i1</code>的值来进行判断，我们其实可以根据控制流进行判断。这就是在SSA技术中大名鼎鼎的<code>phi</code>指令。</p>
<p>为了方便起见，我们首先先来看用<code>phi</code>指令实现的我们上面这个代码：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%x</span>) &#123;</span><br><span class="line">    <span class="variable">%result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">sgt</span> <span class="type">i32</span> <span class="variable">%x</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%result</span><span class="punctuation">,</span> label <span class="variable">%btrue</span><span class="punctuation">,</span> label <span class="variable">%bfalse</span></span><br><span class="line"><span class="symbol">btrue:</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">bfalse:</span></span><br><span class="line">    <span class="keyword">br</span> label <span class="variable">%end</span></span><br><span class="line"><span class="symbol">end:</span></span><br><span class="line">    <span class="variable">%y</span> <span class="operator">=</span> <span class="keyword">phi</span> <span class="type">i32</span> [<span class="number">1</span><span class="punctuation">,</span> <span class="variable">%btrue</span>]<span class="punctuation">,</span> [<span class="number">2</span><span class="punctuation">,</span> <span class="variable">%bfalse</span>]</span><br><span class="line">    <span class="comment">; Do something with %y</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，<code>phi</code>的第一个参数是一个类型，这个类型表示其返回类型为<code>i32</code>。接下来则是两个数组，其表示，如果当前的basic block执行的时候，前一个basic block是<code>%btrue</code>，那么返回<code>1</code>，如果前一个basic block是<code>%bfalse</code>，那么返回<code>2</code>。</p>
<p>也就是说，<code>select</code>是根据其第一个参数<code>i1</code>类型的变量的值来决定返回哪个值，而<code>phi</code>则是根据其之前是哪个basic block来决定其返回值。此外，<code>phi</code>之后可以跟无数的分支，如<code>phi i32 [1, %a], [2, %b], [3, %c]</code>等，从而可以支持多分支的赋值。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在汇编层面，一个函数与一个控制语句极其相似，都是由标签组成，只不过在跳转时增加了一些附加的操作。而在LLVM IR层面，函数则得到了更高一层的抽象。</p>
<h2 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>在LLVM中，一个最基本的函数定义的样子我们之前已经遇到过多次，就是<code>@main</code>函数的样子：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数名之后可以加上参数列表，如：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="variable">%b</span>) &#123;</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个函数定义最基本的框架，就是返回值（<code>i32</code>）+函数名（<code>@foo</code>）+参数列表（<code>(i32 %a, i64 %b）</code>）+函数体（<code>&#123; ret i32 0 &#125;</code>）。</p>
<p>我们可以看到，函数的名称和全局变量一样，都是以<code>@</code>开头的。并且，如果我们查看符号表的话，也会发现其和全局变量一样进入了符号表。因此，函数也有和全局变量完全一致的Linkage Types和Visibility Style，来控制函数名在符号表中的出现情况，因此，可以出现如</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="keyword">private</span> <span class="type">i32</span> <span class="title">@foo</span>() &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的修饰符。</p>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>此外，我们还可以在参数列表之后加上属性，也就是控制优化器和代码生成器的指令。如果我们单纯编译一个简单的C代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>其编译出的LLVM IR实际上是</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@foo</span>() <span class="variable">#0</span> &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; <span class="keyword">noinline</span> <span class="keyword">nounwind</span> <span class="keyword">optnone</span> <span class="keyword">uwtable</span> <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span><span class="operator">=</span><span class="string">&quot;0&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span><span class="operator">=</span><span class="string">&quot;true&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span><span class="operator">=</span><span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span><span class="operator">=</span><span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;tune-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;generic&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>#0</code>就是一个属性组，其包含了<code>noinline</code>、<code>nounwind</code>等若干个函数的属性。这些属性可以控制LLVM在优化和生成函数时的行为。大部分的属性可以在<a target="_blank" rel="noopener" href="http://llvm.org/docs/LangRef.html#function-attributes">Function Attributes</a>一节看到。</p>
<p>当函数的属性比较少时，我们可以直接把属性写在函数定义后面，而不用以属性组的形式来写。例如下面这两种写法都是对的：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>() <span class="keyword">nounwind</span> &#123; <span class="keyword">ret</span> void &#125;</span><br><span class="line"><span class="comment">; or</span></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>() <span class="variable">#0</span> &#123; <span class="keyword">ret</span> void &#125;</span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> &#123;</span><br><span class="line">    <span class="keyword">nounwind</span> <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，无论是在代码编译还是在程序分析的过程中，我们最常处理的都在函数级别。因此，属性在这一过程中就是一个非常关键的概念。我们在编译器前端分析的过程中，遇到了特定的函数，给它加上相应的属性；在编译器后端生成代码时，则判断当前函数是否有相应的属性，从而可以在编译器前后端之间传递信息。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>除了函数定义之外，还有一种情况十分常见，那就是函数声明。<strong>我们在一个编译单元（模块）下，可以使用别的模块的函数，这时候就需要在本模块先声明这个函数，才能保证编译时不出错，从而在链接时正确将声明的函数与别的模块下其定义进行链接。</strong></p>
<p>函数声明也相对比较简单，就是使用<code>declare</code>关键词替换<code>define</code>：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="type">i32</span> <span class="title">@printf</span>(<span class="type">i8</span>*<span class="punctuation">,</span> ...) <span class="variable">#1</span></span><br></pre></td></tr></table></figure>

<p>这个就是在C代码中调用<code>stdio.h</code>库的<code>printf</code>函数时，在LLVM IR代码中可以看到的函数声明，其中<code>#1</code>就是又一大串属性组成的属性组。</p>
<h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>在LLVM IR中，函数的调用与高级语言几乎没有什么区别：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span>) &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@bar</span>() &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>call</code>指令可以像高级语言那样直接调用函数。我们来仔细分析一下这里做了哪几件事：</p>
<ul>
<li>传递参数</li>
<li>执行函数</li>
<li>获得返回值</li>
</ul>
<p>居然能干这么多事，这是汇编语言所羡慕不已的。</p>
<h3 id="执行函数"><a href="#执行函数" class="headerlink" title="执行函数"></a>执行函数</h3><p>我们知道，如果一个函数没有任何参数，返回值也是<code>void</code>类型，也就是说在C语言下这个函数是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么调用这个函数就没有了传递参数和获得返回值这两件事，只剩下执行函数，而这是一个最简单的事，以AMD64架构为例：</p>
<ol>
<li>把函数返回地址压栈</li>
<li>跳转到相应函数的地址</li>
</ol>
<p>函数返回也是一个最简单的事：</p>
<ol>
<li>弹栈获得函数返回地址</li>
<li>跳转到相应的返回地址</li>
</ol>
<p>这个在我们的汇编语言基础中已经反复遇到过多次，相信大家都会十分熟练。</p>
<h3 id="传递参数与获得返回值"><a href="#传递参数与获得返回值" class="headerlink" title="传递参数与获得返回值"></a>传递参数与获得返回值</h3><p>谈到这两点，就不得不说调用约定了。我们知道，在汇编语言中，是没有参数传递和返回值的概念的，有的仅仅是让当前的控制流跳转到指定函数执行。所以，一切的参数传递和返回值都需要我们人为约定。也就是说，我们需要约定两件事：</p>
<ul>
<li>被调用的函数希望知道参数是放在哪里的</li>
<li>调用者希望知道调用函数的返回值是放在哪里的</li>
</ul>
<p>这就是调用约定。不同的调用约定会产生不同的特效，也就产生了许多高级语言的feature。</p>
<h4 id="C调用约定"><a href="#C调用约定" class="headerlink" title="C调用约定"></a>C调用约定</h4><p>最广泛使用的调用约定是C调用约定，也就是各个操作系统的标准库使用的调用约定。在AMD64架构下，C调用约定是System V版本的，<strong>所有参数按顺序放入指定寄存器，如果寄存器不够，剩余的则从右往左顺序压栈。而返回值则是按先后顺序放入寄存器或者放入调用者分配的空间中，如果只有一个返回值，那么就会放在<code>rax</code>里。</strong></p>
<p>在LLVM IR中，函数的调用默认使用C调用约定。为了验证，我们可以写一个简单的程序：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; calling_convention_test.ll</span></span><br><span class="line"><span class="variable">%ReturnType</span> <span class="operator">=</span> <span class="keyword">type</span> &#123; <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span> &#125;</span><br><span class="line"><span class="keyword">define</span> <span class="variable">%ReturnType</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a3</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a4</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a5</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a6</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a7</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%a8</span>) &#123;</span><br><span class="line">    <span class="keyword">ret</span> <span class="variable">%ReturnType</span> &#123; <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="variable">%ReturnType</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">3</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">4</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">5</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">6</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">7</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们查看其编译出来的汇编代码。在<code>main</code>函数中，参数传递是：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">movl    <span class="number">$1</span>, %edi</span><br><span class="line">movl    <span class="number">$2</span>, %esi</span><br><span class="line">movl    <span class="number">$3</span>, %edx</span><br><span class="line">movl    <span class="number">$4</span>, %ecx</span><br><span class="line">movl    <span class="number">$5</span>, %r8d</span><br><span class="line">movl    <span class="number">$6</span>, %r9d</span><br><span class="line">movl    <span class="number">$7</span>, (%rsp)</span><br><span class="line">movl    <span class="number">$8</span>, <span class="number">8</span>(%rsp)</span><br><span class="line">callq   foo@PLT</span><br></pre></td></tr></table></figure>

<p>而在<code>foo</code>函数内部，返回值传递是：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl    <span class="number">$1</span>, %eax</span><br><span class="line">movl    <span class="number">$2</span>, %edx</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>

<p>如果大家去查阅System V的指南的话，会发现完全符合。</p>
<p>这种System V的调用约定有什么好处呢？其最大的特点在于，当寄存器数量不够时，剩余的参数是按<strong>从右向左</strong>的顺序压栈。这就让基于这种调用约定的高级语言可以更轻松地实现可变参数的feature。所谓可变参数，最典型的例子就是C语言中的<code>printf</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, a, b, c, d);</span><br></pre></td></tr></table></figure>

<p><code>printf</code>可以接受任意数量的参数，其参数的数量是由第一个参数<code>&quot;%d %d %d %d&quot;</code>决定的。有多少个需要格式化的变量，接下来就还有多少个参数。</p>
<p>那么，System V的调用约定又是为什么能满足这样的需求呢？假设我们不考虑之前传入寄存器内的参数，只考虑压入栈内的参数。那么，如果是从右往左的顺序压栈，栈顶就是<code>&quot;%d %d %d %d&quot;</code>的地址，接着依次是<code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>。那么，我们的程序就可以先读栈顶，获得字符串，然后确定有多少个参数，接着就继续在栈上读多少个参数。相反，如果是从左往右顺序压栈，那么程序第一个读到的是<code>d</code>，程序也不知道该读多少个参数。</p>
<h4 id="fastcc"><a href="#fastcc" class="headerlink" title="fastcc"></a>fastcc</h4><p>各种语言的调用约定还有许多，可以参考语言指南的<a target="_blank" rel="noopener" href="http://llvm.org/docs/LangRef.html#calling-conventions">Calling Conventions</a>一节。把所有的调用约定都讲一遍显然是不可能且枯燥的。所以，我在这里除了C调用约定之外，只再讲一个调用约定fastcc，以体现不同的调用约定能实现不同的高级语言的feature。</p>
<p>fastcc方案是将变量全都传入寄存器中的方案。这种方案使尾调用优化能更方便地实现。</p>
<p>尾调用会出现在很多场景下，用一个比较平凡的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> foo(a - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到，这个函数在返回时有可能会调用自身，这就叫尾调用。为什么尾调用需要优化呢？我们知道，在正常情况下，调用一个函数会产生函数的栈帧，也就是把函数的参数传入栈，把函数的返回地址传入栈。那么如果<code>a</code>很大，那么调用的函数会越来越多，并且直到最后一个被调用的函数返回之前，所有调用的函数的栈都不会回收，也就是说，我们此时栈上充斥着一层一层被调用函数返回的地址。</p>
<p>然而，由于这个函数是在调用者的返回语句里调用，我们实际上可以复用调用者的栈，这就是尾调用优化的基础思想。我们希望，把这样的尾调用变成循环，从而减少栈的使用。通过将参数都传入寄存器，我们可以避免再将参数传入栈，这就是fastcc为尾调用优化提供的帮助。然后，就可以直接将函数调用变成汇编中的<code>jmp</code>。</p>
<p>我们来看如果用fastcc调用约定，LLVM IR该怎么写：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; tail_call_test.ll</span></span><br><span class="line"><span class="keyword">define</span> <span class="keyword">fastcc</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span>) &#123;</span><br><span class="line">    <span class="variable">%res</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">eq</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%res</span><span class="punctuation">,</span> label <span class="variable">%btrue</span><span class="punctuation">,</span> label <span class="variable">%bfalse</span></span><br><span class="line"><span class="symbol">btrue:</span></span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">bfalse:</span></span><br><span class="line">    <span class="variable">%sub</span> <span class="operator">=</span> <span class="keyword">sub</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">    <span class="variable">%tail_call</span> <span class="operator">=</span> <span class="keyword">tail</span> <span class="keyword">call</span> <span class="keyword">fastcc</span> <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%sub</span>)</span><br><span class="line">    <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%tail_call</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>llc</code>对其编译，并加上<code>-tailcallopt</code>的指令（实际上不加也没关系，LLVM后端会自动进行<a target="_blank" rel="noopener" href="http://llvm.org/docs/CodeGenerator.html#sibling-call-optimization">Sibling call optimization</a>）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc tail_call_test.ll -tailcallopt</span><br></pre></td></tr></table></figure>

<p>其编译而成的汇编代码中，其主体为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    cmpl    <span class="number">$1</span>, %edi</span><br><span class="line">    <span class="keyword">jne</span>     .LBB0_2</span><br><span class="line">    movl    <span class="number">$1</span>, %eax</span><br><span class="line">    retq    <span class="number">$8</span></span><br><span class="line"><span class="symbol">.LBB0_2:</span></span><br><span class="line">    pushq   %rax</span><br><span class="line">    decl    %edi</span><br><span class="line">    popq    %rax</span><br><span class="line">    <span class="keyword">jmp</span>     foo@PLT</span><br></pre></td></tr></table></figure>

<p>我们可以发现，在结尾，使用的是<code>jmp</code>而不是<code>call</code>，所以从高级语言的角度，就可以看作其将尾部的调用变成了循环。并且，有两个操作：<code>pushq    %rax</code>和<code>popq    %rax</code>。这两个操作只是为了栈对齐，具体可以参考stack overflow上的回答<a target="_blank" rel="noopener" href="https://stackoverflow.com/a/45823778/10005095">Why does this function push RAX to the stack as the first operation?</a>。</p>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>与控制语句的可视化类似，我们也可以通过LLVM工具链，获得LLVM IR的函数调用图（Call Graph）。</p>
<p>假设我们有以下LLVM IR:</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; cg.ll</span></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo1</span>() &#123;</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@foo4</span>(<span class="type">i32</span> <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@foo2</span>()</span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@foo3</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo4</span>(<span class="type">i32</span> <span class="variable">%0</span>) &#123;</span><br><span class="line">  <span class="variable">%comparison_result</span> <span class="operator">=</span> <span class="keyword">icmp</span> <span class="keyword">sgt</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%comparison_result</span><span class="punctuation">,</span> label <span class="variable">%true_branch</span><span class="punctuation">,</span> label <span class="variable">%false_branch</span></span><br><span class="line"></span><br><span class="line">true_branch:</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@foo1</span>()</span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%final</span></span><br><span class="line"></span><br><span class="line">false_branch:</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@foo2</span>()</span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%final</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">final:</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@foo3</span>()</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>foo4</code>根据输入，调用<code>foo1</code>或者<code>foo2</code>，最终调用<code>foo3</code>。而<code>foo1</code>则递归调用<code>foo4</code>。</p>
<p>对于这样的LLVM IR，我们使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt -p dot-callgraph cg.ll</span><br></pre></td></tr></table></figure>

<p>可以生成一个<code>cg.ll.callgraph.dot</code>的文件。类似CFG，我们可以使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dot cg.ll -Tpng -o cg.png</span><br></pre></td></tr></table></figure>

<p>生成如下图所示的函数调用图：</p>
<p><img src="/paper_source/Classic-Flang%E8%AF%B4%E6%98%8E/callCFG.jpg" alt="Call Graph"></p>
<h2 id="内置函数、属性和元数据"><a href="#内置函数、属性和元数据" class="headerlink" title="内置函数、属性和元数据"></a>内置函数、属性和元数据</h2><p>在LLVM IR中，除了基础的数据表示、控制流之外，还有内置函数、属性和元数据等，能够影响二进制程序生成的功能。</p>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>我们回顾一下，LLVM IR的作用实际上是将编译器前端与后端解耦合。编程语言的前端开发者，负责将输入的编程语言代码进行解析，生成LLVM IR；指令集架构的后端开发者，负责将输入的LLVM IR生成为目标架构的二进制指令。因此，LLVM IR提供了若干非常基础的指令，如<code>add</code>、<code>br</code>、<code>call</code>等。这样做的好处在于：</p>
<ul>
<li>对前端开发者而言，这些指令语义足够全，使用方法也和常见高级语言类似。</li>
<li>对后端开发者而言，这些指令相对数目比较少，提供的功能也相对较为独立，在大部分常见的指令集中都有类似的指令与其对应。</li>
</ul>
<p>但是，这样的策略也有其弊端：</p>
<ul>
<li>对前端开发者而言，仍然有部分通用的语义无法被单个指令所涵盖</li>
<li>对后端开发者而言，对一些通用指令的优化无法针对LLVM IR指令来做</li>
</ul>
<h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a><code>memcpy</code></h3><p>以内存拷贝为例。熟悉AMD64或者AArch64的开发者一定知道，在这些支持向量操作的指令集架构中，大规模的内存拷贝往往是通过向量指令来实现的，Glibc中的<code>memcpy</code>就是这样实现的。</p>
<p>但是对于通用编程语言来说，标准库往往不喜欢直接调用libc中的函数，会产生一些不必要的依赖。并且，<code>memcpy</code>用向量操作来实现已经是一个非常通用的方案了，所以能不能复用一些逻辑呢？</p>
<p>对于此类，LLVM IR指令过于基础，但是却非常广泛地使用同一套实现逻辑的情况，LLVM IR提供了「<a target="_blank" rel="noopener" href="https://llvm.org/docs/LangRef.html#intrinsic-functions">内置函数</a>」（Intrinsic Functions）功能来解决。</p>
<p>所谓内置函数，我们可以理解成一些可以像普通的LLVM IR函数一样调用的函数，但这些函数不需要开发者自己实现，LLVM的后端开发者提供了这些函数的实现。</p>
<p>例如，LLVM IR提供了<a target="_blank" rel="noopener" href="https://llvm.org/docs/LangRef.html#llvm-memcpy-intrinsic"><code>llvm.memcpy</code></a>内置函数，以提供内存的拷贝操作。前端开发者只需要调用这个函数，就可以实现内存拷贝功能了。</p>
<p>我们熟知的Rust语言，在利用LLVM生成二进制程序时，就是使用的这个函数，可以参考其封装的<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/90c541806f23a127002de5b4038be731ba1458ca/compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp#L1448-L1456"><code>LLVMRustBuildMemCpy</code></a>与调用者<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/90c541806f23a127002de5b4038be731ba1458ca/compiler/rustc_codegen_llvm/src/builder.rs#L871-L896"><code>memcpy</code></a>。</p>
<h3 id="静态分支预测"><a href="#静态分支预测" class="headerlink" title="静态分支预测"></a>静态分支预测</h3><p>LLVM IR提供的内置函数有许多，这里，我们再以静态分支预测为例，介绍一个常见内置函数。</p>
<p>我们在阅读一些大规模项目源码时，例如Linux内核源码、QEMU源码等，往往会注意到大量使用的<code>likely</code>与<code>unlikely</code>，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (likely(x &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>likely</code>是什么？它是干什么用的？事实上，<code>likely</code>与<code>unlikely</code>往往是通过宏定义实现的，它们的作用是静态分支预测。</p>
<p>我们知道，对于C语言等常见的编程语言的<code>if</code>语句，在生成二进制程序的时候，我们可以交换它的两个分支的位置。紧接着<code>cmp</code>等判断语句的分支，在执行时，不会发生跳转，而另一个分支则需要设置PC寄存器来跳转。这种跳转往往会造成一定程度的性能损耗，这些具体的我在「<a target="_blank" rel="noopener" href="https://github.com/Evian-Zhang/learn-assembly-on-Apple-Silicon-Mac">在 Apple Silicon Mac 上入门汇编语言</a>」中的<a target="_blank" rel="noopener" href="https://evian-zhang.github.io/learn-assembly-on-Apple-Silicon-Mac/11-%E8%B7%B3%E8%BD%AC.html#%E7%BC%96%E8%AF%91%E6%9C%9F%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B">编译期分支预测</a>一节中有详细阐述。总之，我们需要给编译器一些信息，来排布不同的分支布局。</p>
<p>对于Clang来说，这是通过<a target="_blank" rel="noopener" href="https://llvm.org/docs/BranchWeightMetadata.html#built-in-expect-instructions">内置<code>expect</code>指令</a>来实现的，也就是说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> likely(x)       __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlikely(x)     __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure>

<p>而<code>__builtin_expect</code>这个内置指令，就会翻译为LLVM IR中的<a target="_blank" rel="noopener" href="https://llvm.org/docs/LangRef.html#llvm-expect-intrinsic"><code>llvm.expect</code></a>内置函数，从而实现了静态分支预测。</p>
<h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><p>在C语言中，我们会遇到一个函数的修饰符：<code>inline</code>。这个修饰符会提示编译器，建议编译器在遇到这个函数的调用时，内联这个函数。这类的信息，LLVM会将其看作函数的「<a target="_blank" rel="noopener" href="https://llvm.org/docs/LangRef.html#function-attributes">属性</a>」（Attribtues）。</p>
<p>在之前，我们也提到过，我们可以：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>() attr<span class="number">1</span> attr<span class="number">2</span> attr<span class="number">3</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有多个函数有相同的属性，我们可以用一个属性组的形式来复用：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo1</span>() <span class="variable">#0</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">define</span> void <span class="title">@foo2</span>() <span class="variable">#0</span> &#123;</span><br><span class="line">    <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; attr<span class="number">1</span> attr<span class="number">2</span> attr<span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<p>LLVM支持的函数属性有多种，我们来看看几个比较容易理解的，由函数属性控制的优化：</p>
<h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><p>函数内联是一个非常复杂的概念，这里我们只是简单地来看一下，下面这个C语言代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a)</span> __<span class="title function_">attribute__</span><span class="params">((always_inline))</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里声明了<code>foo</code>函数，并且用了一个扩展语法<code>__attribute__((always_inline))</code>，这个语法实际上的作用就是给函数加上<code>alwaysinline</code>的属性。</p>
<p>我们查看其生成的LLVM IR：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> dso_local <span class="type">i32</span> <span class="title">@foo</span>(<span class="type">i32</span> noundef <span class="variable">%0</span>) <span class="variable">#0</span> &#123;</span><br><span class="line">  <span class="comment">; ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; <span class="keyword">alwaysinline</span> <span class="keyword">nounwind</span> <span class="keyword">uwtable</span> <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span><span class="operator">=</span><span class="string">&quot;0&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span><span class="operator">=</span><span class="string">&quot;true&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span><span class="operator">=</span><span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span><span class="operator">=</span><span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;tune-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;generic&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，其确实有了<code>alwaysinline</code>这个属性。</p>
<h3 id="帧指针清除优化"><a href="#帧指针清除优化" class="headerlink" title="帧指针清除优化"></a>帧指针清除优化</h3><p>我们再来看一个属性控制的优化：帧指针清除优化（Frame Pointer Elimination）。</p>
<p>在讲这个之前，先讲一个比较小的优化。我们将一个非常简单的C程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译为汇编程序，可以发现，<code>foo</code>函数的汇编代码为：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    pushq   %rbp</span><br><span class="line">    <span class="keyword">movq</span>    %rsp, %rbp</span><br><span class="line">    movl    %edi, -<span class="number">4</span>(%rbp)</span><br><span class="line">    movl    %esi, -<span class="number">8</span>(%rbp)</span><br><span class="line">    popq    %rbp</span><br></pre></td></tr></table></figure>

<p>与我们常识有些违背。为啥这里栈不先增加（也就是对<code>rsp</code>寄存器进行<code>sub</code>），就直接把<code>edi</code>, <code>esi</code>的值移入栈内了呢？<code>-4(%rbp)</code>和<code>-8(%rbp)</code>的内存空间此刻似乎并不属于栈。</p>
<p>这是因为，在System V关于amd64架构的标准中，规定了<code>rsp</code>以下128个字节为red zone。这个区域，信号和异常处理函数均不会使用。因此，一个函数可以放心使用<code>rsp</code>以下128个字节的内容。</p>
<p>同时，我们对栈指针进行操作，一个很重要的原因就是为了进一步函数调用的时候，使用<code>call</code>指令会自动将被调用函数的返回地址压栈，那么就需要在调用<code>call</code>指令之前，保证栈顶指针确实指向栈顶，否则压栈就会覆盖一些数据。</p>
<p>但此时，我们的<code>foo</code>函数并没有调用别的函数，也就不会产生压栈行为。因此，如果在栈帧不超过128个字节的情况下，编译器自动为我们省去了这样的操作。为了验证这一点，我们做一个小的修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; bar(); &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，我们再看编译出的<code>foo</code>函数的汇编代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    pushq   %rbp</span><br><span class="line">    <span class="keyword">movq</span>    %rsp, %rbp</span><br><span class="line">    subq    <span class="number">$16</span>, %rsp</span><br><span class="line">    movl    %edi, -<span class="number">4</span>(%rbp)</span><br><span class="line">    movl    %esi, -<span class="number">8</span>(%rbp)</span><br><span class="line">    callq   bar</span><br><span class="line">    addq    <span class="number">$16</span>, %rsp</span><br><span class="line">    popq    %rbp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>

<p>确实增加了对<code>rbp</code>的<code>sub</code>和<code>add</code>操作。而此时的<code>bar</code>函数，也没有对<code>rsp</code>的操作。</p>
<p>接下来，就要讲帧指针清除优化了。经过我们上述的讨论，一个函数在进入时会有一些固定动作：</p>
<ol>
<li>把<code>rbp</code>压栈</li>
<li>把<code>rsp</code>放入<code>rbp</code></li>
<li>减<code>rsp</code>，预留栈空间</li>
</ol>
<p>在函数返回之前，也有其相应的操作：</p>
<ol>
<li>加<code>rsp</code>，回收栈空间</li>
<li>把<code>rbp</code>最初的值弹栈回到<code>rbp</code></li>
</ol>
<p>我们刚刚讲的优化，使得没有调用别的函数的函数，可以省略掉进入时的第3步和返回前的第1步。那么，是否还可以继续省略呢？</p>
<p>那么，我们就要考虑为什么需要这些步骤。这些步骤都是围绕<code>rbp</code>进行的，而正是因为<code>rbp</code>经常进行这种操作，所以我们把<code>rbp</code>称为帧指针。之所以要进行这些操作，是因为我们在函数执行的过程中，栈顶指针随着不断调用别的函数，会不断移动，导致我们根据栈顶指针的位置，不太方便确定局部变量的位置。而如果我们在一开始就把<code>rsp</code>的值放在<code>rbp</code>中，那么局部变量的位置相对<code>rbp</code>是固定的，就更好确认了。注意到我们这里说根据<code>rsp</code>的值确认局部变量的位置只是不方便，但并不是不能做到。所以，我们可以增加一些编译器的负担，而把帧指针清除。</p>
<p>帧指针清除在LLVM IR层面其实十分方便，就是什么都不写。我们可以观察</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%b</span>) &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> ptr <span class="variable">%1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%b</span><span class="punctuation">,</span> ptr <span class="variable">%2</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数在编译成汇编语言之后，是：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    movl    %edi, -<span class="number">4</span>(%rsp)</span><br><span class="line">    movl    %esi, -<span class="number">8</span>(%rsp)</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>

<p>不仅没有了栈的增加减少（之前提过的优化），也没有了对<code>rbp</code>的操作（帧指针清除）。</p>
<p>要想恢复这一操作也十分简单，在函数参数列表后加上一个属性<code>&quot;frame-pointer&quot;=&quot;all&quot;</code>：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@foo</span>(<span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="variable">%b</span>) <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> &#123;</span><br><span class="line">    <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%a</span><span class="punctuation">,</span> ptr <span class="variable">%1</span></span><br><span class="line">    <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%b</span><span class="punctuation">,</span> ptr <span class="variable">%2</span></span><br><span class="line">    <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其编译后的汇编程序就是：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">foo:</span></span><br><span class="line">    pushq   %rbp</span><br><span class="line">    <span class="keyword">movq</span>    %rsp, %rbp</span><br><span class="line">    movl    %edi, -<span class="number">4</span>(%rbp)</span><br><span class="line">    movl    %esi, -<span class="number">8</span>(%rbp)</span><br><span class="line">    popq    %rbp</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure>

<p>恢复了往日的雄风。</p>
<h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>函数的属性可以在前后端之间传递函数的信息，例如，前端发现某个函数需要后端的特殊处理，就给这个函数加一个自定义的属性。而在LLVM的整个管线中的任意一个位置，我们往往都能读到这个属性，从而可以依据是否有这个属性来做特殊的处理&#x2F;优化。正因如此，之所以函数要有属性，是因为函数是LLVM的优化过程中一个非常重要的基础单元，因此需要保留各种信息。</p>
<p>除此之外，我们有时也会希望每一条指令，或者每一个翻译单元，都可以有类似属性一样的信息，可以在管线中传递&#x2F;过滤，从而能获得一些信息。这在LLVM IR中被称为「<a target="_blank" rel="noopener" href="https://llvm.org/docs/LangRef.html#metadata">元数据</a>」（Metadata）。</p>
<h3 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h3><p>说了这么多，元数据具体有什么用处呢？元数据的语法又是怎样的呢？我们来看一个具体的例子。</p>
<p>我们知道，在Clang中，传入<code>-g</code>选项可以生成调试信息。那么，调试信息是怎么在LLVM IR中体现的呢？</p>
<p>我们这样一个<code>debug.c</code>文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang debug.c -g -S -emit-llvm</span><br></pre></td></tr></table></figure>

<p>生成LLVM IR文件，其一部分如下：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local <span class="type">i32</span> <span class="title">@sum</span>(<span class="type">i32</span> noundef <span class="variable">%0</span><span class="punctuation">,</span> <span class="type">i32</span> noundef <span class="variable">%1</span>) <span class="variable">#0</span> <span class="title">!dbg</span> <span class="title">!10</span> &#123;</span><br><span class="line">  <span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="variable">%4</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> ptr <span class="variable">%3</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.dbg.declare</span>(metadata ptr <span class="variable">%3</span><span class="punctuation">,</span> metadata <span class="title">!15</span><span class="punctuation">,</span> metadata <span class="title">!DIExpression</span>())<span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!16</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%1</span><span class="punctuation">,</span> ptr <span class="variable">%4</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.dbg.declare</span>(metadata ptr <span class="variable">%4</span><span class="punctuation">,</span> metadata <span class="title">!17</span><span class="punctuation">,</span> metadata <span class="title">!DIExpression</span>())<span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!18</span></span><br><span class="line">  <span class="variable">%5</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%3</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span><span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!19</span></span><br><span class="line">  <span class="variable">%6</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> ptr <span class="variable">%4</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span><span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!20</span></span><br><span class="line">  <span class="variable">%7</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="keyword">nsw</span> <span class="type">i32</span> <span class="variable">%5</span><span class="punctuation">,</span> <span class="variable">%6</span><span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!21</span></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%7</span><span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"></span><br><span class="line"><span class="title">!llvm.dbg.cu</span> <span class="operator">=</span> !&#123;<span class="title">!0</span>&#125;</span><br><span class="line"><span class="title">!llvm.module.flags</span> <span class="operator">=</span> !&#123;<span class="title">!2</span><span class="punctuation">,</span> <span class="title">!3</span><span class="punctuation">,</span> <span class="title">!4</span><span class="punctuation">,</span> <span class="title">!5</span><span class="punctuation">,</span> <span class="title">!6</span><span class="punctuation">,</span> <span class="title">!7</span><span class="punctuation">,</span> <span class="title">!8</span>&#125;</span><br><span class="line"><span class="title">!llvm.ident</span> <span class="operator">=</span> !&#123;<span class="title">!9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!0</span> <span class="operator">=</span> distinct <span class="title">!DICompileUnit</span>(language: DW_LANG_C<span class="number">11</span><span class="punctuation">,</span> file: <span class="title">!1</span><span class="punctuation">,</span> producer: <span class="string">&quot;Homebrew clang version 16.0.6&quot;</span><span class="punctuation">,</span> isOptimized: <span class="keyword">false</span><span class="punctuation">,</span> runtimeVersion: <span class="number">0</span><span class="punctuation">,</span> emissionKind: FullDebug<span class="punctuation">,</span> splitDebugInlining: <span class="keyword">false</span><span class="punctuation">,</span> nameTableKind: None)</span><br><span class="line"><span class="title">!1</span> <span class="operator">=</span> <span class="title">!DIFile</span>(filename: <span class="string">&quot;debug.c&quot;</span><span class="punctuation">,</span> directory: <span class="string">&quot;...&quot;</span><span class="punctuation">,</span> checksumkind: CSK_MD<span class="number">5</span><span class="punctuation">,</span> checksum: <span class="string">&quot;...&quot;</span>)</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="title">!10</span> <span class="operator">=</span> distinct <span class="title">!DISubprogram</span>(name: <span class="string">&quot;sum&quot;</span><span class="punctuation">,</span> scope: <span class="title">!1</span><span class="punctuation">,</span> file: <span class="title">!1</span><span class="punctuation">,</span> line: <span class="number">1</span><span class="punctuation">,</span> <span class="keyword">type</span>: <span class="title">!11</span><span class="punctuation">,</span> scopeLine: <span class="number">1</span><span class="punctuation">,</span> flags: DIFlagPrototyped<span class="punctuation">,</span> spFlags: DISPFlagDefinition<span class="punctuation">,</span> unit: <span class="title">!0</span><span class="punctuation">,</span> retainedNodes: <span class="title">!14</span>)</span><br><span class="line"><span class="title">!11</span> <span class="operator">=</span> <span class="title">!DISubroutineType</span>(types: <span class="title">!12</span>)</span><br><span class="line"><span class="title">!12</span> <span class="operator">=</span> !&#123;<span class="title">!13</span><span class="punctuation">,</span> <span class="title">!13</span><span class="punctuation">,</span> <span class="title">!13</span>&#125;</span><br><span class="line"><span class="title">!13</span> <span class="operator">=</span> <span class="title">!DIBasicType</span>(name: <span class="string">&quot;int&quot;</span><span class="punctuation">,</span> size: <span class="number">32</span><span class="punctuation">,</span> encoding: DW_ATE_signed)</span><br><span class="line"><span class="title">!14</span> <span class="operator">=</span> !&#123;&#125;</span><br><span class="line"><span class="title">!15</span> <span class="operator">=</span> <span class="title">!DILocalVariable</span>(name: <span class="string">&quot;a&quot;</span><span class="punctuation">,</span> arg: <span class="number">1</span><span class="punctuation">,</span> scope: <span class="title">!10</span><span class="punctuation">,</span> file: <span class="title">!1</span><span class="punctuation">,</span> line: <span class="number">1</span><span class="punctuation">,</span> <span class="keyword">type</span>: <span class="title">!13</span>)</span><br><span class="line"><span class="title">!16</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">1</span><span class="punctuation">,</span> column: <span class="number">13</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!17</span> <span class="operator">=</span> <span class="title">!DILocalVariable</span>(name: <span class="string">&quot;b&quot;</span><span class="punctuation">,</span> arg: <span class="number">2</span><span class="punctuation">,</span> scope: <span class="title">!10</span><span class="punctuation">,</span> file: <span class="title">!1</span><span class="punctuation">,</span> line: <span class="number">1</span><span class="punctuation">,</span> <span class="keyword">type</span>: <span class="title">!13</span>)</span><br><span class="line"><span class="title">!18</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">1</span><span class="punctuation">,</span> column: <span class="number">20</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!19</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">2</span><span class="punctuation">,</span> column: <span class="number">12</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!20</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">2</span><span class="punctuation">,</span> column: <span class="number">16</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!21</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">2</span><span class="punctuation">,</span> column: <span class="number">14</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br><span class="line"><span class="title">!22</span> <span class="operator">=</span> <span class="title">!DILocation</span>(line: <span class="number">2</span><span class="punctuation">,</span> column: <span class="number">5</span><span class="punctuation">,</span> scope: <span class="title">!10</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在生成的LLVM IR中，出现了大量以<code>!</code>开头的符号，这就是元数据的语法。</p>
<p>具体而言，我们看到其中的</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">!12</span> <span class="operator">=</span> !&#123;<span class="title">!13</span><span class="punctuation">,</span> <span class="title">!13</span><span class="punctuation">,</span> <span class="title">!13</span>&#125;</span><br><span class="line"><span class="title">!13</span> <span class="operator">=</span> <span class="title">!DIBasicType</span>(name: <span class="string">&quot;int&quot;</span><span class="punctuation">,</span> size: <span class="number">32</span><span class="punctuation">,</span> encoding: DW_ATE_signed)</span><br></pre></td></tr></table></figure>

<p>这里，<code>!13 = ...</code>生成了一个元数据，其内容为一个给定的结构体<code>DIBasicType</code>，而<code>!12</code>这个元数据的内容，则并不是一个给定的结构体，而是由三个<code>!13</code>这个元数据组成的结构。也就是说，元数据的组织相对比较灵活。</p>
<p>在<code>sum</code>函数体中，我们可以看到，几乎每条指令后都附加了一个元数据，在代码下半部分找到对应的元数据，其实就是这行指令对应C语言中源代码里的位置，也就是调试信息中的location。</p>
<p>此外，我们还可以看到<code>llvm.dbg.declare</code>内置函数的调用。这个函数的作用是标记源代码中变量的地址。例如：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> ptr <span class="variable">%3</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">call</span> void <span class="title">@llvm.dbg.declare</span>(metadata ptr <span class="variable">%3</span><span class="punctuation">,</span> metadata <span class="title">!15</span><span class="punctuation">,</span> metadata <span class="title">!DIExpression</span>())<span class="punctuation">,</span> <span class="title">!dbg</span> <span class="title">!16</span></span><br></pre></td></tr></table></figure>

<p>这里就是指，源代码中位于<code>!15</code>元数据处的变量，也就是<code>a</code>，其在生成的二进制程序中，位于<code>%3</code>变量。</p>
<p>LLVM中的调试信息非常全面且复杂，具体可以看官方文档<a target="_blank" rel="noopener" href="https://llvm.org/docs/SourceLevelDebugging.html">Source Level Debugging with LLVM</a>。</p>
<h3 id="控制流完整性"><a href="#控制流完整性" class="headerlink" title="控制流完整性"></a>控制流完整性</h3><p>元数据的另一个用途，就在于控制流完整性保护。当一个攻击者攻击一个二进制程序的时候，最低级的攻击者只是让它崩溃，造成DoS攻击。高级的攻击者，往往想让这个程序执行自己想让它执行的命令。而这一途径，在现代攻击环境下，往往是通过函数指针覆盖来实现的。</p>
<p>举一个例子来说，在前几年，有一个非常著名的漏洞<a target="_blank" rel="noopener" href="https://twitter.com/axi0mX/status/1177542201670168576?s=20">checkm8</a>。这个漏洞可以攻击苹果的大部分iPhone设备，并且由于代码处于ROM中，所以被认为无法修复。其具体的分析可以看<a target="_blank" rel="noopener" href="https://habr.com/en/companies/dsec/articles/472762/">Technical analysis of the checkm8 exploit</a>和<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/87456653">iPhone史诗级漏洞checkm8攻击原理浅析 - Gh0u1L5的文章 - 知乎</a>。我们这里只需要了解一点，它的核心是，Apple代码中有一个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device_io_request</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *callback;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里<code>callback</code>是一个函数指针，在程序执行中会被调用。攻击者通过某种方法，强行覆盖了这个函数指针的值，从而让程序执行自己想要执行的函数。</p>
<p>为了抵御这种攻击，我们往往会采用控制流完整性（Control Flow Integrity, CFI）策略。最简单的思路是，我们在写程序时，函数指针所指向的函数，肯定是有限个确定的函数。那么，我们可以在执行函数指针所对应的间接调用时，检查调用目标是否是那有限个确定的函数，就可以保证不会出现之前的这种问题了。</p>
<p>但是，如何确定这个函数指针究竟能指向哪些函数呢？这个问题非常复杂，编译器往往是做不到这件事的。因此，现在一般会使用比较弱化的控制流完整性策略。在LLVM中，我们可以通过传递<code>-fsanitize=cfi-icall</code>来启用LLVM-CFI所提供的控制流完整性策略（需要同时通过<code>-flto</code>开启LTO），例如，我们有以下程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*f)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo1</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo2</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> a)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">baz</span><span class="params">(f func)</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将其保存为<code>cfi.c</code>，然后在命令行中使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang cfi.c -flto -fsanitize=cfi-icall -S -emit-llvm</span><br></pre></td></tr></table></figure>

<p>可以生成一个开启了LLVM-CFI策略的LLVM IR代码。</p>
<p>那么，LLVM-CFI策略是什么呢？由于其相对比较复杂，具体可以参考<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ControlFlowIntegrityDesign.html">Control Flow Integrity Design Documentation</a>，我们这里只是非常粗略地讲。</p>
<p>在上述代码中，<code>baz</code>函数接收一个函数指针，然后调用了这个函数指针。这个函数指针的类型是，不接收参数，也没有返回值。而LLVM-CFI采用的策略则是，只要满足这个类型的函数，都被认为是可以被函数指针所指向的。反之，如果不满足，则被拒绝。也就是说，在这个代码中，<code>foo1</code>、<code>foo2</code>都是满足的，而<code>bar</code>函数，因为它接收一个<code>int</code>类型的参数，所以不满足。</p>
<p>那么，具体是怎么实现的呢？我们来看看它的LLVM IR代码，其一部分为：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@foo1</span>() <span class="variable">#0</span> <span class="title">!type</span> <span class="title">!9</span> <span class="title">!type</span> <span class="title">!10</span> &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@foo2</span>() <span class="variable">#0</span> <span class="title">!type</span> <span class="title">!9</span> <span class="title">!type</span> <span class="title">!10</span> &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@bar</span>(<span class="type">i32</span> noundef <span class="variable">%0</span>) <span class="variable">#0</span> <span class="title">!type</span> <span class="title">!11</span> <span class="title">!type</span> <span class="title">!12</span> &#123;</span><br><span class="line">  <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="variable">%0</span><span class="punctuation">,</span> ptr <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local void <span class="title">@baz</span>(ptr noundef <span class="variable">%0</span>) <span class="variable">#0</span> <span class="title">!type</span> <span class="title">!13</span> <span class="title">!type</span> <span class="title">!14</span> &#123;</span><br><span class="line">  <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">alloca</span> ptr<span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">store</span> ptr <span class="variable">%0</span><span class="punctuation">,</span> ptr <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">load</span> ptr<span class="punctuation">,</span> ptr <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%4</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i1</span> <span class="title">@llvm.type.test</span>(ptr <span class="variable">%3</span><span class="punctuation">,</span> metadata !<span class="string">&quot;_ZTSFvvE&quot;</span>)<span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%4</span><span class="punctuation">,</span> label <span class="variable">%6</span><span class="punctuation">,</span> label <span class="variable">%5</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>:                                                <span class="comment">; preds = %1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.ubsantrap</span>(<span class="type">i8</span> <span class="number">2</span>) <span class="variable">#3</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line">  <span class="keyword">unreachable</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>:                                                <span class="comment">; preds = %1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="variable">%3</span>()</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!9</span> <span class="operator">=</span> !&#123;<span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> !<span class="string">&quot;_ZTSFvvE&quot;</span>&#125;</span><br><span class="line"><span class="title">!10</span> <span class="operator">=</span> !&#123;<span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> !<span class="string">&quot;_ZTSFvvE.generalized&quot;</span>&#125;</span><br><span class="line"><span class="title">!11</span> <span class="operator">=</span> !&#123;<span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> !<span class="string">&quot;_ZTSFviE&quot;</span>&#125;</span><br><span class="line"><span class="title">!12</span> <span class="operator">=</span> !&#123;<span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> !<span class="string">&quot;_ZTSFviE.generalized&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在<code>baz</code>函数中，在调用这个函数指针，也就是<code>call void %3()</code>之前，被插入了一部分代码：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">load</span> ptr<span class="punctuation">,</span> ptr <span class="variable">%2</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">8</span></span><br><span class="line">  <span class="variable">%4</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i1</span> <span class="title">@llvm.type.test</span>(ptr <span class="variable">%3</span><span class="punctuation">,</span> metadata !<span class="string">&quot;_ZTSFvvE&quot;</span>)<span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%4</span><span class="punctuation">,</span> label <span class="variable">%6</span><span class="punctuation">,</span> label <span class="variable">%5</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line"><span class="number">5</span>:                                                <span class="comment">; preds = %1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@llvm.ubsantrap</span>(<span class="type">i8</span> <span class="number">2</span>) <span class="variable">#3</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br><span class="line">  <span class="keyword">unreachable</span><span class="punctuation">,</span> <span class="title">!nosanitize</span> <span class="title">!15</span></span><br></pre></td></tr></table></figure>

<p>在这里，首先调用了<code>llvm.type.test</code>这个内置函数。这个内置函数的作用是查看<code>ptr %3</code>这个函数的类型，是否是<code>!&quot;_ZTSFvvE&quot;</code>这个元数据所代表的类型，如果不是的话，就跳转，调用<code>llvm.ubsantrap</code>报告错误。而我们可以看到，<code>foo1</code>、<code>foo2</code>、<code>bar</code>都被附加了一些元数据，查看代码的下半部分，可以看到，<code>foo1</code>、<code>foo2</code>的元数据是<code>!&quot;_ZTSFvvE&quot;</code>，而<code>bar</code>的元数据是<code>!&quot;_ZTSFviE&quot;</code>。因此，如果攻击者想让这个间接调用前往<code>bar</code>函数，就会被拒绝，从而保护了控制流的完整性。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/project/" rel="tag"># project</a>
              <a href="/tags/Flang/" rel="tag"># Flang</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/07/14/%E5%92%8C%E7%AC%A6%E8%80%81%E5%B8%88%E8%AE%A8%E8%AE%BA/" rel="prev" title="和符老师讨论">
                  <i class="fa fa-chevron-left"></i> 和符老师讨论
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/09/05/clion%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="next" title="clion的使用">
                  clion的使用 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zoush99</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>Word count total: </span>
    <span title="Word count total">79k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>Reading time total &asymp;</span>
    <span title="Reading time total">2:23</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
